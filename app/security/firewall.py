"""Lightweight in-process firewall middleware.

This implements a low-overhead per-process IP rate limiter and temporary ban list.
It's designed to be cheap (in-memory dicts, lazy cleanup) and safe to run in the
Flask process. For production-scale DDoS protection use a reverse proxy (nginx,
Cloudflare, AWS Shield) or a shared rate-limiter (Redis) â€” documented in
help/FIREWALL.md.
"""
import time
import threading
from flask import request, jsonify
from flask import abort
from flask_socketio import disconnect


class Firewall:
    def __init__(self, app=None, socketio=None):
        self.lock = threading.Lock()
        # Per-ip counters: ip -> (count, window_start)
        self.counters = {}
        # Banned ips: ip -> ban_until_timestamp
        self.banned = {}
        # Default configuration - can be overridden via app.config
        self.default_config = {
            # Default to disabled in this deployment; enable explicitly via
            # application config or at runtime with Firewall.enable().
            'FIREWALL_ENABLED': False,
            # Default rate limit: allow a healthy burst of requests per minute.
            # Increased from 20 to 1000 to accommodate page loads + assets.
            'FIREWALL_RATE_LIMIT': 1000,   # requests
            'FIREWALL_WINDOW': 60,       # seconds
            'FIREWALL_BAN_TIME': 300,    # seconds to ban IP on violation
            'FIREWALL_WHITELIST': [],
            'FIREWALL_BLACKLIST': [],
            'FIREWALL_TRUSTED_PROXIES': [],  # list of trusted proxy IPs to consider for X-Forwarded-For
            # Paths and file extensions to ignore from rate limiting (assets, service workers, etc.)
            'FIREWALL_EXCLUDE_EXTENSIONS': ['.css', '.js', '.png', '.jpg', '.jpeg', '.gif', '.ico', '.svg', '.woff', '.woff2', '.ttf', '.map', '.webp'],
            'FIREWALL_EXCLUDE_PATH_PREFIXES': ['/static/', '/assets/', '/uploads/', '/sw.js', '/pwa', '/manifest.json'],
            'FIREWALL_EXCLUDE_METHODS': ['OPTIONS', 'HEAD']
        }
        self.app = None
        if app is not None:
            self.init_app(app, socketio)

    # Runtime control helpers -------------------------------------------------
    def enable(self):
        """Enable the in-process firewall at runtime.

        This flips the app config value if an app was provided and logs the
        transition. It is safe to call from application code that holds
        appropriate privileges.
        """
        if self.app is not None:
            self.app.config['FIREWALL_ENABLED'] = True
            try:
                self.app.logger.info('Firewall: enabled at runtime')
            except Exception:
                pass

    def disable(self):
        """Disable the in-process firewall at runtime.

        Use this when testing or when an external firewall is protecting the
        deployment and the in-process limiter is not desired.
        """
        if self.app is not None:
            self.app.config['FIREWALL_ENABLED'] = False
            try:
                self.app.logger.info('Firewall: disabled at runtime')
            except Exception:
                pass

    def is_enabled(self):
        """Return whether the firewall is currently enabled (bool)."""
        if self.app is None:
            return bool(self.default_config.get('FIREWALL_ENABLED', False))
        return bool(self.app.config.get('FIREWALL_ENABLED', False))

    def _now(self):
        return time.monotonic()

    def _get_remote_ip(self):
        # Respect X-Forwarded-For but only pick the left-most address
        # if request came through trusted proxies. If no trusted proxies
        # configured, prefer X-Forwarded-For anyway but warn in docs.
        ip = None
        try:
            xff = request.headers.get('X-Forwarded-For', '')
            if xff:
                # Many proxies append; first is original client
                ip = xff.split(',')[0].strip()
        except Exception:
            ip = None

        if not ip:
            try:
                ip = request.remote_addr
            except Exception:
                ip = '0.0.0.0'
        return ip

    def init_app(self, app, socketio=None):
        # Load defaults into app.config if not present
        for k, v in self.default_config.items():
            app.config.setdefault(k, v)

        self.app = app

        @app.before_request
        def _firewall_before_request():
            # Very small, fast checks on each HTTP request
            if not app.config.get('FIREWALL_ENABLED', True):
                return None

            ip = self._get_remote_ip()
            if not ip:
                return None

            # Quickly ignore requests that are commonly generated by normal page loads
            # (static assets, service worker, preflight/HEAD). These should not count
            # towards rate limits so a single page load doesn't trigger a ban.
            try:
                method = (request.method or '').upper()
                if method in app.config.get('FIREWALL_EXCLUDE_METHODS', []):
                    return None
                path = request.path or ''
                # Path prefix exclusions
                for pfx in app.config.get('FIREWALL_EXCLUDE_PATH_PREFIXES', []) or []:
                    if path.startswith(pfx):
                        return None
                # Extension-based exclusions
                lower = path.lower()
                for ext in app.config.get('FIREWALL_EXCLUDE_EXTENSIONS', []) or []:
                    if lower.endswith(ext):
                        return None
            except Exception:
                # Don't let exclusion checks break requests
                pass

            # Whitelist/blacklist checks
            if ip in app.config.get('FIREWALL_WHITELIST', []):
                return None

            if ip in app.config.get('FIREWALL_BLACKLIST', []):
                return abort(403)

            now = self._now()

            # Check ban list
            ban_until = None
            with self.lock:
                ban_until = self.banned.get(ip)

            if ban_until and ban_until > now:
                # Still banned
                return jsonify({'error': 'temporarily banned'}), 429
            elif ban_until and ban_until <= now:
                # Lift ban lazily
                with self.lock:
                    try:
                        del self.banned[ip]
                    except KeyError:
                        pass

            # Rate limiting counter update
            window = float(app.config.get('FIREWALL_WINDOW', 60))
            limit = int(app.config.get('FIREWALL_RATE_LIMIT', 60))
            ban_time = float(app.config.get('FIREWALL_BAN_TIME', 300))

            with self.lock:
                count, start = self.counters.get(ip, (0, now))
                if now - start > window:
                    # Reset window
                    count = 1
                    start = now
                else:
                    count = count + 1

                self.counters[ip] = (count, start)

                # Lazy cleanup to keep dicts small: if counters grow very large,
                # we only clean when we see an entry exceed limit * 10 (rare path)
                if len(self.counters) > 100000:
                    # Snapshot keys and remove expired
                    keys = list(self.counters.keys())
                    cutoff = now - (window * 2)
                    for k in keys:
                        _, s = self.counters.get(k, (0, 0))
                        if s < cutoff:
                            try:
                                del self.counters[k]
                            except KeyError:
                                pass

                if count > limit:
                    # Violation: add to ban list
                    self.banned[ip] = now + ban_time
                    # Optionally remove counters for IP to save memory
                    try:
                        del self.counters[ip]
                    except KeyError:
                        pass
                    app.logger.warning('Firewall: banning %s for %s seconds', ip, ban_time)
                    return jsonify({'error': 'rate limit exceeded', 'ban_seconds': int(ban_time)}), 429

            # Allow request to continue
            return None

        # SocketIO connect handler to pre-check incoming socket connections
        if socketio is not None:
            @socketio.on('connect')
            def _socketio_connect_handler(environ=None, auth=None):
                # environ is available via request.environ in contexts
                try:
                    if not app.config.get('FIREWALL_ENABLED', True):
                        return None
                    # remote address may be in environ
                    ip = None
                    if environ and isinstance(environ, dict):
                        ip = environ.get('REMOTE_ADDR') or environ.get('HTTP_X_FORWARDED_FOR')
                        if isinstance(ip, str) and ',' in ip:
                            ip = ip.split(',')[0].strip()
                    if not ip:
                        try:
                            ip = request.remote_addr
                        except Exception:
                            ip = None

                    if not ip:
                        return None

                    if ip in app.config.get('FIREWALL_WHITELIST', []):
                        return None
                    if ip in app.config.get('FIREWALL_BLACKLIST', []):
                        disconnect()
                        return None

                    now = self._now()
                    ban_until = None
                    with self.lock:
                        ban_until = self.banned.get(ip)
                    if ban_until and ban_until > now:
                        # actively ban socket connection
                        app.logger.info('Firewall: rejected SocketIO connect from %s (banned)', ip)
                        disconnect()
                        return None
                except Exception:
                    # Never raise from firewall into app - fail-open for stability
                    return None

        # Expose the firewall instance on app for diagnostics
        app.firewall = self
