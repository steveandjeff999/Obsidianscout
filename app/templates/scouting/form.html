{% extends 'base.html' %}

{% block title %}Scouting Form{% endblock %}

{% block heading %}Scouting Form{% endblock %}
{% block extra_css %}
<link rel="stylesheet" href="{{ url_for('static', filename='css/scouting_form.css') }}">
{% endblock %}
{% block subheading %}
<div id="form-subheading" class="text-muted mb-4">Select team and match below</div>
{% endblock %}

{% block content %}
<div class="row">
    <div class="col-md-12">
    <!-- Team and Match Selection -->
    <div class="card mb-4 navbar-glass">
            <div class="card-header bg-primary text-white">
                <h5 class="mb-0">Select Team and Match</h5>
            </div>
            <div class="card-body">
                <form id="team-match-form" aria-label="Team and Match selection">
                    <div class="row">
                        <div class="col-md-6 mb-2">
                            <label for="match-selector" class="form-label">Select Match</label>
                            <!-- Search input for matches -->
                            <div class="input-group mb-1">
                                <span class="input-group-text"><i class="fas fa-search"></i></span>
                                <input type="search" id="match-search" class="form-control form-control-sm" placeholder="Search matches by type or number" aria-label="Search matches">
                            </div>
                            <select class="form-select" id="match-selector" name="match_id" required aria-required="true" aria-label="Match selector">
                                <option value="">-- Select Match --</option>
                                {% for match_option in matches %}
                                <option value="{{ match_option.id }}" data-match-type="{{ match_option.match_type }}" data-match-number="{{ match_option.match_number }}" data-red-alliance="{{ match_option.red_alliance }}" data-blue-alliance="{{ match_option.blue_alliance }}" {% if match and match.id == match_option.id %}selected{% endif %}>
                                    {{ match_option.match_type }} {{ match_option.match_number }}
                                </option>
                                {% endfor %}
                            </select>
                        </div>
                        <div class="col-md-6 mb-2">
                            <label for="team-selector" class="form-label">Select Team</label>
                            <!-- Search input for teams -->
                            <div class="input-group mb-1">
                                <span class="input-group-text"><i class="fas fa-search"></i></span>
                                <input type="search" id="team-search" class="form-control form-control-sm" placeholder="Search teams by number or name" aria-label="Search teams">
                            </div>
                            <select class="form-select" id="team-selector" name="team_id" required aria-label="Team selector">
                                <option value="">-- Select Team --</option>
                                {% for team_option in teams %}
                                <option value="{{ team_option.id }}" data-team-number="{{ team_option.team_number }}" data-team-name="{{ team_option.team_name }}" {% if team and team.id == team_option.id %}selected{% endif %}>
                                    {{ team_option.team_number }} - {{ team_option.team_name }}
                                </option>
                                {% endfor %}
                            </select>
                        </div>
                        <!-- Quick prediction UI removed -->
                    </div>
                </form>
            </div>
        </div>

        <!-- Form Content Container -->
        <div id="form-content">
            {% if team and match %}
                {% include "scouting/partials/form_content.html" %}
            {% else %}
            <!-- Empty Form State -->
            <div class="alert alert-info text-center py-4">
                <i class="fas fa-info-circle fa-3x mb-3"></i>
                <h4>Please select a team and match above</h4>
                <p class="mb-0">The form will automatically update when both are selected.</p>
            </div>
            {% endif %}
        </div>
    </div>
</div>

<!-- QR Code Container (initially hidden) -->
<div class="modal fade" id="qrModal" tabindex="-1" aria-hidden="true">
    <div class="modal-dialog modal-dialog-centered">
        <div class="modal-content">
            <div class="modal-header">
                <h5 class="modal-title">
                    <i class="fas fa-qrcode me-2"></i> QR Code for Match Data
                </h5>
                <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
            </div>
            <div class="modal-body">
                <div class="qr-container">
                    <div id="qrcode" class="mb-3"></div>
                    <div id="qrDownloadContainer" class="text-center d-none">
                        <button type="button" class="btn btn-primary">
                            <i class="fas fa-download me-2"></i> Download QR Code
                        </button>
                    </div>
                </div>
            </div>
        </div>
    </div>
</div>

<!-- Status Toast Container -->
<div class="toast-container position-fixed bottom-0 end-0 p-3">
  <!-- Toasts will be inserted here dynamically -->
</div>
{% endblock %}

{% block extra_js %}
<!-- Inject game config into page for offline use -->
<script>
    window.gameConfig = {{ game_config | tojson | safe }};
</script>

<!-- Offline scouting form manager -->
<script src="{{ url_for('static', filename='js/scouting_form_offline.js') }}"></script>

<script>
    document.addEventListener('DOMContentLoaded', function() {
        // Load form offline using cached data
        function loadFormOffline(offlineData, savedScrollY, savedActiveId) {
            console.log('[Offline Mode] Loading form from cached data...');
            
            const formContent = document.getElementById('form-content');
            const { team, match, html, cached, needsReset } = offlineData;
            
            // Update subheading
            document.getElementById('form-subheading').textContent = 
                `${team.team_number} - ${team.team_name} | ${match.match_type} ${match.match_number}`;
            
            let formHTML;
            
            // If we have cached server-rendered HTML, use it directly
            if (cached && html) {
                console.log('[Offline Mode] Using cached universal form template');
                
                // Add offline indicator banner
                const offlineBanner = `
                    <div class="alert alert-info alert-dismissible fade show mb-3">
                        <i class="fas fa-wifi-slash me-2"></i>
                        <strong>Offline Mode</strong> - Form loaded from cache. 
                        Data will be saved locally and synced when connection is restored.
                        <button type="button" class="btn-close" data-bs-dismiss="alert" aria-label="Close"></button>
                    </div>
                `;
                
                formHTML = offlineBanner + html;
            } else {
                // Fallback: generate form from game config
                console.log('[Offline Mode] Generating form from game config');
                formHTML = generateOfflineFormHTML(team, match, offlineData.gameConfig);
            }
            
            // Preserve current auto timer toggle state (if user toggled before load) so it isn't lost when we overwrite the form
            try {
                const existingToggle = document.getElementById('auto_period_timer_enabled');
                if (existingToggle) {
                    // Use the same key as the main scripts to keep behavior consistent
                    localStorage.setItem('auto_period_timer_enabled', existingToggle.checked ? 'true' : 'false');
                    console.log('[Offline Mode] Preserved existing auto timer toggle state before injecting form HTML');
                }
            } catch (e) {
                // ignore
            }

            formContent.innerHTML = formHTML;
            
            // Determine alliance color from match schedule
            const alliance = determineAlliance(team.team_number, match);
            console.log('[Offline Mode] Determined alliance:', alliance);
            
            // Update alliance indicator
            updateAllianceIndicator(alliance, team, match);
            
            // Update hidden fields with correct team/match data
            const scoutingForm = document.getElementById('scouting-form');
            if (scoutingForm) {
                scoutingForm.dataset.offline = 'true';
                
                // Update or create hidden fields
                updateOrCreateHiddenField(scoutingForm, 'team_id', team.id);
                updateOrCreateHiddenField(scoutingForm, 'match_id', match.id);
                updateOrCreateHiddenField(scoutingForm, 'team_number', team.team_number);
                updateOrCreateHiddenField(scoutingForm, 'match_number', match.match_number);
                updateOrCreateHiddenField(scoutingForm, 'match_type', match.match_type);
                updateOrCreateHiddenField(scoutingForm, 'alliance', alliance);
            }
            
            // Initialize form components immediately after DOM update
            setTimeout(() => {
                initializeFormComponents();

                // Reset all form values to defaults if using cached template
                if (needsReset) {
                    console.log('[Offline Mode] Resetting form values to defaults');
                    resetFormToDefaults();
                }

                // Ensure the auto-period-timer toggle is restored and persists across loads
                try {
                    setupAutoTimerTogglePersistence();
                } catch (e) {
                    console.warn('Could not setup auto timer toggle persistence', e);
                }

                // Enable save button in offline mode
                const saveBtn = document.getElementById('save-button');
                if (saveBtn) {
                    saveBtn.disabled = false;
                }

                // Restore scroll and focus
                try {
                    if (typeof window.safeRestoreScroll === 'function') {
                        window.safeRestoreScroll(savedScrollY, { behavior: 'auto', timeout: 300 });
                    }
                } catch (e) {
                    console.warn('Could not restore scroll position', e);
                }

                if (savedActiveId) {
                    try {
                        const prev = document.getElementById(savedActiveId);
                        if (prev && typeof prev.focus === 'function') {
                            prev.focus({ preventScroll: true });
                        }
                    } catch (e) {
                        // ignore
                    }
                }
            }, 50);
        }
        
        // Helper function to update or create hidden field
        function updateOrCreateHiddenField(form, name, value) {
            let field = form.querySelector(`input[name="${name}"]`);
            if (!field) {
                field = document.createElement('input');
                field.type = 'hidden';
                field.name = name;
                form.appendChild(field);
            }
            field.value = value;
        }
        
        // Determine alliance color from match schedule data
        function determineAlliance(teamNumber, match) {
            const teamNumStr = String(teamNumber);
            
            // Check red alliance
            if (match.red_alliance) {
                const redTeams = match.red_alliance.split(',').map(t => t.trim());
                if (redTeams.includes(teamNumStr)) {
                    return 'red';
                }
            }
            
            // Check blue alliance
            if (match.blue_alliance) {
                const blueTeams = match.blue_alliance.split(',').map(t => t.trim());
                if (blueTeams.includes(teamNumStr)) {
                    return 'blue';
                }
            }
            
            return 'unknown';
        }
        
        // Update the alliance indicator UI
        function updateAllianceIndicator(alliance, team, match) {
            const indicator = document.querySelector('.alliance-indicator');
            if (!indicator) return;
            
            // Remove existing alliance classes
            indicator.classList.remove('bg-danger', 'bg-primary', 'bg-warning', 'alliance-unknown');
            
            // Set alliance-specific styling
            if (alliance === 'red') {
                indicator.classList.add('bg-danger');
                indicator.querySelector('.alliance-icon i')?.classList.remove('fa-tint');
                indicator.querySelector('.alliance-icon i')?.classList.add('fa-fire');
                indicator.querySelector('.alliance-details h4').textContent = 'Red Alliance';
                
                // Update text colors for red alliance
                const h4 = indicator.querySelector('.alliance-details h4');
                const teamDiv = indicator.querySelector('.alliance-details > div:last-child');
                if (h4) h4.classList.add('text-white');
                if (teamDiv) {
                    teamDiv.classList.remove('text-muted', 'text-dark');
                    teamDiv.classList.add('text-white-50');
                }
                indicator.querySelector('.alliance-icon i')?.classList.add('text-white');
            } else if (alliance === 'blue') {
                indicator.classList.add('bg-primary');
                indicator.querySelector('.alliance-icon i')?.classList.remove('fa-fire');
                indicator.querySelector('.alliance-icon i')?.classList.add('fa-tint');
                indicator.querySelector('.alliance-details h4').textContent = 'Blue Alliance';
                
                // Update text colors for blue alliance
                const h4 = indicator.querySelector('.alliance-details h4');
                const teamDiv = indicator.querySelector('.alliance-details > div:last-child');
                if (h4) h4.classList.add('text-white');
                if (teamDiv) {
                    teamDiv.classList.remove('text-muted', 'text-dark');
                    teamDiv.classList.add('text-white-50');
                }
                indicator.querySelector('.alliance-icon i')?.classList.add('text-white');
            } else {
                indicator.classList.add('bg-warning', 'alliance-unknown');
                indicator.querySelector('.alliance-icon i')?.classList.remove('fa-fire');
                indicator.querySelector('.alliance-icon i')?.classList.add('fa-tint');
                indicator.querySelector('.alliance-details h4').textContent = 'Unknown Alliance';
                
                // Update text colors for unknown alliance
                const h4 = indicator.querySelector('.alliance-details h4');
                const teamDiv = indicator.querySelector('.alliance-details > div:last-child');
                if (h4) h4.classList.add('text-dark');
                if (teamDiv) {
                    teamDiv.classList.remove('text-white-50');
                    teamDiv.classList.add('text-muted');
                }
                indicator.querySelector('.alliance-icon i')?.classList.add('text-dark');
            }
            
            // Update team info
            const teamInfoDiv = indicator.querySelector('.alliance-details > div:last-child');
            if (teamInfoDiv) {
                teamInfoDiv.textContent = `Team ${team.team_number} - ${team.team_name}`;
            }
            
            console.log('[Offline Mode] Alliance indicator updated to:', alliance);
        }

        // Ensure auto-period-timer toggle state persists across form injections
        function setupAutoTimerTogglePersistence() {
            const toggle = document.getElementById('auto_period_timer_enabled');
            if (!toggle) return;

            // Restore state from localStorage if present (use same key as scripts.js)
            const saved = localStorage.getItem('auto_period_timer_enabled');
            if (saved !== null) {
                toggle.checked = (saved === 'true');
            }

            // Attach listener to persist user changes if scripts.js didn't already; avoid duplicates
            if (!toggle._scoutingAutoTimerListenerAttached) {
                toggle.addEventListener('change', function() {
                    try {
                        localStorage.setItem('auto_period_timer_enabled', toggle.checked ? 'true' : 'false');
                        console.log('[Offline Mode] Auto timer toggle state saved:', toggle.checked);
                    } catch (e) {
                        console.warn('Could not persist auto timer toggle state', e);
                    }
                });
                toggle._scoutingAutoTimerListenerAttached = true;
            }
        }
        
        // Reset form to default values
        function resetFormToDefaults() {
            const form = document.getElementById('scouting-form');
            if (!form) return;
            
            // Read saved auto timer state from localStorage (use same key as scripts.js)
            const savedAutoTimerState = (localStorage.getItem('auto_period_timer_enabled') === 'true');
            
            // Reset all inputs to their default values
            const inputs = form.querySelectorAll('input:not([type="hidden"]), select, textarea');
            inputs.forEach(input => {
                // Skip the auto period timer toggle
                if (input.id === 'auto_period_timer_enabled') {
                    return;
                }
                
                if (input.type === 'checkbox' || input.type === 'radio') {
                    input.checked = false;
                } else if (input.type === 'number' || input.classList.contains('counter-input')) {
                    input.value = 0;
                } else if (input.tagName === 'SELECT') {
                    input.selectedIndex = 0;
                } else {
                    input.value = '';
                }
            });
            
            // Restore the auto period timer toggle state
            const autoTimerToggle = document.getElementById('auto_period_timer_enabled');
            if (autoTimerToggle) {
                autoTimerToggle.checked = savedAutoTimerState;
            }
            
            // Update points displays to 0
            const pointsDisplays = form.querySelectorAll('.points-display .points-value');
            pointsDisplays.forEach(display => {
                display.textContent = '0';
            });
            
            // Clear scout name but keep it enabled
            const scoutNameInput = form.querySelector('#scout_name, input[name="scout_name"]');
            if (scoutNameInput) {
                scoutNameInput.value = '';
            }
            
            console.log('[Offline Mode] Form reset to default values (auto timer toggle preserved)');
        }
        
        // Generate complete offline form HTML matching online structure
        function generateOfflineFormHTML(team, match, gameConfig) {
            return `
                <!-- Offline Mode Indicator -->
                <div class="alert alert-info alert-dismissible fade show mb-3">
                    <i class="fas fa-wifi-slash me-2"></i>
                    <strong>Offline Mode</strong> - Form loaded from cached data. 
                    Data will be saved locally and synced when connection is restored.
                    <button type="button" class="btn-close" data-bs-dismiss="alert" aria-label="Close"></button>
                </div>
                
                <!-- Scouting Form -->
                <form id="scouting-form" class="scouting-form" data-offline="true">
                    <input type="hidden" name="team_id" value="${team.id}">
                    <input type="hidden" name="match_id" value="${match.id}">
                    <input type="hidden" name="team_number" value="${team.team_number}">
                    <input type="hidden" name="match_number" value="${match.match_number}">
                    <input type="hidden" name="match_type" value="${match.match_type}">
                    
                    ${generateFormFieldsFromConfig(gameConfig)}
                    
                    <!-- Action Buttons -->
                    <div class="form-section mb-4">
                        <div class="d-grid gap-2">
                            <button type="button" id="save-button" class="btn btn-primary btn-lg">
                                <i class="fas fa-save me-2"></i>Save Offline
                            </button>
                            <button type="button" id="generateQR" class="btn btn-success btn-lg">
                                <i class="fas fa-qrcode me-2"></i>Generate QR Code
                            </button>
                            <button type="button" id="export-json-button" class="btn btn-info btn-lg">
                                <i class="fas fa-file-export me-2"></i>Export JSON
                            </button>
                            <button type="button" id="reset-form" class="btn btn-outline-secondary">
                                <i class="fas fa-redo me-2"></i>Reset Form
                            </button>
                        </div>
                        <div class="mt-2 text-center small text-muted">
                            <i class="fas fa-info-circle me-1"></i>
                            Offline mode: Data will be saved locally
                        </div>
                    </div>
                </form>
            `;
        }
        
        // Generate form fields from game config - matches online structure
        function generateFormFieldsFromConfig(config) {
            if (!config) return '<div class="alert alert-warning">No game configuration available</div>';
            
            let html = '';
            
            // Scout info section
            html += `
                <div class="card mb-3 navbar-glass">
                    <div class="card-header bg-primary text-white">
                        <h5 class="mb-0">Scout Information</h5>
                    </div>
                    <div class="card-body">
                        <div class="mb-3">
                            <label for="scout_name" class="form-label">Scout Name</label>
                            <input type="text" class="form-control" id="scout_name" name="scout_name" 
                                   placeholder="Enter your name" required>
                        </div>
                    </div>
                </div>
            `;
            
            // Generate match period tabs
            const periods = [
                { key: 'auto_period', icon: 'robot', color: 'primary' },
                { key: 'teleop_period', icon: 'gamepad', color: 'success' },
                { key: 'endgame_period', icon: 'flag-checkered', color: 'warning' }
            ];
            
            const availablePeriods = periods.filter(p => config[p.key] && config[p.key].scoring_elements && config[p.key].scoring_elements.length > 0);
            
            if (availablePeriods.length > 0) {
                // Tab navigation
                html += `
                    <ul class="nav nav-tabs mb-3" role="tablist">
                `;
                
                availablePeriods.forEach((period, index) => {
                    const periodData = config[period.key];
                    const periodName = periodData.name || period.key.replace('_period', '').replace('_', ' ');
                    const isActive = index === 0 ? 'active' : '';
                    
                    html += `
                        <li class="nav-item" role="presentation">
                            <button class="nav-link ${isActive}" id="${period.key}-tab" data-bs-toggle="tab" 
                                    data-bs-target="#${period.key}" type="button" role="tab">
                                <i class="fas fa-${period.icon} me-2"></i>${periodName}
                            </button>
                        </li>
                    `;
                });
                
                html += `</ul>`;
                
                // Tab content
                html += `<div class="tab-content">`;
                
                availablePeriods.forEach((period, index) => {
                    const periodData = config[period.key];
                    const isActive = index === 0 ? 'show active' : '';
                    
                    html += `
                        <div class="tab-pane fade ${isActive}" id="${period.key}" role="tabpanel">
                            <div class="card mb-3 navbar-glass">
                                <div class="card-body">
                    `;
                    
                    // Generate scoring elements for this period
                    if (periodData.scoring_elements && periodData.scoring_elements.length > 0) {
                        periodData.scoring_elements.forEach(element => {
                            html += generateFormElement(element, period.key);
                        });
                    }
                    
                    html += `
                                </div>
                            </div>
                        </div>
                    `;
                });
                
                html += `</div>`;
            }
            
            // Post-match section
            if (config.post_match) {
                html += `
                    <div class="card mb-3 navbar-glass">
                        <div class="card-header bg-secondary text-white">
                            <h5 class="mb-0"><i class="fas fa-clipboard-check me-2"></i>Post-Match</h5>
                        </div>
                        <div class="card-body">
                `;
                
                // Rating elements
                if (config.post_match.rating_elements && config.post_match.rating_elements.length > 0) {
                    config.post_match.rating_elements.forEach(element => {
                        html += generateFormElement(element, 'post_match');
                    });
                }
                
                // Text elements
                if (config.post_match.text_elements && config.post_match.text_elements.length > 0) {
                    config.post_match.text_elements.forEach(element => {
                        html += generateFormElement(element, 'post_match');
                    });
                }
                
                // Boolean elements
                if (config.post_match.boolean_elements && config.post_match.boolean_elements.length > 0) {
                    config.post_match.boolean_elements.forEach(element => {
                        html += generateFormElement(element, 'post_match');
                    });
                }
                
                html += `
                        </div>
                    </div>
                `;
            }
            
            return html;
        }
        
        // Generate individual form element matching online styling
        function generateFormElement(element, periodKey) {
            const id = element.id || element.name || 'element_' + Math.random();
            const label = element.name || element.label || id;
            const type = element.type || 'text';
            const defaultValue = element.default !== undefined ? element.default : '';
            const description = element.description || '';
            
            let html = `<div class="mb-4 form-element" data-element-type="${type}" data-period="${periodKey}">`;
            
            switch (type) {
                case 'counter':
                    const pointsValue = element.points_value || 0;
                    html += `
                        <label class="form-label fw-bold">${label}</label>
                        ${description ? `<div class="form-text mb-2">${description}</div>` : ''}
                        <div class="input-group counter-control">
                            <button type="button" class="btn btn-outline-danger counter-btn" data-action="decrement" data-target="${id}">
                                <i class="fas fa-minus"></i>
                            </button>
                            <input type="number" class="form-control counter-input text-center fs-4 fw-bold" 
                                   id="${id}" name="${id}" value="${defaultValue}" min="0" 
                                   data-points="${pointsValue}">
                            <button type="button" class="btn btn-outline-success counter-btn" data-action="increment" data-target="${id}">
                                <i class="fas fa-plus"></i>
                            </button>
                        </div>
                    `;
                    if (pointsValue > 0) {
                        html += `
                            <div class="points-display mt-2 text-end small text-muted" data-metric-id="${id}">
                                <span class="points-value">0</span> points (${pointsValue} each)
                            </div>
                        `;
                    }
                    break;
                    
                case 'boolean':
                case 'checkbox':
                    html += `
                        <div class="form-check form-switch">
                            <input type="checkbox" class="form-check-input" id="${id}" name="${id}" 
                                   role="switch" ${defaultValue ? 'checked' : ''}>
                            <label class="form-check-label fw-bold" for="${id}">${label}</label>
                            ${description ? `<div class="form-text">${description}</div>` : ''}
                        </div>
                    `;
                    break;
                    
                case 'select':
                case 'dropdown':
                    html += `
                        <label for="${id}" class="form-label fw-bold">${label}</label>
                        ${description ? `<div class="form-text mb-2">${description}</div>` : ''}
                        <select class="form-select" id="${id}" name="${id}">
                    `;
                    if (element.options && element.options.length > 0) {
                        element.options.forEach(option => {
                            const value = typeof option === 'object' ? (option.value || option) : option;
                            const optionLabel = typeof option === 'object' ? (option.label || value) : option;
                            html += `<option value="${value}" ${value == defaultValue ? 'selected' : ''}>${optionLabel}</option>`;
                        });
                    }
                    html += `</select>`;
                    break;
                    
                case 'rating':
                    html += `
                        <label class="form-label fw-bold">${label}</label>
                        ${description ? `<div class="form-text mb-2">${description}</div>` : ''}
                        <div class="rating-group d-flex gap-2" data-rating-id="${id}">
                    `;
                    for (let i = 1; i <= 5; i++) {
                        html += `
                            <input type="radio" class="btn-check" id="${id}_${i}" name="${id}" value="${i}" 
                                   ${i == defaultValue ? 'checked' : ''}>
                            <label class="btn btn-outline-warning" for="${id}_${i}">
                                <i class="fas fa-star"></i> ${i}
                            </label>
                        `;
                    }
                    html += `</div>`;
                    break;
                    
                case 'textarea':
                    html += `
                        <label for="${id}" class="form-label fw-bold">${label}</label>
                        ${description ? `<div class="form-text mb-2">${description}</div>` : ''}
                        <textarea class="form-control" id="${id}" name="${id}" rows="3">${defaultValue}</textarea>
                    `;
                    break;
                    
                case 'text':
                default:
                    html += `
                        <label for="${id}" class="form-label fw-bold">${label}</label>
                        ${description ? `<div class="form-text mb-2">${description}</div>` : ''}
                        <input type="text" class="form-control" id="${id}" name="${id}" value="${defaultValue}">
                    `;
            }
            
            html += `</div>`;
            return html;
        }

        // Initialize form components in one place for easier updates
        function initializeFormComponents() {
            // Show QR code in modal when generated
            const generateQRButton = document.getElementById('generateQR');
            if (generateQRButton) {
                const qrModalElement = document.getElementById('qrModal');
                if (qrModalElement) {
                    const qrModal = new bootstrap.Modal(qrModalElement);
                    
                    // Remove any existing event listener first
                    generateQRButton.removeEventListener('click', showQRModal);
                    
                    // Add new event listener
                    generateQRButton.addEventListener('click', showQRModal);
                    
                    function showQRModal() {
                        try {
                            // Show modal first, then generate QR code
                            qrModal.show();
                            if (typeof generateQRCode === 'function') {
                                generateQRCode(); // This function is defined in scripts.js
                            }
                        } catch (error) {
                            console.error('Error showing QR modal:', error);
                        }
                    }
                } else {
                    console.warn('QR Modal element not found');
                }
            } else {
                console.warn('Generate QR Button not found');
            }
            
            // Initialize counters (needed for points calculation)
            initializeCounters();
            
            // Initialize star rating system
            initializeRatings();
            
            // Initialize match period tabs
            initializeMatchPeriodTabs();
            
            // Initialize auto period timer
            initializeAutoPeriodTimer();
            
            // Initialize points calculation
            initializePointsCalculation();

            // Form reset button
            initializeResetButton();

            // Setup save button with enhanced functionality
            setupSaveButton();
            
            // Setup export JSON button
            setupExportJsonButton();

            // Setup save locally handler (if scripts.js provided it)
            if (typeof setupSaveLocally === 'function') {
                try { setupSaveLocally(); } catch (e) { /* ignore */ }
            }

            // Make sure points are calculated on page load
            updatePointsCalculation();
        }
        
        // Function to show toast notifications
        function showToast(message, type = 'info') {
            const toastContainer = document.querySelector('.toast-container');
            if (!toastContainer) return;
            
            const toast = document.createElement('div');
            toast.classList.add('toast', 'align-items-center', 'border-0');
            toast.classList.add(`bg-${type === 'error' ? 'danger' : type}`);
            toast.classList.add(type === 'error' || type === 'success' ? 'text-white' : '');
            toast.setAttribute('role', 'alert');
            toast.setAttribute('aria-live', 'assertive');
            toast.setAttribute('aria-atomic', 'true');
            
            toast.innerHTML = `
                <div class="d-flex">
                    <div class="toast-body">
                        <i class="fas fa-${type === 'success' ? 'check-circle' : type === 'error' ? 'exclamation-circle' : 'info-circle'} me-2"></i>
                        ${message}
                    </div>
                    <button type="button" class="btn-close btn-close-white me-2 m-auto" data-bs-dismiss="toast" aria-label="Close"></button>
                </div>
            `;
            
            toastContainer.appendChild(toast);
            
            const bsToast = new bootstrap.Toast(toast, {
                delay: 5000
            });
            
            bsToast.show();
            
            // Remove toast from DOM after it's been hidden
            toast.addEventListener('hidden.bs.toast', function() {
                if (toast.parentNode) {
                    toast.parentNode.removeChild(toast);
                }
            });
        }
        
        // Set up Save button handler
        function setupSaveButton() {
            const saveBtn = document.getElementById('save-button');
            if (!saveBtn) return;
            
            saveBtn.addEventListener('click', function(e) {
                e.preventDefault();
                
                const form = document.getElementById('scouting-form');
                if (!form) return;
                
                // Validate form
                if (!validateForm(form)) {
                    showToast('Please fill in all required fields', 'error');
                    return;
                }
                
                // Visual feedback - change button state
                const originalText = saveBtn.innerHTML;
                saveBtn.disabled = true;
                
                // Check if we're in offline mode
                const isOfflineForm = form.dataset.offline === 'true';
                const isOffline = !navigator.onLine;
                
                if (isOffline || isOfflineForm) {
                    // Save offline
                    saveBtn.innerHTML = '<span class="spinner-border spinner-border-sm me-2" role="status"></span>Saving Offline...';
                    
                    try {
                        // Collect form data
                        const formData = new FormData(form);
                        const formObj = {};
                        
                        formData.forEach((value, key) => {
                            const element = form.elements[key];
                            
                            // Handle checkboxes
                            if (element && element.type === 'checkbox') {
                                formObj[key] = element.checked;
                                return;
                            }
                            
                            // Handle numbers
                            if (element && (element.type === 'number' || element.classList.contains('counter-input'))) {
                                formObj[key] = value === '' ? 0 : Number(value);
                                return;
                            }
                            
                            // Handle everything else
                            formObj[key] = value;
                        });
                        
                        // Add timestamp
                        formObj.timestamp = new Date().toISOString();
                        formObj.offline = true;
                        
                        // Save using offline manager
                        if (window.ScoutingOfflineManager) {
                            const saved = window.ScoutingOfflineManager.saveFormOffline(formObj);
                            
                            if (saved) {
                                saveBtn.disabled = false;
                                saveBtn.innerHTML = originalText;
                                
                                showToast('Data saved offline successfully! Will sync when connection is restored.', 'success');
                                
                                // Add save indicator
                                const saveTimeIndicator = document.createElement('div');
                                saveTimeIndicator.className = 'save-indicator';
                                saveTimeIndicator.innerHTML = `
                                    <div class="small text-success mt-2 text-end">
                                        <i class="fas fa-check-circle me-1"></i>
                                        Saved offline at ${new Date().toLocaleTimeString()}
                                    </div>
                                `;
                                
                                const existingIndicator = document.querySelector('.save-indicator');
                                if (existingIndicator) {
                                    existingIndicator.replaceWith(saveTimeIndicator);
                                } else {
                                    const buttonContainer = saveBtn.closest('.form-section');
                                    if (buttonContainer) {
                                        buttonContainer.appendChild(saveTimeIndicator);
                                    }
                                }
                            } else {
                                throw new Error('Failed to save offline');
                            }
                        } else {
                            throw new Error('Offline manager not available');
                        }
                    } catch (error) {
                        console.error('Error saving offline:', error);
                        saveBtn.disabled = false;
                        saveBtn.innerHTML = originalText;
                        showToast('Error saving offline. Try generating a QR code instead.', 'error');
                    }
                    
                    return;
                }
                
                // Online save
                saveBtn.innerHTML = '<span class="spinner-border spinner-border-sm me-2" role="status"></span>Saving...';
                
                // Get the form data
                const formData = new FormData(form);
                
                // Submit form via AJAX
                fetch('{{ url_for("scouting.api_save") }}', {
                    method: 'POST',
                    body: formData,
                    headers: {
                        'X-Requested-With': 'XMLHttpRequest'
                    }
                })
                .then(response => {
                    if (!response.ok) {
                        throw new Error('Network response was not ok: ' + response.statusText);
                    }
                    return response.json();
                })
                .then(data => {
                    console.log('Save response:', data);
                    
                    // Reset button state
                    saveBtn.disabled = false;
                    saveBtn.innerHTML = originalText;
                    
                    if (data.success) {
                        // Show success message with some feedback about what was saved
                        showToast(`Data for Team ${data.team_number} in ${data.match_type} ${data.match_number} ${data.action} successfully!`, 'success');
                        
                        // Instead of redirecting, show a success indicator on the form
                        const formContainer = document.querySelector('.scouting-form');
                        if (formContainer) {
                            // Add visual success indicator to the form
                            formContainer.classList.add('form-saved');
                            setTimeout(() => {
                                formContainer.classList.remove('form-saved');
                            }, 2000);
                        }
                        
                        // Add a small badge showing when saved
                        const saveTimeIndicator = document.createElement('div');
                        saveTimeIndicator.className = 'save-indicator';
                        saveTimeIndicator.innerHTML = `
                            <div class="small text-success mt-2 text-end">
                                <i class="fas fa-check-circle me-1"></i>
                                Last saved at ${data.timestamp}
                            </div>
                        `;
                        
                        // Replace existing indicator or add new one
                        const existingIndicator = document.querySelector('.save-indicator');
                        if (existingIndicator) {
                            existingIndicator.replaceWith(saveTimeIndicator);
                        } else {
                            const buttonContainer = saveBtn.closest('.form-section');
                            if (buttonContainer) {
                                buttonContainer.appendChild(saveTimeIndicator);
                            }
                        }
                    } else {
                        showToast('Error: ' + (data.message || 'Unknown error'), 'error');
                    }
                })
                .catch(error => {
                    console.error('Error saving data:', error);
                    
                    // If it's a network error, save offline instead
                    if (error.message.includes('Network') || error.message.includes('Failed to fetch')) {
                        console.log('Network error, falling back to offline save...');
                        
                        // Reset button and try offline save
                        saveBtn.disabled = false;
                        saveBtn.innerHTML = originalText;
                        
                        // Mark form as offline and trigger save again
                        form.dataset.offline = 'true';
                        saveBtn.click();
                        return;
                    }
                    
                    // Reset button state
                    saveBtn.disabled = false;
                    saveBtn.innerHTML = originalText;
                    
                    // Handle error
                    showToast('Error saving data. Please try again or generate a QR code instead.', 'error');
                    
                    // If offline or connection error, suggest QR code
                    if (!navigator.onLine) {
                        showToast('You appear to be offline. Try generating a QR code instead.', 'info');
                    }
                });
            });
        }
        
        // Set up Export JSON button handler
        function setupExportJsonButton() {
            const exportBtn = document.getElementById('export-json-button');
            if (!exportBtn) return;
            
            exportBtn.addEventListener('click', function(e) {
                e.preventDefault();
                
                const form = document.getElementById('scouting-form');
                if (!form) return;
                
                // Visual feedback - change button state
                const originalText = exportBtn.innerHTML;
                exportBtn.disabled = true;
                exportBtn.innerHTML = '<span class="spinner-border spinner-border-sm me-2" role="status"></span>Exporting...';
                
                try {
                    // Build the same flat JSON object as used for QR codes
                    const formData = new FormData(form);
                    const jsonObj = {};

                    // Process form entries preserving booleans and numbers
                    formData.forEach((value, key) => {
                        const element = form.elements[key];

                        // Handle checkboxes (use checked boolean)
                        if (element && element.type === 'checkbox') {
                            jsonObj[key] = element.checked;
                            return;
                        }

                        // If the element is a number input, convert to Number
                        if (element && element.type === 'number') {
                            jsonObj[key] = value === '' ? 0 : Number(value);
                            return;
                        }

                        // If value looks numeric, convert to Number
                        if (value !== '' && !isNaN(value)) {
                            // But preserve arrays and multiple-valued inputs below
                            jsonObj[key] = Number(value);
                            return;
                        }

                        // Handle multiple values (checkbox groups, multi-selects)
                        if (jsonObj.hasOwnProperty(key)) {
                            if (Array.isArray(jsonObj[key])) jsonObj[key].push(value);
                            else jsonObj[key] = [jsonObj[key], value];
                        } else {
                            jsonObj[key] = value;
                        }
                    });

                    // Ensure unchecked checkboxes are present with false (use id if available)
                    const allCheckboxes = form.querySelectorAll('input[type="checkbox"]');
                    allCheckboxes.forEach(cb => {
                        const key = cb.name || cb.id || null;
                        if (!key) return;
                        if (!jsonObj.hasOwnProperty(key)) {
                            jsonObj[key] = false;
                        }
                    });

                    // Add calculated points similar to QR logic
                    const pointsElements = document.querySelectorAll('.points-display');
                    pointsElements.forEach(element => {
                        const metricId = element.dataset.metricId;
                        if (metricId) {
                            const pointsValue = element.querySelector('.points-value');
                            if (pointsValue) {
                                jsonObj[metricId + '_points'] = parseInt(pointsValue.textContent || '0');
                            }
                        }
                    });

                    // Ensure scout_name fallback
                    try {
                        const scoutField = form.elements['scout_name'] || document.getElementById('scout_name');
                        const fallbackScout = (scoutField && scoutField.placeholder) ? scoutField.placeholder : (scoutField && scoutField.value) ? scoutField.value : 'unknown';
                        if (!jsonObj.scout_name || (typeof jsonObj.scout_name === 'string' && jsonObj.scout_name.trim() === '')) {
                            jsonObj.scout_name = fallbackScout;
                        }
                    } catch (e) { /* ignore */ }

                    // Add generated_at and offline_generated to match QR payload
                    jsonObj.generated_at = new Date().toISOString();
                    jsonObj.offline_generated = true;

                    // Create and download flat JSON file
                    const jsonString = JSON.stringify(jsonObj, null, 2);
                    const blob = new Blob([jsonString], { type: 'application/json' });
                    const url = URL.createObjectURL(blob);

                    const a = document.createElement('a');
                    a.href = url;
                    const timestamp = new Date().toISOString().replace(/[:.]/g, '-').split('.')[0];
                    const teamPart = (jsonObj.team_id || jsonObj.team_number || 'unknown');
                    const matchPart = (jsonObj.match_id || jsonObj.match_number || 'unknown');
                    a.download = `scouting-data-team-${teamPart}-match-${matchPart}-${timestamp}.json`;
                    document.body.appendChild(a);
                    a.click();
                    document.body.removeChild(a);
                    URL.revokeObjectURL(url);

                    // Reset button state
                    exportBtn.disabled = false;
                    exportBtn.innerHTML = originalText;

                    showToast('Scouting data exported successfully!', 'success');

                } catch (error) {
                    console.error('Error exporting data:', error);

                    // Reset button state
                    exportBtn.disabled = false;
                    exportBtn.innerHTML = originalText;

                    showToast('Error exporting data. Please try again.', 'error');
                }
            });
        }
        
        // Form validation helper
        function validateForm(form) {
            const requiredFields = form.querySelectorAll('[required]');
            let valid = true;
            
            requiredFields.forEach(field => {
                if (!field.value) {
                    field.classList.add('is-invalid');
                    valid = false;
                    
                    // Focus first invalid field
                    if (valid === false && field === requiredFields[0]) {
                        field.focus();
                    }
                } else {
                    field.classList.remove('is-invalid');
                }
            });
            
            return valid;
        }
        
        // Initialize form reset button
        function initializeResetButton() {
            const resetBtn = document.getElementById('reset-form');
            if (resetBtn) {
                resetBtn.addEventListener('click', function() {
                    if (confirm('Are you sure you want to reset all form fields?')) {
                        const formInputs = document.querySelectorAll('#scouting-form input:not([type="hidden"]), #scouting-form select, #scouting-form textarea');
                        formInputs.forEach(input => {
                            if (input.type === 'checkbox') {
                                input.checked = false;
                            } else if (input.tagName === 'SELECT') {
                                input.selectedIndex = 0;
                            } else if (input.type === 'number' || input.classList.contains('counter-input')) {
                                // Reset numeric counters to 0 (not empty). Empty/null breaks arithmetic with +/- handlers.
                                try { input.value = 0; } catch (e) { input.value = '0'; }
                            } else {
                                input.value = '';
                            }
                        });
                        
                        // Update points after resetting form
                        updatePointsCalculation();
                    }
                });
            }
        }
        
        // Team and Match selection enhancements with auto-submit
        const teamSelector = document.getElementById('team-selector');
        const matchSelector = document.getElementById('match-selector');
        const teamMatchForm = document.getElementById('team-match-form');
        
        if (teamSelector && matchSelector && teamMatchForm) {
            // New: search inputs for filtering options
            const teamSearch = document.getElementById('team-search');
            const matchSearch = document.getElementById('match-search');

            // Helper to normalize strings for comparison
            function normalizeString(s) {
                return (s || '').toString().toLowerCase().trim();
            }

            // Filter team options by team number or name
            function filterTeamOptions() {
                const query = normalizeString(teamSearch.value);
                const options = Array.from(teamSelector.querySelectorAll('option'));

                // Keep the empty placeholder visible
                options.forEach(opt => {
                    if (!opt.value) return; // placeholder

                    const teamNumber = normalizeString(opt.getAttribute('data-team-number'));
                    const teamName = normalizeString(opt.getAttribute('data-team-name'));
                    const text = normalizeString(opt.textContent || opt.innerText);
                    const match = !query || teamNumber.includes(query) || teamName.includes(query) || text.includes(query);

                    opt.hidden = !match;
                    opt.style.display = match ? '' : 'none';
                });

                // If the currently selected option is hidden by filter, reset selection to placeholder
                const current = teamSelector.options[teamSelector.selectedIndex];
                if (current && current.hidden) {
                    teamSelector.value = '';
                }

                // Auto-select if there's exactly one visible non-placeholder option
                const visibleOptions = options.filter(opt => opt.value && !opt.hidden);
                if (visibleOptions.length === 1) {
                    const only = visibleOptions[0];

                    // For teams: prefer exact team number match OR if query-empty but only one option
                    const teamNumberAttr = normalizeString(only.getAttribute('data-team-number'));
                    const exactNumberMatch = query && teamNumberAttr === query;

                    if (exactNumberMatch || query === '' || query.length > 0 && exactNumberMatch) {
                        // Programmatically select and dispatch change
                        teamSelector.value = only.value;
                        teamSelector.dispatchEvent(new Event('change', { bubbles: true }));
                    }
                }
                // Sync any custom select UI visibility if present
                try { syncCustomSelectVisibility(teamSelector); } catch (e) { /* ignore if not present */ }
            }

            // Filter match options by match type or number, with shorthand parsing
            function filterMatchOptions() {
                const raw = normalizeString(matchSearch.value);
                const options = Array.from(matchSelector.querySelectorAll('option'));

                // Parse query into alpha and numeric parts (e.g., 'sf1' -> letters: 'sf', number: '1')
                function parseMatchQuery(q) {
                    if (!q) return { letters: '', number: '' };
                    // remove extra spaces
                    const compact = q.replace(/\s+/g, '');
                    const numMatch = compact.match(/(\d+)/);
                    const number = numMatch ? numMatch[1] : '';
                    const letters = compact.replace(/\d+/g, '');
                    return { letters: letters, number: number };
                }

                const q = parseMatchQuery(raw);

                // Aliases for canonical match type words
                const aliases = {
                    qualification: ['q','qu','qual','qualification','qualif','qualifcation','qualifc'],
                    practice: ['p','pr','practice','prac','pract','pm','pm1'],
                    quarter: ['qf','quarter','quarterfinal','quarterfinals','quarter-final','quarter-finals','quarterfinals','qtr'],
                    semi: ['sf','sem','semi','semifinal','semifinals','sf1','smf','smf1','semifinalmatch'],
                    final: ['f','fin','final','finals','f1'],
                    playoff: ['playoff','po','playoffs','pm','pm1']
                };

                // Determine which canonical types the letters token maps to
                function candidateTypesFromLetters(letters) {
                    if (!letters) return [];
                    const res = [];
                    for (const [canon, arr] of Object.entries(aliases)) {
                        for (const a of arr) {
                            if (letters === a || letters.startsWith(a) || a.startsWith(letters)) {
                                res.push(canon);
                                break;
                            }
                        }
                    }
                    return res;
                }

                const candidateTypes = candidateTypesFromLetters(q.letters);

                // We'll compute a score for each option and use that to determine visibility and best match
                const scored = [];
                options.forEach(opt => {
                    if (!opt.value) return; // placeholder

                    const matchType = normalizeString(opt.getAttribute('data-match-type') || '');
                    const matchNumber = normalizeString(opt.getAttribute('data-match-number') || '');
                    const text = normalizeString(opt.textContent || opt.innerText || '');

                    let score = 0;

                    // Strong boost for exact number match
                    if (q.number && matchNumber === q.number) score += 60;

                    // Good boost if text contains the number
                    if (q.number && text.includes(q.number)) score += 20;

                    // Letters/type matching via canonical candidates
                    if (q.letters && candidateTypes.length > 0) {
                        for (const ct of candidateTypes) {
                            if (matchType.includes(ct)) score += 40;
                            if (text.includes(ct)) score += 25;
                            if (ct.startsWith(q.letters) || q.letters.startsWith(ct)) score += 10;
                        }
                    }

                    // Loose letter match against the displayed text
                    if (q.letters && text.includes(q.letters)) score += 10;

                    // Small boosts for startsWith matches
                    if (raw && text.startsWith(raw)) score += 8;
                    if (raw && matchType.startsWith(raw)) score += 6;

                    // If no query, give minimal score so everything remains visible
                    if (!q.letters && !q.number) score += 1;

                    // Record
                    scored.push({ opt, score, matchType, matchNumber, text });
                });

                // Decide visibility: show items with score > 0 (or all if query empty)
                scored.forEach(s => {
                    const visible = s.score > 0;
                    s.opt.hidden = !visible;
                    s.opt.style.display = visible ? '' : 'none';
                });

                // Find best-scoring candidate
                scored.sort((a, b) => b.score - a.score);
                const best = scored[0];
                const second = scored[1];

                // Selection logic: choose best if it's reasonably strong and unambiguous
                if (best && best.score > 0) {
                    const threshold = 40; // minimum score to consider auto-select
                    const gap = (second ? best.score - second.score : best.score);

                    if (best.score >= threshold && gap >= 20) {
                        // auto-select best candidate
                        matchSelector.value = best.opt.value;
                        matchSelector.dispatchEvent(new Event('change', { bubbles: true }));
                    }
                }

                const current = matchSelector.options[matchSelector.selectedIndex];
                if (current && current.hidden) {
                    matchSelector.value = '';
                }

                // Auto-select if there's exactly one visible non-placeholder match option
                const visibleMatchOptions = options.filter(opt => opt.value && !opt.hidden);
                if (visibleMatchOptions.length === 1) {
                    const only = visibleMatchOptions[0];
                    matchSelector.value = only.value;
                    matchSelector.dispatchEvent(new Event('change', { bubbles: true }));
                }
                // Sync any custom select UI visibility if present
                try { syncCustomSelectVisibility(matchSelector); } catch (e) { /* ignore if not present */ }
            }

            // Attach input listeners with debounce to avoid overfiring
            function debounce(func, wait) {
                let timeout;
                return function(...args) {
                    clearTimeout(timeout);
                    timeout = setTimeout(() => func.apply(this, args), wait);
                };
            }

            if (teamSearch) teamSearch.addEventListener('input', debounce(filterTeamOptions, 150));
            if (matchSearch) matchSearch.addEventListener('input', debounce(filterMatchOptions, 150));

            // Ensure filters run on initial load (e.g., when localStorage preselects values)
            try { filterTeamOptions(); filterMatchOptions(); } catch (e) { /* ignore */ }
            // Style match type dropdown options
            const matchOptions = matchSelector.querySelectorAll('option');
            matchOptions.forEach(option => {
                if (option.value) {
                    const matchType = option.getAttribute('data-match-type');
                    let textClass = '';
                    
                    if (matchType === 'Qualification') {
                        textClass = 'text-primary';
                    } else if (matchType === 'Playoff') {
                        textClass = 'text-danger';
                    } else if (matchType === 'Practice') {
                        textClass = 'text-success';
                    }
                    
                    if (textClass) {
                        option.classList.add(textClass, 'fw-bold');
                    }
                }
            });
            
            // Save form data for offline use
            function saveFormDataOffline(teamId, matchId) {
                try {
                    localStorage.setItem('last_team_id', teamId);
                    localStorage.setItem('last_match_id', matchId);
                } catch (e) {
                    console.warn("Unable to save to localStorage:", e);
                }
            }
            
            // Load form when team and match are selected
            function loadForm() {
                const teamId = document.getElementById('team-selector').value;
                const matchId = document.getElementById('match-selector').value;
                
                if (!teamId || !matchId) return;
                
                // Show loading indicator
                const formContent = document.getElementById('form-content');
                formContent.innerHTML = `
                    <div class="text-center py-5">
                        <div class="spinner-border text-primary" role="status">
                            <span class="visually-hidden">Loading...</span>
                        </div>
                        <p class="mt-3">Loading scouting form...</p>
                    </div>
                `;
                
                // Save selected values in localStorage for offline use
                try {
                    localStorage.setItem('last_team_id', teamId);
                    localStorage.setItem('last_match_id', matchId);
                } catch (e) {
                    console.warn("Unable to save to localStorage:", e);
                }
                
                // Capture scroll/focus state before AJAX request so we can restore after DOM replacement
                const __savedScrollY = window.scrollY || 0;
                const __savedActiveId = (document.activeElement && document.activeElement.id) ? document.activeElement.id : null;

                // Check if we're offline and should use cached data
                if (!navigator.onLine && window.ScoutingOfflineManager) {
                    console.log('[Offline Mode] Loading form from cache...');
                    const offlineData = window.ScoutingOfflineManager.generateFormOffline(teamId, matchId);
                    
                    if (offlineData) {
                        // Generate form using cached data
                        loadFormOffline(offlineData, __savedScrollY, __savedActiveId);
                        return;
                    } else {
                        formContent.innerHTML = `
                            <div class="alert alert-warning">
                                <i class="fas fa-wifi-slash me-2"></i>
                                <strong>Offline Mode</strong><br>
                                Unable to load form - no cached data available.
                                Please connect to the internet to load the form for the first time.
                            </div>
                        `;
                        return;
                    }
                }

                // Create form data for the AJAX request
                const formData = new FormData();
                formData.append('team_id', teamId);
                formData.append('match_id', matchId);

                // Make AJAX request
                fetch('{{ url_for("scouting.scouting_form") }}', {
                    method: 'POST',
                    body: formData,
                    headers: {
                        'X-Requested-With': 'XMLHttpRequest'
                    }
                })
                .then(response => {
                    // Check if response is OK
                    if (!response.ok) {
                        throw new Error(`HTTP ${response.status}: ${response.statusText}`);
                    }
                    
                    // Check if response is JSON
                    const contentType = response.headers.get('content-type');
                    if (!contentType || !contentType.includes('application/json')) {
                        throw new Error('Server returned non-JSON response');
                    }
                    
                    return response.json();
                })
                .then(data => {
                    if (data.success) {
                        // Update form content
                        formContent.innerHTML = data.html;
                        
                        // Cache this rendered HTML for offline use
                        if (window._scoutingFormLoadHandler && typeof window._scoutingFormLoadHandler === 'function') {
                            window._scoutingFormLoadHandler(data.team_id, data.match_id, data.html);
                        }

                        // Show warning if there was data corruption
                        if (data.warning) {
                            const warningAlert = document.createElement('div');
                            warningAlert.className = 'alert alert-warning alert-dismissible fade show mb-3';
                            warningAlert.innerHTML = `
                                <i class="fas fa-exclamation-triangle me-2"></i>
                                ${data.warning}
                                <button type="button" class="btn-close" data-bs-dismiss="alert" aria-label="Close"></button>
                            `;
                            formContent.insertBefore(warningAlert, formContent.firstChild);
                        }

                        // Update subheading
                        document.getElementById('form-subheading').textContent = 
                            `${data.team_number} - ${data.team_name} | ${data.match_type} ${data.match_number}`;

                        // Initialize form components AFTER the form is loaded and restore previous scroll/focus
                        setTimeout(() => {
                            initializeFormComponents();

                            // Copy quick prediction (if set) into loaded form's predicted_winner input
                            try {
                                const quick = document.querySelector('input[name="predicted_winner_select"]:checked');
                                if (quick) {
                                    const val = quick.value;
                                    // Find target radios in loaded form and set
                                    const target = document.querySelector('#form-content input[name="predicted_winner"]');
                                    if (target) {
                                        // If the loaded form uses radios, set the matching one
                                        const radios = document.querySelectorAll('#form-content input[name="predicted_winner"]');
                                        radios.forEach(r => { r.checked = (r.value === val); });
                                    }
                                }
                            } catch (e) { console.warn('Could not copy quick prediction into loaded form', e); }

                            // Restore scroll position
                                try {
                                    if (typeof window.safeRestoreScroll === 'function') {
                                        window.safeRestoreScroll(__savedScrollY, { behavior: 'auto', timeout: 300 });
                                    } else {
                                        // Fallback already handled; no-op here to avoid double-restores
                                    }
                                } catch (e) {
                                    console.warn('Could not restore scroll position', e);
                                }

                            // Restore focus to previously focused element if it still exists
                            if (__savedActiveId) {
                                try {
                                    const prev = document.getElementById(__savedActiveId);
                                    if (prev && typeof prev.focus === 'function') {
                                        prev.focus({ preventScroll: true });
                                    }
                                } catch (e) {
                                    // ignore
                                }
                            }
                        }, 100);
                    } else {
                        formContent.innerHTML = `
                            <div class="alert alert-danger">
                                <i class="fas fa-exclamation-circle me-2"></i>
                                ${data.message || 'An error occurred while loading the form.'}
                            </div>
                        `;
                    }
                })
                .catch(error => {
                    console.error('Error loading form:', error);
                    
                    // If offline or network error, try to load from cache
                    if (!navigator.onLine || error.message.includes('Network') || error.message.includes('Failed to fetch')) {
                        console.log('[Offline Mode] Network error, attempting to load from cache...');
                        
                        if (window.ScoutingOfflineManager) {
                            const offlineData = window.ScoutingOfflineManager.generateFormOffline(teamId, matchId);
                            
                            if (offlineData) {
                                loadFormOffline(offlineData, __savedScrollY, __savedActiveId);
                                return;
                            }
                        }
                        
                        formContent.innerHTML = `
                            <div class="alert alert-warning">
                                <i class="fas fa-wifi-slash me-2"></i>
                                <strong>Offline Mode</strong><br>
                                Unable to connect to server and no cached data available.
                                Please connect to the internet or wait for the connection to be restored.
                            </div>
                        `;
                        return;
                    }
                    
                    let errorMessage = 'Error loading form. Please try again.';
                    
                    if (error.message.includes('HTTP 500')) {
                        errorMessage = 'Server error occurred. Please check the server logs or try again later.';
                    } else if (error.message.includes('non-JSON response')) {
                        errorMessage = 'Server returned an unexpected response. There may be a server error.';
                    }
                    
                    formContent.innerHTML = `
                        <div class="alert alert-danger">
                            <i class="fas fa-exclamation-circle me-2"></i>
                            ${errorMessage}
                            <div class="mt-2 small text-muted">
                                Technical details: ${error.message}
                            </div>
                        </div>
                    `;
                });
            }
            
            // Auto-submit when both selections are made
            function checkSelections() {
                const teamId = teamSelector.value;
                const matchId = matchSelector.value;
                
                if (teamId && matchId) {
                    // Visual feedback
                    teamSelector.classList.add('border-success');
                    matchSelector.classList.add('border-success');
                    
                    loadForm();
                } else {
                    teamSelector.classList.remove('border-success');
                    matchSelector.classList.remove('border-success');
                }
            }
            
            // Initialize from localStorage if available
            try {
                const lastTeamId = localStorage.getItem('last_team_id');
                const lastMatchId = localStorage.getItem('last_match_id');
                
                // If we have stored values and no current selection, use them
                if (lastTeamId && lastMatchId && !teamSelector.value && !matchSelector.value) {
                    teamSelector.value = lastTeamId;
                    matchSelector.value = lastMatchId;
                    if (teamSelector.value && matchSelector.value) {
                        checkSelections();
                    }
                }
            } catch (e) {
                console.warn("Unable to retrieve from localStorage:", e);
            }
            
            // Attach event listeners
            teamSelector.addEventListener('change', checkSelections);
            matchSelector.addEventListener('change', checkSelections);

            // Create custom dropdown wrappers for better styling and consistent appearance
            function createCustomSelects() {
                [teamSelector, matchSelector].forEach(function(sel) {
                    if (!sel) return;

                    // Avoid creating twice
                    if (sel.dataset.custom === '1') return;
                    sel.dataset.custom = '1';

                    // Hide native select but keep it in DOM for form submission
                    sel.style.display = 'none';

                    // Create wrapper
                    const wrapper = document.createElement('div');
                    wrapper.className = 'custom-select-wrapper';
                    wrapper.dataset.for = sel.id;

                    const toggle = document.createElement('button');
                    toggle.type = 'button';
                    toggle.className = 'custom-select-toggle btn btn-outline-secondary w-100 text-start';
                    toggle.setAttribute('aria-haspopup', 'listbox');
                    toggle.setAttribute('aria-expanded', 'false');
                    toggle.innerHTML = `<span class="custom-select-value">${sel.options[sel.selectedIndex] ? sel.options[sel.selectedIndex].text : sel.querySelector('option')?.textContent}</span><span class="chev float-end"></span>`;

                    const menu = document.createElement('div');
                    menu.className = 'custom-select-menu shadow-sm';
                    menu.setAttribute('role', 'listbox');
                    menu.style.maxHeight = '40vh';
                    menu.style.overflow = 'auto';
                    menu.style.display = 'none';

                    // Populate items and mark selected
                    Array.from(sel.options).forEach(function(opt) {
                        const item = document.createElement('div');
                        item.className = 'custom-select-item p-2';
                        item.setAttribute('role', 'option');
                        item.dataset.value = opt.value;
                        item.textContent = opt.textContent;
                        if (opt.disabled) item.classList.add('disabled');
                        if (opt.hidden) item.style.display = 'none';
                        if (!opt.value) item.classList.add('placeholder');
                        if (opt.selected) item.classList.add('selected');
                        menu.appendChild(item);
                    });

                    // Insert wrapper before native select
                    sel.parentNode.insertBefore(wrapper, sel);
                    wrapper.appendChild(toggle);
                    wrapper.appendChild(menu);

                    // Toggle menu
                    toggle.addEventListener('click', function(e) {
                        e.stopPropagation();
                        const open = menu.style.display !== 'none';
                        // close any other menus
                        document.querySelectorAll('.custom-select-menu').forEach(m => { if (m !== menu) m.style.display = 'none'; m.previousSibling && m.previousSibling.setAttribute('aria-expanded','false'); });
                        menu.style.display = open ? 'none' : 'block';
                        toggle.setAttribute('aria-expanded', (!open).toString());
                        // add open class to wrapper for styling
                        if (!open) wrapper.classList.add('open'); else wrapper.classList.remove('open');
                    });

                    // Item click
                    menu.addEventListener('click', function(e) {
                        const it = e.target.closest('.custom-select-item');
                        if (!it) return;
                        if (it.classList.contains('disabled')) return;
                        const value = it.dataset.value || '';
                        sel.value = value;
                        // sync toggle text
                        const valueLabel = it.textContent;
                        wrapper.querySelector('.custom-select-value').textContent = valueLabel;
                        // mark selected visually
                        menu.querySelectorAll('.custom-select-item').forEach(i => i.classList.remove('selected'));
                        it.classList.add('selected');
                        // close
                        menu.style.display = 'none';
                        toggle.setAttribute('aria-expanded','false');
                        wrapper.classList.remove('open');
                        sel.dispatchEvent(new Event('change', { bubbles: true }));
                    });

                    // Close on outside click
                    document.addEventListener('click', function(ev) {
                        if (!wrapper.contains(ev.target)) {
                            menu.style.display = 'none';
                            toggle.setAttribute('aria-expanded','false');
                        }
                    });

                    // Store reference for syncing
                    sel._customWrapper = wrapper;
                });
            }

            // Sync visibility of custom menu items with native select options (used by filters)
            function syncCustomSelectVisibility(sel) {
                if (!sel || !sel._customWrapper) return;
                const menu = sel._customWrapper.querySelector('.custom-select-menu');
                const items = Array.from(menu.querySelectorAll('.custom-select-item'));
                Array.from(sel.options).forEach(function(opt, idx) {
                    const it = items[idx];
                    if (!it) return;
                    it.style.display = opt.hidden ? 'none' : '';
                });
            }

            // Initialize custom selects after dom wiring
            try { createCustomSelects(); syncCustomSelectVisibility(teamSelector); syncCustomSelectVisibility(matchSelector); } catch (e) { /* ignore */ }
        }
        
        // Initialize existing form components if present on page load
        initializeFormComponents();
        
        // ======== REAL-TIME CONFIG UPDATE LISTENERS ========
        
        // Listen for game config updates
        window.addEventListener('gameConfigUpdated', function(event) {
            const newGameConfig = event.detail;
            console.log('Game config updated in scouting form:', newGameConfig);
            
            // Show notification to user
            showConfigUpdateNotification('Game configuration has been updated due to alliance mode change.');
            
            // Optionally reload form elements or show a reload prompt
            if (confirm('The game configuration has been updated. Would you like to reload the form to use the new configuration?')) {
                window.location.reload();
            }
        });
        
        // ======== GLOBAL CONFIG RELOAD HANDLER ========
        // Listen for global config changes that require form reload
        window.addEventListener('globalConfigReload', function(event) {
            const configData = event.detail;
            console.log('Global config reload in scouting form:', configData);
            
            // Show notification
            showConfigUpdateNotification(`Configuration updated: ${configData.message}`);
            
            // Automatically reload the form content without full page reload
            reloadFormWithNewConfig();
        });
        
        // Function to reload form content with new configuration
        window.reloadFormWithNewConfig = function() {
            console.log('Reloading scouting form with new configuration...');
            
            // Get current form state
            const currentTeamId = document.getElementById('team-selector')?.value;
            const currentMatchId = document.getElementById('match-selector')?.value;
            
            if (!currentTeamId || !currentMatchId) {
                console.log('No team/match selected, skipping form reload');
                return;
            }
            
            // Capture scroll/focus state before AJAX request so we can restore after DOM replacement
            const __savedScrollY = window.scrollY || 0;
            const __savedActiveId = (document.activeElement && document.activeElement.id) ? document.activeElement.id : null;

            // Reload the form content via AJAX
            fetch(window.location.pathname, {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/x-www-form-urlencoded',
                    'X-Requested-With': 'XMLHttpRequest'
                },
                body: new URLSearchParams({
                    'team_id': currentTeamId,
                    'match_id': currentMatchId
                })
            })
            .then(response => response.json())
            .then(data => {
                if (data.success) {
                    // Replace the current form content
                    const currentFormContent = document.getElementById('form-content');
                    if (currentFormContent && data.html) {
                        currentFormContent.innerHTML = data.html;
                        
                        // Show warning if there was data corruption
                        if (data.warning) {
                            const warningAlert = document.createElement('div');
                            warningAlert.className = 'alert alert-warning alert-dismissible fade show mb-3';
                            warningAlert.innerHTML = `
                                <i class="fas fa-exclamation-triangle me-2"></i>
                                ${data.warning}
                                <button type="button" class="btn-close" data-bs-dismiss="alert" aria-label="Close"></button>
                            `;
                            currentFormContent.insertBefore(warningAlert, currentFormContent.firstChild);
                        }
                        
                        // Reinitialize form components
                        initializeFormComponents();

                        // Restore scroll position
                        try {
                            if (typeof window.safeRestoreScroll === 'function') {
                                window.safeRestoreScroll(__savedScrollY, { behavior: 'auto', timeout: 300 });
                            } else {
                                // Fallback already handled; no-op here to avoid double-restores
                            }
                        } catch (e) { /* ignore */ }

                        // Restore focus to previously focused element if it still exists
                        if (__savedActiveId) {
                            try {
                                const prev = document.getElementById(__savedActiveId);
                                if (prev && typeof prev.focus === 'function') prev.focus({ preventScroll: true });
                            } catch (e) { /* ignore */ }
                        }

                        console.log('Form reloaded successfully with new configuration');
                        showConfigUpdateNotification('Form updated with new configuration');
                    }
                } else {
                    console.error('Error reloading form:', data.message);
                    showConfigUpdateNotification('Error reloading form: ' + data.message, 'error');
                }
            })
            .catch(error => {
                console.error('Error reloading form:', error);
                showConfigUpdateNotification('Error reloading form. Please refresh the page.', 'error');
            });
        };
        
        // Listen for alliance status changes
        window.addEventListener('allianceStatusUpdated', function(event) {
            const allianceStatus = event.detail;
            console.log('Alliance status updated in scouting form:', allianceStatus);
            
            if (allianceStatus.is_active) {
                showConfigUpdateNotification(`Alliance mode activated. Now using shared configuration from ${allianceStatus.alliance_info?.alliance_name || 'alliance'}.`);
            } else {
                showConfigUpdateNotification('Alliance mode deactivated. Now using individual team configuration.');
            }
        });
        
        // Function to show config update notifications
        function showConfigUpdateNotification(message, type = 'info') {
            // Normalize type
            let normalizedType = type;
            if (!type || type === 'info' || type === 'message' || type === 'default') normalizedType = 'success';
            if (type === 'error' || type === 'err') normalizedType = 'danger';
            if (type === 'warn') normalizedType = 'warning';

            // Create a notification banner
            const notification = document.createElement('div');
            notification.className = `alert alert-${normalizedType} alert-dismissible fade show position-fixed`;
            notification.style.cssText = 'top: 20px; right: 20px; z-index: 9999; max-width: 400px;';
            notification.innerHTML = `
                <i class="fas fa-sync-alt me-2"></i>
                ${message}
                <button type="button" class="btn-close" data-bs-dismiss="alert"></button>
            `;
            
            document.body.appendChild(notification);
            
            // Auto-remove after 10 seconds
            setTimeout(() => {
                if (notification.parentNode) {
                    notification.remove();
                }
            }, 10000);
        }
    });
</script>
<link rel="stylesheet" href="{{ url_for('static', filename='css/scale-ui.css') }}">
<script src="{{ url_for('static', filename='js/scale-ui.js') }}"></script>
{% endblock %}