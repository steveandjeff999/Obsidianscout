{% extends 'base.html' %}

{% block title %}Scouting Form{% endblock %}

{% block heading %}Scouting Form{% endblock %}
{% block extra_css %}
<link rel="stylesheet" href="{{ url_for('static', filename='css/scouting_form.css') }}">
{% endblock %}
{% block subheading %}
<div id="form-subheading" class="text-muted mb-4">Select team and match below</div>
{% endblock %}

{% block content %}
<div class="row">
    <div class="col-md-12">
        <!-- Team and Match Selection -->
        <div class="card mb-4">
            <div class="card-header bg-primary text-white">
                <h5 class="mb-0">Select Team and Match</h5>
            </div>
            <div class="card-body">
                <form id="team-match-form" aria-label="Team and Match selection">
                    <div class="row">
                        <div class="col-md-6 mb-2">
                            <label for="team-selector" class="form-label">Select Team</label>
                            <!-- Search input for teams -->
                            <div class="input-group mb-1">
                                <span class="input-group-text"><i class="fas fa-search"></i></span>
                                <input type="search" id="team-search" class="form-control form-control-sm" placeholder="Search teams by number or name" aria-label="Search teams">
                            </div>
                            <select class="form-select" id="team-selector" name="team_id" required aria-label="Team selector">
                                <option value="">-- Select Team --</option>
                                {% for team_option in teams %}
                                <option value="{{ team_option.id }}" data-team-number="{{ team_option.team_number }}" data-team-name="{{ team_option.team_name }}" {% if team and team.id == team_option.id %}selected{% endif %}>
                                    {{ team_option.team_number }} - {{ team_option.team_name }}
                                </option>
                                {% endfor %}
                            </select>
                        </div>
                        <div class="col-md-6 mb-2">
                            <label for="match-selector" class="form-label">Select Match</label>
                            <!-- Search input for matches -->
                            <div class="input-group mb-1">
                                <span class="input-group-text"><i class="fas fa-search"></i></span>
                                <input type="search" id="match-search" class="form-control form-control-sm" placeholder="Search matches by type or number" aria-label="Search matches">
                            </div>
                            <select class="form-select" id="match-selector" name="match_id" required aria-required="true" aria-label="Match selector">
                                <option value="">-- Select Match --</option>
                                {% for match_option in matches %}
                                <option value="{{ match_option.id }}" data-match-type="{{ match_option.match_type }}" data-match-number="{{ match_option.match_number }}" {% if match and match.id == match_option.id %}selected{% endif %}>
                                    {{ match_option.match_type }} {{ match_option.match_number }}
                                </option>
                                {% endfor %}
                            </select>
                        </div>
                    </div>
                </form>
            </div>
        </div>

        <!-- Form Content Container -->
        <div id="form-content">
            {% if team and match %}
                {% include "scouting/partials/form_content.html" %}
            {% else %}
            <!-- Empty Form State -->
            <div class="alert alert-info text-center py-4">
                <i class="fas fa-info-circle fa-3x mb-3"></i>
                <h4>Please select a team and match above</h4>
                <p class="mb-0">The form will automatically update when both are selected.</p>
            </div>
            {% endif %}
        </div>
    </div>
</div>

<!-- QR Code Container (initially hidden) -->
<div class="modal fade" id="qrModal" tabindex="-1" aria-hidden="true">
    <div class="modal-dialog modal-dialog-centered">
        <div class="modal-content">
            <div class="modal-header">
                <h5 class="modal-title">
                    <i class="fas fa-qrcode me-2"></i> QR Code for Match Data
                </h5>
                <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
            </div>
            <div class="modal-body">
                <div class="qr-container">
                    <div id="qrcode" class="mb-3"></div>
                    <div id="qrDownloadContainer" class="text-center d-none">
                        <button type="button" class="btn btn-primary">
                            <i class="fas fa-download me-2"></i> Download QR Code
                        </button>
                    </div>
                </div>
            </div>
        </div>
    </div>
</div>

<!-- Status Toast Container -->
<div class="toast-container position-fixed bottom-0 end-0 p-3">
  <!-- Toasts will be inserted here dynamically -->
</div>
{% endblock %}

{% block extra_js %}
<script>
    document.addEventListener('DOMContentLoaded', function() {
        // Initialize form components in one place for easier updates
        function initializeFormComponents() {
            // Show QR code in modal when generated
            const generateQRButton = document.getElementById('generateQR');
            if (generateQRButton) {
                const qrModalElement = document.getElementById('qrModal');
                if (qrModalElement) {
                    const qrModal = new bootstrap.Modal(qrModalElement);
                    
                    // Remove any existing event listener first
                    generateQRButton.removeEventListener('click', showQRModal);
                    
                    // Add new event listener
                    generateQRButton.addEventListener('click', showQRModal);
                    
                    function showQRModal() {
                        try {
                            // Show modal first, then generate QR code
                            qrModal.show();
                            if (typeof generateQRCode === 'function') {
                                generateQRCode(); // This function is defined in scripts.js
                            }
                        } catch (error) {
                            console.error('Error showing QR modal:', error);
                        }
                    }
                } else {
                    console.warn('QR Modal element not found');
                }
            } else {
                console.warn('Generate QR Button not found');
            }
            
            // Initialize counters (needed for points calculation)
            initializeCounters();
            
            // Initialize star rating system
            initializeRatings();
            
            // Initialize match period tabs
            initializeMatchPeriodTabs();
            
            // Initialize points calculation
            initializePointsCalculation();

            // Form reset button
            initializeResetButton();

            // Setup save button with enhanced functionality
            setupSaveButton();
            
            // Setup export JSON button
            setupExportJsonButton();

            // Setup save locally handler (if scripts.js provided it)
            if (typeof setupSaveLocally === 'function') {
                try { setupSaveLocally(); } catch (e) { /* ignore */ }
            }

            // Make sure points are calculated on page load
            updatePointsCalculation();
        }
        
        // Function to show toast notifications
        function showToast(message, type = 'info') {
            const toastContainer = document.querySelector('.toast-container');
            if (!toastContainer) return;
            
            const toast = document.createElement('div');
            toast.classList.add('toast', 'align-items-center', 'border-0');
            toast.classList.add(`bg-${type === 'error' ? 'danger' : type}`);
            toast.classList.add(type === 'error' || type === 'success' ? 'text-white' : '');
            toast.setAttribute('role', 'alert');
            toast.setAttribute('aria-live', 'assertive');
            toast.setAttribute('aria-atomic', 'true');
            
            toast.innerHTML = `
                <div class="d-flex">
                    <div class="toast-body">
                        <i class="fas fa-${type === 'success' ? 'check-circle' : type === 'error' ? 'exclamation-circle' : 'info-circle'} me-2"></i>
                        ${message}
                    </div>
                    <button type="button" class="btn-close btn-close-white me-2 m-auto" data-bs-dismiss="toast" aria-label="Close"></button>
                </div>
            `;
            
            toastContainer.appendChild(toast);
            
            const bsToast = new bootstrap.Toast(toast, {
                delay: 5000
            });
            
            bsToast.show();
            
            // Remove toast from DOM after it's been hidden
            toast.addEventListener('hidden.bs.toast', function() {
                if (toast.parentNode) {
                    toast.parentNode.removeChild(toast);
                }
            });
        }
        
        // Set up Save button handler
        function setupSaveButton() {
            const saveBtn = document.getElementById('save-button');
            if (!saveBtn) return;
            
            saveBtn.addEventListener('click', function(e) {
                e.preventDefault();
                
                const form = document.getElementById('scouting-form');
                if (!form) return;
                
                // Validate form
                if (!validateForm(form)) {
                    showToast('Please fill in all required fields', 'error');
                    return;
                }
                
                // Visual feedback - change button state
                const originalText = saveBtn.innerHTML;
                saveBtn.disabled = true;
                saveBtn.innerHTML = '<span class="spinner-border spinner-border-sm me-2" role="status"></span>Saving...';
                
                // Get the form data
                const formData = new FormData(form);
                
                // Submit form via AJAX
                fetch('{{ url_for("scouting.api_save") }}', {
                    method: 'POST',
                    body: formData,
                    headers: {
                        'X-Requested-With': 'XMLHttpRequest'
                    }
                })
                .then(response => {
                    if (!response.ok) {
                        throw new Error('Network response was not ok: ' + response.statusText);
                    }
                    return response.json();
                })
                .then(data => {
                    console.log('Save response:', data);
                    
                    // Reset button state
                    saveBtn.disabled = false;
                    saveBtn.innerHTML = originalText;
                    
                    if (data.success) {
                        // Show success message with some feedback about what was saved
                        showToast(`Data for Team ${data.team_number} in ${data.match_type} ${data.match_number} ${data.action} successfully!`, 'success');
                        
                        // Instead of redirecting, show a success indicator on the form
                        const formContainer = document.querySelector('.scouting-form');
                        if (formContainer) {
                            // Add visual success indicator to the form
                            formContainer.classList.add('form-saved');
                            setTimeout(() => {
                                formContainer.classList.remove('form-saved');
                            }, 2000);
                        }
                        
                        // Add a small badge showing when saved
                        const saveTimeIndicator = document.createElement('div');
                        saveTimeIndicator.className = 'save-indicator';
                        saveTimeIndicator.innerHTML = `
                            <div class="small text-success mt-2 text-end">
                                <i class="fas fa-check-circle me-1"></i>
                                Last saved at ${data.timestamp}
                            </div>
                        `;
                        
                        // Replace existing indicator or add new one
                        const existingIndicator = document.querySelector('.save-indicator');
                        if (existingIndicator) {
                            existingIndicator.replaceWith(saveTimeIndicator);
                        } else {
                            const buttonContainer = saveBtn.closest('.form-section');
                            if (buttonContainer) {
                                buttonContainer.appendChild(saveTimeIndicator);
                            }
                        }
                    } else {
                        showToast('Error: ' + (data.message || 'Unknown error'), 'error');
                    }
                })
                .catch(error => {
                    console.error('Error saving data:', error);
                    
                    // Reset button state
                    saveBtn.disabled = false;
                    saveBtn.innerHTML = originalText;
                    
                    // Handle error
                    showToast('Error saving data. Please try again or generate a QR code instead.', 'error');
                    
                    // If offline or connection error, suggest QR code
                    if (!navigator.onLine || error.message.includes('Network')) {
                        showToast('You appear to be offline. Try generating a QR code instead.', 'info');
                    }
                });
            });
        }
        
        // Set up Export JSON button handler
        function setupExportJsonButton() {
            const exportBtn = document.getElementById('export-json-button');
            if (!exportBtn) return;
            
            exportBtn.addEventListener('click', function(e) {
                e.preventDefault();
                
                const form = document.getElementById('scouting-form');
                if (!form) return;
                
                // Visual feedback - change button state
                const originalText = exportBtn.innerHTML;
                exportBtn.disabled = true;
                exportBtn.innerHTML = '<span class="spinner-border spinner-border-sm me-2" role="status"></span>Exporting...';
                
                try {
                    // Get the form data
                    const formData = new FormData(form);
                    const jsonData = {};
                    
                    // Convert form data to JSON object
                    for (let [key, value] of formData.entries()) {
                        if (jsonData[key]) {
                            // Handle multiple values (like checkboxes with same name)
                            if (Array.isArray(jsonData[key])) {
                                jsonData[key].push(value);
                            } else {
                                jsonData[key] = [jsonData[key], value];
                            }
                        } else {
                            jsonData[key] = value;
                        }
                    }
                    
                    // Add metadata
                    const metadata = {
                        export_timestamp: new Date().toISOString(),
                        form_type: 'scouting_data',
                        team_number: jsonData.team_id || 'unknown',
                        match_number: jsonData.match_id || 'unknown',
                        scout_name: jsonData.scout_name || 'unknown'
                    };
                    
                    const exportData = {
                        metadata: metadata,
                        form_data: jsonData
                    };
                    
                    // Create and download the JSON file
                    const jsonString = JSON.stringify(exportData, null, 2);
                    const blob = new Blob([jsonString], { type: 'application/json' });
                    const url = URL.createObjectURL(blob);
                    
                    // Create download link
                    const a = document.createElement('a');
                    a.href = url;
                    const timestamp = new Date().toISOString().replace(/[:.]/g, '-').split('.')[0];
                    a.download = `scouting-data-team-${metadata.team_number}-match-${metadata.match_number}-${timestamp}.json`;
                    document.body.appendChild(a);
                    a.click();
                    document.body.removeChild(a);
                    URL.revokeObjectURL(url);
                    
                    // Reset button state
                    exportBtn.disabled = false;
                    exportBtn.innerHTML = originalText;
                    
                    showToast('Scouting data exported successfully!', 'success');
                    
                } catch (error) {
                    console.error('Error exporting data:', error);
                    
                    // Reset button state
                    exportBtn.disabled = false;
                    exportBtn.innerHTML = originalText;
                    
                    showToast('Error exporting data. Please try again.', 'error');
                }
            });
        }
        
        // Form validation helper
        function validateForm(form) {
            const requiredFields = form.querySelectorAll('[required]');
            let valid = true;
            
            requiredFields.forEach(field => {
                if (!field.value) {
                    field.classList.add('is-invalid');
                    valid = false;
                    
                    // Focus first invalid field
                    if (valid === false && field === requiredFields[0]) {
                        field.focus();
                    }
                } else {
                    field.classList.remove('is-invalid');
                }
            });
            
            return valid;
        }
        
        // Initialize form reset button
        function initializeResetButton() {
            const resetBtn = document.getElementById('reset-form');
            if (resetBtn) {
                resetBtn.addEventListener('click', function() {
                    if (confirm('Are you sure you want to reset all form fields?')) {
                        const formInputs = document.querySelectorAll('#scouting-form input:not([type="hidden"]), #scouting-form select, #scouting-form textarea');
                        formInputs.forEach(input => {
                            if (input.type === 'checkbox') {
                                input.checked = false;
                            } else if (input.tagName === 'SELECT') {
                                input.selectedIndex = 0;
                            } else if (input.type === 'number' || input.classList.contains('counter-input')) {
                                // Reset numeric counters to 0 (not empty). Empty/null breaks arithmetic with +/- handlers.
                                try { input.value = 0; } catch (e) { input.value = '0'; }
                            } else {
                                input.value = '';
                            }
                        });
                        
                        // Update points after resetting form
                        updatePointsCalculation();
                    }
                });
            }
        }
        
        // Team and Match selection enhancements with auto-submit
        const teamSelector = document.getElementById('team-selector');
        const matchSelector = document.getElementById('match-selector');
        const teamMatchForm = document.getElementById('team-match-form');
        
        if (teamSelector && matchSelector && teamMatchForm) {
            // New: search inputs for filtering options
            const teamSearch = document.getElementById('team-search');
            const matchSearch = document.getElementById('match-search');

            // Helper to normalize strings for comparison
            function normalizeString(s) {
                return (s || '').toString().toLowerCase().trim();
            }

            // Filter team options by team number or name
            function filterTeamOptions() {
                const query = normalizeString(teamSearch.value);
                const options = Array.from(teamSelector.querySelectorAll('option'));

                // Keep the empty placeholder visible
                options.forEach(opt => {
                    if (!opt.value) return; // placeholder

                    const teamNumber = normalizeString(opt.getAttribute('data-team-number'));
                    const teamName = normalizeString(opt.getAttribute('data-team-name'));
                    const text = normalizeString(opt.textContent || opt.innerText);
                    const match = !query || teamNumber.includes(query) || teamName.includes(query) || text.includes(query);

                    opt.hidden = !match;
                    opt.style.display = match ? '' : 'none';
                });

                // If the currently selected option is hidden by filter, reset selection to placeholder
                const current = teamSelector.options[teamSelector.selectedIndex];
                if (current && current.hidden) {
                    teamSelector.value = '';
                }

                // Auto-select if there's exactly one visible non-placeholder option
                const visibleOptions = options.filter(opt => opt.value && !opt.hidden);
                if (visibleOptions.length === 1) {
                    const only = visibleOptions[0];

                    // For teams: prefer exact team number match OR if query-empty but only one option
                    const teamNumberAttr = normalizeString(only.getAttribute('data-team-number'));
                    const exactNumberMatch = query && teamNumberAttr === query;

                    if (exactNumberMatch || query === '' || query.length > 0 && exactNumberMatch) {
                        // Programmatically select and dispatch change
                        teamSelector.value = only.value;
                        teamSelector.dispatchEvent(new Event('change', { bubbles: true }));
                    }
                }
            }

            // Filter match options by match type or number, with shorthand parsing
            function filterMatchOptions() {
                const raw = normalizeString(matchSearch.value);
                const options = Array.from(matchSelector.querySelectorAll('option'));

                // Parse query into alpha and numeric parts (e.g., 'sf1' -> letters: 'sf', number: '1')
                function parseMatchQuery(q) {
                    if (!q) return { letters: '', number: '' };
                    // remove extra spaces
                    const compact = q.replace(/\s+/g, '');
                    const numMatch = compact.match(/(\d+)/);
                    const number = numMatch ? numMatch[1] : '';
                    const letters = compact.replace(/\d+/g, '');
                    return { letters: letters, number: number };
                }

                const q = parseMatchQuery(raw);

                // Aliases for canonical match type words
                const aliases = {
                    qualification: ['q','qu','qual','qualification','qualif','qualifcation','qualifc'],
                    practice: ['p','pr','practice','prac','pract','pm','pm1'],
                    quarter: ['qf','quarter','quarterfinal','quarterfinals','quarter-final','quarter-finals','quarterfinals','qtr'],
                    semi: ['sf','sem','semi','semifinal','semifinals','sf1','smf','smf1','semifinalmatch'],
                    final: ['f','fin','final','finals','f1'],
                    playoff: ['playoff','po','playoffs','pm','pm1']
                };

                // Determine which canonical types the letters token maps to
                function candidateTypesFromLetters(letters) {
                    if (!letters) return [];
                    const res = [];
                    for (const [canon, arr] of Object.entries(aliases)) {
                        for (const a of arr) {
                            if (letters === a || letters.startsWith(a) || a.startsWith(letters)) {
                                res.push(canon);
                                break;
                            }
                        }
                    }
                    return res;
                }

                const candidateTypes = candidateTypesFromLetters(q.letters);

                // We'll compute a score for each option and use that to determine visibility and best match
                const scored = [];
                options.forEach(opt => {
                    if (!opt.value) return; // placeholder

                    const matchType = normalizeString(opt.getAttribute('data-match-type') || '');
                    const matchNumber = normalizeString(opt.getAttribute('data-match-number') || '');
                    const text = normalizeString(opt.textContent || opt.innerText || '');

                    let score = 0;

                    // Strong boost for exact number match
                    if (q.number && matchNumber === q.number) score += 60;

                    // Good boost if text contains the number
                    if (q.number && text.includes(q.number)) score += 20;

                    // Letters/type matching via canonical candidates
                    if (q.letters && candidateTypes.length > 0) {
                        for (const ct of candidateTypes) {
                            if (matchType.includes(ct)) score += 40;
                            if (text.includes(ct)) score += 25;
                            if (ct.startsWith(q.letters) || q.letters.startsWith(ct)) score += 10;
                        }
                    }

                    // Loose letter match against the displayed text
                    if (q.letters && text.includes(q.letters)) score += 10;

                    // Small boosts for startsWith matches
                    if (raw && text.startsWith(raw)) score += 8;
                    if (raw && matchType.startsWith(raw)) score += 6;

                    // If no query, give minimal score so everything remains visible
                    if (!q.letters && !q.number) score += 1;

                    // Record
                    scored.push({ opt, score, matchType, matchNumber, text });
                });

                // Decide visibility: show items with score > 0 (or all if query empty)
                scored.forEach(s => {
                    const visible = s.score > 0;
                    s.opt.hidden = !visible;
                    s.opt.style.display = visible ? '' : 'none';
                });

                // Find best-scoring candidate
                scored.sort((a, b) => b.score - a.score);
                const best = scored[0];
                const second = scored[1];

                // Selection logic: choose best if it's reasonably strong and unambiguous
                if (best && best.score > 0) {
                    const threshold = 40; // minimum score to consider auto-select
                    const gap = (second ? best.score - second.score : best.score);

                    if (best.score >= threshold && gap >= 20) {
                        // auto-select best candidate
                        matchSelector.value = best.opt.value;
                        matchSelector.dispatchEvent(new Event('change', { bubbles: true }));
                    }
                }

                const current = matchSelector.options[matchSelector.selectedIndex];
                if (current && current.hidden) {
                    matchSelector.value = '';
                }

                // Auto-select if there's exactly one visible non-placeholder match option
                const visibleMatchOptions = options.filter(opt => opt.value && !opt.hidden);
                if (visibleMatchOptions.length === 1) {
                    const only = visibleMatchOptions[0];
                    matchSelector.value = only.value;
                    matchSelector.dispatchEvent(new Event('change', { bubbles: true }));
                }
            }

            // Attach input listeners with debounce to avoid overfiring
            function debounce(func, wait) {
                let timeout;
                return function(...args) {
                    clearTimeout(timeout);
                    timeout = setTimeout(() => func.apply(this, args), wait);
                };
            }

            if (teamSearch) teamSearch.addEventListener('input', debounce(filterTeamOptions, 150));
            if (matchSearch) matchSearch.addEventListener('input', debounce(filterMatchOptions, 150));

            // Ensure filters run on initial load (e.g., when localStorage preselects values)
            try { filterTeamOptions(); filterMatchOptions(); } catch (e) { /* ignore */ }
            // Style match type dropdown options
            const matchOptions = matchSelector.querySelectorAll('option');
            matchOptions.forEach(option => {
                if (option.value) {
                    const matchType = option.getAttribute('data-match-type');
                    let textClass = '';
                    
                    if (matchType === 'Qualification') {
                        textClass = 'text-primary';
                    } else if (matchType === 'Playoff') {
                        textClass = 'text-danger';
                    } else if (matchType === 'Practice') {
                        textClass = 'text-success';
                    }
                    
                    if (textClass) {
                        option.classList.add(textClass, 'fw-bold');
                    }
                }
            });
            
            // Save form data for offline use
            function saveFormDataOffline(teamId, matchId) {
                try {
                    localStorage.setItem('last_team_id', teamId);
                    localStorage.setItem('last_match_id', matchId);
                } catch (e) {
                    console.warn("Unable to save to localStorage:", e);
                }
            }
            
            // Load form when team and match are selected
            function loadForm() {
                const teamId = document.getElementById('team-selector').value;
                const matchId = document.getElementById('match-selector').value;
                
                if (!teamId || !matchId) return;
                
                // Show loading indicator
                const formContent = document.getElementById('form-content');
                formContent.innerHTML = `
                    <div class="text-center py-5">
                        <div class="spinner-border text-primary" role="status">
                            <span class="visually-hidden">Loading...</span>
                        </div>
                        <p class="mt-3">Loading scouting form...</p>
                    </div>
                `;
                
                // Save selected values in localStorage for offline use
                try {
                    localStorage.setItem('last_team_id', teamId);
                    localStorage.setItem('last_match_id', matchId);
                } catch (e) {
                    console.warn("Unable to save to localStorage:", e);
                }
                
                // Create form data for the AJAX request
                const formData = new FormData();
                formData.append('team_id', teamId);
                formData.append('match_id', matchId);
                
                // Capture scroll/focus state before AJAX request so we can restore after DOM replacement
                const __savedScrollY = window.scrollY || 0;
                const __savedActiveId = (document.activeElement && document.activeElement.id) ? document.activeElement.id : null;

                // Make AJAX request
                fetch('{{ url_for("scouting.scouting_form") }}', {
                    method: 'POST',
                    body: formData,
                    headers: {
                        'X-Requested-With': 'XMLHttpRequest'
                    }
                })
                .then(response => {
                    // Check if response is OK
                    if (!response.ok) {
                        throw new Error(`HTTP ${response.status}: ${response.statusText}`);
                    }
                    
                    // Check if response is JSON
                    const contentType = response.headers.get('content-type');
                    if (!contentType || !contentType.includes('application/json')) {
                        throw new Error('Server returned non-JSON response');
                    }
                    
                    return response.json();
                })
                .then(data => {
                    if (data.success) {
                        // Update form content
                        formContent.innerHTML = data.html;

                        // Show warning if there was data corruption
                        if (data.warning) {
                            const warningAlert = document.createElement('div');
                            warningAlert.className = 'alert alert-warning alert-dismissible fade show mb-3';
                            warningAlert.innerHTML = `
                                <i class="fas fa-exclamation-triangle me-2"></i>
                                ${data.warning}
                                <button type="button" class="btn-close" data-bs-dismiss="alert" aria-label="Close"></button>
                            `;
                            formContent.insertBefore(warningAlert, formContent.firstChild);
                        }

                        // Update subheading
                        document.getElementById('form-subheading').textContent = 
                            `${data.team_number} - ${data.team_name} | ${data.match_type} ${data.match_number}`;

                        // Initialize form components AFTER the form is loaded and restore previous scroll/focus
                        setTimeout(() => {
                            initializeFormComponents();

                            // Restore scroll position
                            try {
                                window.scrollTo(0, __savedScrollY);
                            } catch (e) {
                                console.warn('Could not restore scroll position', e);
                            }

                            // Restore focus to previously focused element if it still exists
                            if (__savedActiveId) {
                                try {
                                    const prev = document.getElementById(__savedActiveId);
                                    if (prev && typeof prev.focus === 'function') {
                                        prev.focus({ preventScroll: true });
                                    }
                                } catch (e) {
                                    // ignore
                                }
                            }
                        }, 100);
                    } else {
                        formContent.innerHTML = `
                            <div class="alert alert-danger">
                                <i class="fas fa-exclamation-circle me-2"></i>
                                ${data.message || 'An error occurred while loading the form.'}
                            </div>
                        `;
                    }
                })
                .catch(error => {
                    console.error('Error loading form:', error);
                    
                    let errorMessage = 'Error loading form. Please try again.';
                    
                    if (error.message.includes('HTTP 500')) {
                        errorMessage = 'Server error occurred. Please check the server logs or try again later.';
                    } else if (error.message.includes('non-JSON response')) {
                        errorMessage = 'Server returned an unexpected response. There may be a server error.';
                    } else if (error.message.includes('Network')) {
                        errorMessage = 'Network error. Please check your connection and try again.';
                    }
                    
                    formContent.innerHTML = `
                        <div class="alert alert-danger">
                            <i class="fas fa-exclamation-circle me-2"></i>
                            ${errorMessage}
                            <div class="mt-2 small text-muted">
                                Technical details: ${error.message}
                            </div>
                        </div>
                    `;
                });
            }
            
            // Auto-submit when both selections are made
            function checkSelections() {
                const teamId = teamSelector.value;
                const matchId = matchSelector.value;
                
                if (teamId && matchId) {
                    // Visual feedback
                    teamSelector.classList.add('border-success');
                    matchSelector.classList.add('border-success');
                    
                    loadForm();
                } else {
                    teamSelector.classList.remove('border-success');
                    matchSelector.classList.remove('border-success');
                }
            }
            
            // Initialize from localStorage if available
            try {
                const lastTeamId = localStorage.getItem('last_team_id');
                const lastMatchId = localStorage.getItem('last_match_id');
                
                // If we have stored values and no current selection, use them
                if (lastTeamId && lastMatchId && !teamSelector.value && !matchSelector.value) {
                    teamSelector.value = lastTeamId;
                    matchSelector.value = lastMatchId;
                    if (teamSelector.value && matchSelector.value) {
                        checkSelections();
                    }
                }
            } catch (e) {
                console.warn("Unable to retrieve from localStorage:", e);
            }
            
            // Attach event listeners
            teamSelector.addEventListener('change', checkSelections);
            matchSelector.addEventListener('change', checkSelections);
        }
        
        // Initialize existing form components if present on page load
        initializeFormComponents();
        
        // ======== REAL-TIME CONFIG UPDATE LISTENERS ========
        
        // Listen for game config updates
        window.addEventListener('gameConfigUpdated', function(event) {
            const newGameConfig = event.detail;
            console.log('Game config updated in scouting form:', newGameConfig);
            
            // Show notification to user
            showConfigUpdateNotification('Game configuration has been updated due to alliance mode change.');
            
            // Optionally reload form elements or show a reload prompt
            if (confirm('The game configuration has been updated. Would you like to reload the form to use the new configuration?')) {
                window.location.reload();
            }
        });
        
        // ======== GLOBAL CONFIG RELOAD HANDLER ========
        // Listen for global config changes that require form reload
        window.addEventListener('globalConfigReload', function(event) {
            const configData = event.detail;
            console.log('Global config reload in scouting form:', configData);
            
            // Show notification
            showConfigUpdateNotification(`Configuration updated: ${configData.message}`);
            
            // Automatically reload the form content without full page reload
            reloadFormWithNewConfig();
        });
        
        // Function to reload form content with new configuration
        window.reloadFormWithNewConfig = function() {
            console.log('Reloading scouting form with new configuration...');
            
            // Get current form state
            const currentTeamId = document.getElementById('team-selector')?.value;
            const currentMatchId = document.getElementById('match-selector')?.value;
            
            if (!currentTeamId || !currentMatchId) {
                console.log('No team/match selected, skipping form reload');
                return;
            }
            
            // Capture scroll/focus state before AJAX request so we can restore after DOM replacement
            const __savedScrollY = window.scrollY || 0;
            const __savedActiveId = (document.activeElement && document.activeElement.id) ? document.activeElement.id : null;

            // Reload the form content via AJAX
            fetch(window.location.pathname, {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/x-www-form-urlencoded',
                    'X-Requested-With': 'XMLHttpRequest'
                },
                body: new URLSearchParams({
                    'team_id': currentTeamId,
                    'match_id': currentMatchId
                })
            })
            .then(response => response.json())
            .then(data => {
                if (data.success) {
                    // Replace the current form content
                    const currentFormContent = document.getElementById('form-content');
                    if (currentFormContent && data.html) {
                        currentFormContent.innerHTML = data.html;
                        
                        // Show warning if there was data corruption
                        if (data.warning) {
                            const warningAlert = document.createElement('div');
                            warningAlert.className = 'alert alert-warning alert-dismissible fade show mb-3';
                            warningAlert.innerHTML = `
                                <i class="fas fa-exclamation-triangle me-2"></i>
                                ${data.warning}
                                <button type="button" class="btn-close" data-bs-dismiss="alert" aria-label="Close"></button>
                            `;
                            currentFormContent.insertBefore(warningAlert, currentFormContent.firstChild);
                        }
                        
                        // Reinitialize form components
                        initializeFormComponents();

                        // Restore scroll position
                        try {
                            window.scrollTo(0, __savedScrollY);
                        } catch (e) { /* ignore */ }

                        // Restore focus to previously focused element if it still exists
                        if (__savedActiveId) {
                            try {
                                const prev = document.getElementById(__savedActiveId);
                                if (prev && typeof prev.focus === 'function') prev.focus({ preventScroll: true });
                            } catch (e) { /* ignore */ }
                        }

                        console.log('Form reloaded successfully with new configuration');
                        showConfigUpdateNotification('Form updated with new configuration');
                    }
                } else {
                    console.error('Error reloading form:', data.message);
                    showConfigUpdateNotification('Error reloading form: ' + data.message, 'error');
                }
            })
            .catch(error => {
                console.error('Error reloading form:', error);
                showConfigUpdateNotification('Error reloading form. Please refresh the page.', 'error');
            });
        };
        
        // Listen for alliance status changes
        window.addEventListener('allianceStatusUpdated', function(event) {
            const allianceStatus = event.detail;
            console.log('Alliance status updated in scouting form:', allianceStatus);
            
            if (allianceStatus.is_active) {
                showConfigUpdateNotification(`Alliance mode activated. Now using shared configuration from ${allianceStatus.alliance_info?.alliance_name || 'alliance'}.`);
            } else {
                showConfigUpdateNotification('Alliance mode deactivated. Now using individual team configuration.');
            }
        });
        
        // Function to show config update notifications
        function showConfigUpdateNotification(message) {
            // Create a notification banner
            const notification = document.createElement('div');
            notification.className = 'alert alert-info alert-dismissible fade show position-fixed';
            notification.style.cssText = 'top: 20px; right: 20px; z-index: 9999; max-width: 400px;';
            notification.innerHTML = `
                <i class="fas fa-sync-alt me-2"></i>
                ${message}
                <button type="button" class="btn-close" data-bs-dismiss="alert"></button>
            `;
            
            document.body.appendChild(notification);
            
            // Auto-remove after 10 seconds
            setTimeout(() => {
                if (notification.parentNode) {
                    notification.remove();
                }
            }, 10000);
        }
    });
</script>
<link rel="stylesheet" href="{{ url_for('static', filename='css/scale-ui.css') }}">
<script src="{{ url_for('static', filename='js/scale-ui.js') }}"></script>
{% endblock %}