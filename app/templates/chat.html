{% extends 'base.html' %}

{% block title %}Chat{% endblock %}

{% block content %}
<div class="container mt-4">
    <h1 class="mb-4">Chat</h1>

    <!-- YPP Reminder Card -->
    <div class="card mb-3 border-warning">
        <div class="card-body d-flex align-items-start gap-3">
            <div class="fs-3 text-warning"><i class="fas fa-exclamation-circle"></i></div>
            <div>
                <h5 class="card-title mb-1">Youth Protection Program (YPP)</h5>
                <p class="card-text mb-0">When chatting on this platform, always follow the FIRST Youth Protection Program guidelines. Read the guide here: <a href="https://www.firstinspires.org/sites/default/files/uploads/about/FIRST-YPP-ProgramGuide.pdf" target="_blank" rel="noopener">FIRST YPP Program Guide (PDF)</a>.</p>
            </div>
        </div>
    </div>

    <ul class="nav nav-tabs" id="chatTab" role="tablist" style="margin-bottom: 1rem;">
        <li class="nav-item" role="presentation">
            <button class="nav-link active" id="dm-tab" data-bs-toggle="tab" data-bs-target="#dmTabPane" type="button" role="tab">DMs</button>
        </li>
        <li class="nav-item" role="presentation">
            <button class="nav-link" id="groups-tab" data-bs-toggle="tab" data-bs-target="#groupsTabPane" type="button" role="tab">Groups</button>
        </li>
    </ul>

    <div class="tab-content" id="chatTabContent">
        <!-- DM Tab -->
        <div class="tab-pane fade show active" id="dmTabPane" role="tabpanel">
            <div class="row">
                <div class="col-md-4 mb-3">
                    <div class="card h-100">
                        <div class="card-header">Conversations</div>
                        <div class="card-body d-flex flex-column">
                            <label for="dmUserSelect" class="form-label mb-1">Chat with:</label>
                            <select id="dmUserSelect" class="form-select form-select-sm mb-2" style="width: 100%;"></select>
                            <div class="text-muted small mb-2">Select a user to open or continue a conversation.</div>
                            <div class="flex-grow-1 overflow-auto" style="min-height: 180px;">
                                <!-- Placeholder for recent conversations if needed -->
                            </div>
                        </div>
                    </div>
                </div>

                <div class="col-md-5 mb-3">
                    <div class="card h-100">
                        <div class="card-header">Messages</div>
                        <div class="card-body d-flex flex-column p-3">
                            <!-- Use a fixed height so the input remains visible and the messages area scrolls -->
                            <div id="dmChatContainer" class="flex-grow-1 overflow-auto bg-light p-2 rounded chat-messages-fixed-height" style="min-height: 300px;" {% if last_read_message_id is defined and last_read_message_id %}data-last-read="{{ last_read_message_id }}"{% endif %}></div>
                            <div class="mt-3">
                                <div class="input-group">
                                    <input type="text" class="form-control" id="dmChatInput" placeholder="Type a message...">
                                    <button class="btn btn-primary" id="dmSendBtn">Send</button>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>

                
            </div>
        </div>

        <!-- Assistant tab removed from frontend intentionally -->

        <!-- Group messaging UI removed -->
        <!-- Groups Tab -->
        <div class="tab-pane fade" id="groupsTabPane" role="tabpanel">
            <div class="row">
                <div class="col-md-4 mb-3">
                    <div class="card h-100">
                        <div class="card-header">Groups</div>
                        <div class="card-body d-flex flex-column">
                            <label for="groupNameInput" class="form-label mb-1">Group name:</label>
                            <input id="groupNameInput" class="form-control form-control-sm mb-2" placeholder="main" />
                            <label for="addMemberSelect" class="form-label mb-1">Add team member:</label>
                            <div class="input-group mb-2">
                                <select id="addMemberSelect" class="form-select form-select-sm"></select>
                                <button class="btn btn-outline-primary btn-sm" id="addMemberBtn">Add</button>
                            </div>
                            <div class="text-muted small mb-2">Add a teammate to the current group (they'll be added to server-side membership).</div>
                            <div class="btn-group mb-2" role="group">
                                <button class="btn btn-primary btn-sm" id="joinGroupBtn">Join</button>
                                <button class="btn btn-secondary btn-sm" id="leaveGroupBtn">Leave</button>
                            </div>
                            <div class="text-muted small mb-2">Join or enter a group name to chat with team members.</div>
                            <div id="currentGroupLabel" class="fw-bold mt-2"></div>
                            <hr />
                            <div class="mt-2">
                                <div class="fw-bold mb-1">Chats I'm in</div>
                                <ul id="myChatsList" class="list-unstyled small text-muted" style="max-height:200px; overflow:auto;"></ul>
                            </div>
                        </div>
                    </div>
                </div>

                <div class="col-md-5 mb-3">
                    <div class="card h-100">
                        <div class="card-header">Group Messages</div>
                        <div class="card-body d-flex flex-column p-3">
                            <div id="groupChatContainer" class="flex-grow-1 overflow-auto bg-light p-2 rounded" style="min-height: 300px;"></div>
                            <div class="mt-3">
                                <div class="input-group">
                                    <input type="text" class="form-control" id="groupChatInput" placeholder="Type a group message...">
                                    <button class="btn btn-primary" id="groupSendBtn">Send</button>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>

                <div class="col-md-3 mb-3">
                    <div class="card h-100">
                        <div class="card-header">Members</div>
                        <div class="card-body">
                            <ul id="groupMembersList" class="list-unstyled small text-muted"></ul>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>
</div>
{% endblock %}

{% block scripts %}
<script>
    // Add CSS for context menu
    const style = document.createElement('style');
    style.textContent = `
        :root {
            --context-bg: #ffffff;
            --context-border: #ccc;
            --context-text: #212529;
            --context-hover: #f8f9fa;
            --context-shadow: 0 2px 10px rgba(0,0,0,0.1);
        }
        /* Dark mode overrides via prefers-color-scheme */
        @media (prefers-color-scheme: dark) {
            :root {
                --context-bg: #1e1e1e;
                --context-border: #2c2c2c;
                --context-text: #e9edf0;
                --context-hover: #2a2a2a;
                --context-shadow: 0 6px 20px rgba(0,0,0,0.6);
            }
        }
        /* Also support an explicit page-level dark mode class */
        body.dark-mode {
            --context-bg: #1e1e1e;
            --context-border: #2c2c2c;
            --context-text: #e9edf0;
            --context-hover: #2a2a2a;
            --context-shadow: 0 6px 20px rgba(0,0,0,0.6);
        }

        .chat-message {
            position: relative;
            cursor: pointer;
            padding: 8px;
            border-radius: 6px;
            transition: background-color 0.2s;
        }
        .chat-message:hover {
            background-color: rgba(0,0,0,0.04);
        }
        .message-reactions {
            font-size: 0.9em;
            color: var(--context-text, #6c757d);
            margin-left: 10px;
        }
        .context-menu {
            position: absolute;
            background: var(--context-bg);
            color: var(--context-text);
            border: 1px solid var(--context-border);
            border-radius: 10px;
            box-shadow: var(--context-shadow);
            z-index: 1000;
            min-width: 160px;
            padding: 6px 0;
            -webkit-tap-highlight-color: transparent;
        }
        .context-menu-item {
            padding: 12px 18px;
            cursor: pointer;
            border: none;
            background: none;
            width: 100%;
            text-align: left;
            font-size: 16px;
            line-height: 1.2;
            display: block;
            color: inherit;
        }
        .context-menu-item:hover {
            background-color: var(--context-hover);
        }
        .context-menu-item:disabled {
            color: #6c757d;
            cursor: not-allowed;
        }
        .context-menu-item:disabled:hover {
            background-color: transparent;
        }
        .message-editing {
            background-color: #fff3cd;
        }
        .edit-input {
            width: 100%;
            border: 1px solid #ced4da;
            border-radius: 4px;
            padding: 6px 10px;
            font-size: inherit;
        }
        .edit-actions {
            margin-top: 8px;
        }
        .edit-actions button {
            margin-right: 5px;
        }

        /* Mobile-specific context behavior */
        @media (max-width: 600px) {
            .context-menu {
                min-width: calc(100% - 32px);
                left: 16px !important;
                right: 16px !important;
                bottom: 20px !important;
                top: auto !important;
                border-radius: 12px;
                padding: 8px 0;
            }
            .context-menu-item { padding: 14px 18px; font-size: 18px; }
        }
        
        /* Enhanced mobile input protection */
        @media (max-width: 768px) {
            /* Prevent chat inputs from zooming */
            #dmChatInput, #assistantChatInput, #groupChatInput, 
            #groupNameInput, #dmUserSelect, #addMemberSelect {
                font-size: 16px !important;
                transform: translateZ(0);
                -webkit-transform: translateZ(0);
            }
            
            /* Stabilize chat containers */
            .card-body, .tab-content, .chat-message {
                transform: translateZ(0);
                -webkit-transform: translateZ(0);
            }
            
            /* Prevent scroll on focus */
            #dmChatInput:focus, #assistantChatInput:focus, #groupChatInput:focus {
                scroll-margin: 0 !important;
            }
        }
    `;
    document.head.appendChild(style);
    // Add a small stylesheet for fixed-height chat containers
    const fixedStyle = document.createElement('style');
    fixedStyle.textContent = `
        .chat-messages-fixed-height { height: 420px; max-height: 420px; }
        @media (max-width: 900px) { .chat-messages-fixed-height { height: 320px; max-height: 320px; } }
    `;
    document.head.appendChild(fixedStyle);

    // Context menu system
    let contextMenu = null;
    let longPressTimer = null;
    let longPressTriggered = false;

    function showContextMenu(event, messageElement) {
        event.preventDefault();
        hideContextMenu();
        
        const messageId = messageElement.getAttribute('data-message-id');
        const sender = messageElement.getAttribute('data-sender');
        const isOwnMessage = sender === currentUsername;
        
        if (!messageId) return; // Skip messages without IDs
        
        contextMenu = document.createElement('div');
        contextMenu.className = 'context-menu';
        
        // Edit option (only for own messages)
        if (isOwnMessage) {
            const editBtn = document.createElement('button');
            editBtn.className = 'context-menu-item';
            editBtn.innerHTML = '<i class="fas fa-edit"></i> Edit';
            editBtn.onclick = () => editMessage(messageElement);
            contextMenu.appendChild(editBtn);
            
            // Delete option (only for own messages)
            const deleteBtn = document.createElement('button');
            deleteBtn.className = 'context-menu-item';
            deleteBtn.innerHTML = '<i class="fas fa-trash"></i> Delete';
            deleteBtn.onclick = () => deleteMessage(messageElement);
            contextMenu.appendChild(deleteBtn);
        }
        
        // React options
        const reactions = ['👍', '👎', '❤️', '😄', '😮', '😢'];
        reactions.forEach(emoji => {
            const reactBtn = document.createElement('button');
            reactBtn.className = 'context-menu-item';
            reactBtn.innerHTML = `${emoji} React`;
            reactBtn.onclick = () => reactToMessage(messageElement, emoji);
            contextMenu.appendChild(reactBtn);
        });
        
        // Position the menu
        // Create and append a blocking overlay for mobile to capture taps and prevent background scrolling
        let overlay = document.getElementById('context-menu-overlay');
        if (!overlay) {
            overlay = document.createElement('div');
            overlay.id = 'context-menu-overlay';
            overlay.style.position = 'fixed';
            overlay.style.left = '0';
            overlay.style.top = '0';
            overlay.style.right = '0';
            overlay.style.bottom = '0';
            overlay.style.zIndex = 999;
            overlay.style.background = 'transparent';
            overlay.addEventListener('click', function(e) { hideContextMenu(); });
            overlay.addEventListener('touchstart', function(e) { e.preventDefault(); }, { passive: false });
            document.body.appendChild(overlay);
        }
        document.body.appendChild(contextMenu);
        const rect = contextMenu.getBoundingClientRect();
        // If on small screen (mobile), show as bottom sheet centered horizontally
        const isMobile = window.matchMedia('(max-width: 600px)').matches;
        if (isMobile) {
            // Use fixed positioning so menu doesn't shift the document flow
            contextMenu.style.position = 'fixed';
            contextMenu.style.left = '16px';
            contextMenu.style.right = '16px';
            contextMenu.style.bottom = '20px';
            contextMenu.style.top = 'auto';
            // Lock body scroll while menu is open without causing jump: fix body and preserve scrollY
            const scrollY = window.scrollY || window.pageYOffset || 0;
            document.body.style.position = 'fixed';
            document.body.style.top = `-${scrollY}px`;
            document.body.dataset._savedScroll = String(scrollY);
            document.body.classList.add('context-menu-open');
        } else {
            const x = (event.pageX || event.clientX || 0);
            const y = (event.pageY || event.clientY || 0);
            // Default place near the touch/click, but keep inside viewport
            let left = x;
            let top = y;
            if (left + rect.width > window.innerWidth) left = Math.max(8, window.innerWidth - rect.width - 8);
            if (top + rect.height > window.innerHeight) top = Math.max(8, window.innerHeight - rect.height - 8);
            contextMenu.style.left = left + 'px';
            contextMenu.style.top = top + 'px';
        }
    }

    function hideContextMenu() {
        if (contextMenu) {
            contextMenu.remove();
            contextMenu = null;
            // Restore body scrolling if we had locked it for mobile bottom sheet
            // Restore any fixed positioning used for scroll lock
            if (document.body.dataset && document.body.dataset._savedScroll) {
                try {
                    const saved = parseInt(document.body.dataset._savedScroll, 10) || 0;
                    document.body.style.position = '';
                    document.body.style.top = '';
                    // Briefly suppress the mobile stabilizer so it doesn't override our explicit restore
                    try {
                        // Use global helper that cooperates with the stabilizer
                        if (typeof window.safeRestoreScroll === 'function') {
                            window.safeRestoreScroll(saved, { behavior: 'auto', timeout: 300 });
                        } else {
                            // If helper unavailable, set suppression flag and attempt direct restore safely
                            try { window.__suppressMobileScrollJumps = true; } catch (e) {}
                            window.requestAnimationFrame(() => {
                                try {
                                    if (typeof window.safeRestoreScroll === 'function') {
                                        window.safeRestoreScroll(saved, { behavior: 'auto', timeout: 300 });
                                        } else {
                                            // Fallback: prefer the global helper if available, otherwise attempt direct restore
                                            try {
                                                if (window.safeRestoreScroll && typeof window.safeRestoreScroll === 'function') {
                                                    window.safeRestoreScroll(saved, { behavior: 'auto', timeout: 300 });
                                                } else {
                                                    try { window.scrollTo({ top: saved, behavior: 'auto' }); } catch (e) { try { window.scrollTo(0, saved); } catch(err){} }
                                                }
                                            } catch (e) {
                                                try { window.scrollTo(0, saved); } catch(err){}
                                            }
                                        }
                                } catch (e) {
                                    try {
                                        if (window.safeRestoreScroll && typeof window.safeRestoreScroll === 'function') {
                                            window.safeRestoreScroll(saved, { behavior: 'auto', timeout: 300 });
                                        } else {
                                            try { if (window.safeRestoreScroll && typeof window.safeRestoreScroll === 'function') { window.safeRestoreScroll(saved, { behavior: 'auto', timeout: 300 }); } else { window.scrollTo(0, saved); } } catch (err) {}
                                        }
                                    } catch (err) { try { if (window.safeRestoreScroll && typeof window.safeRestoreScroll === 'function') { window.safeRestoreScroll(saved, { behavior: 'auto', timeout: 300 }); } else { window.scrollTo(0, saved); } } catch(e){} }
                                }
                                setTimeout(() => { try { window.__suppressMobileScrollJumps = false; } catch (e) {} }, 300);
                            });
                        }
                    } catch (e) { /* ignore */ }
                    delete document.body.dataset._savedScroll;
                } catch (e) {
                    document.body.style.position = '';
                    document.body.style.top = '';
                }
            }
            document.body.classList.remove('context-menu-open');
            // Remove the overlay if present
            try {
                const overlay = document.getElementById('context-menu-overlay');
                if (overlay) overlay.remove();
            } catch (e) {}
        }
    }

    // Hide context menu when clicking elsewhere, but suppress the immediate click after opening via touch
    let suppressClickUntil = 0;
    document.addEventListener('click', function(e) {
        if (Date.now() < suppressClickUntil) {
            // ignore this click because it immediately followed a touch that opened the menu
            return;
        }
        hideContextMenu();
    });
    document.addEventListener('scroll', function() {
        // Only hide if menu is open and not displayed as a mobile bottom sheet
        if (contextMenu && !document.body.classList.contains('context-menu-open')) {
            hideContextMenu();
        }
    }, { passive: true });

    // Message action functions
    function editMessage(messageElement) {
        hideContextMenu();
        const messageId = messageElement.getAttribute('data-message-id');
        const textElement = messageElement.querySelector('.message-text');
        if (!textElement) return;
        
        const currentText = textElement.textContent;
        messageElement.classList.add('message-editing');
        
        textElement.innerHTML = `
            <input type="text" class="edit-input" value="${currentText.replace(/"/g, '&quot;')}" />
            <div class="edit-actions">
                <button class="btn btn-sm btn-primary save-edit">Save</button>
                <button class="btn btn-sm btn-secondary cancel-edit">Cancel</button>
            </div>
        `;
        
        const input = textElement.querySelector('.edit-input');
        const saveBtn = textElement.querySelector('.save-edit');
        const cancelBtn = textElement.querySelector('.cancel-edit');
        
        input.focus();
        
        saveBtn.onclick = async () => {
            const newText = input.value.trim();
            if (!newText || newText === currentText) {
                cancelEdit();
                return;
            }
            
            try {
                const response = await fetch('/chat/edit-message', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ message_id: messageId, text: newText })
                });
                
                if (response.ok) {
                    textElement.innerHTML = newText + ' <span class="text-muted ms-1">(edited)</span>';
                    messageElement.classList.remove('message-editing');
                } else {
                    alert('Failed to edit message');
                    cancelEdit();
                }
            } catch (e) {
                console.error('Error editing message:', e);
                alert('Failed to edit message');
                cancelEdit();
            }
        };
        
        cancelBtn.onclick = cancelEdit;
        input.onkeypress = (e) => {
            if (e.key === 'Enter') saveBtn.click();
            if (e.key === 'Escape') cancelEdit();
        };
        
        function cancelEdit() {
            textElement.innerHTML = currentText;
            messageElement.classList.remove('message-editing');
        }
    }

    function deleteMessage(messageElement) {
        hideContextMenu();
        if (!confirm('Delete this message?')) return;
        
        const messageId = messageElement.getAttribute('data-message-id');
        
        fetch('/chat/delete-message', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ message_id: messageId })
        }).then(response => {
            if (response.ok) {
                messageElement.style.opacity = '0.5';
                messageElement.querySelector('.message-text').innerHTML = '<em>Message deleted</em>';
            } else {
                alert('Failed to delete message');
            }
        }).catch(e => {
            console.error('Error deleting message:', e);
            alert('Failed to delete message');
        });
    }

    function reactToMessage(messageElement, emoji) {
        hideContextMenu();
        const messageId = messageElement.getAttribute('data-message-id');
        
        fetch('/chat/react-message', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ message_id: messageId, emoji: emoji })
        }).then(response => response.json())
        .then(data => {
            if (data.success) {
                // Update reactions display
                updateReactionsDisplay(messageElement, data.reactions);
            } else {
                alert('Failed to add reaction');
            }
        }).catch(e => {
            console.error('Error adding reaction:', e);
            alert('Failed to add reaction');
        });
    }

    function updateReactionsDisplay(messageElement, reactions) {
        let reactionsEl = messageElement.querySelector('.message-reactions');
        if (!reactionsEl) {
            reactionsEl = document.createElement('span');
            reactionsEl.className = 'message-reactions ms-2';
            const textElement = messageElement.querySelector('.message-text');
            textElement.parentNode.insertBefore(reactionsEl, textElement.nextSibling);
        }
        
        if (reactions && reactions.length > 0) {
            reactionsEl.innerHTML = reactions.map(r => (r.count != null ? `${r.emoji} ${r.count}` : `${r.emoji}`)).join(' ');
            reactionsEl.style.display = '';
        } else {
            reactionsEl.style.display = 'none';
        }
    }

    // Event delegation for message interaction
    function setupMessageEventListeners() {
        document.addEventListener('contextmenu', function(e) {
            const messageElement = e.target.closest('.chat-message');
            if (messageElement) {
                showContextMenu(e, messageElement);
            }
        });

        // Touch events for mobile long press
        // Enhanced touch handling: support long-press and tap-to-open without causing page jumps
        let touchStartInfo = null; // {time, x, y, target}
        document.addEventListener('touchstart', function(e) {
            const touch = e.touches[0];
            const messageElement = e.target.closest('.chat-message');
            touchStartInfo = {
                time: Date.now(),
                x: touch ? (touch.clientX || touch.pageX) : 0,
                y: touch ? (touch.clientY || touch.pageY) : 0,
                target: messageElement
            };
            if (messageElement) {
                longPressTriggered = false;
                longPressTimer = setTimeout(() => {
                    longPressTriggered = true;
                    const syntheticEvent = {
                        preventDefault: () => {},
                        pageX: touchStartInfo.x,
                        pageY: touchStartInfo.y,
                        clientX: touchStartInfo.x,
                        clientY: touchStartInfo.y
                    };
                    // Blur active element to avoid accidental focus scrolls on iOS
                    try { if (document.activeElement && document.activeElement.blur) document.activeElement.blur(); } catch(e) {}
                    showContextMenu(syntheticEvent, messageElement);
                    // Haptic feedback if available
                    if (navigator.vibrate) navigator.vibrate(50);
                    // Suppress the next click which may immediately follow this touch
                    suppressClickUntil = Date.now() + 500;
                }, 500); // long-press threshold
            }
        }, { passive: false });

        document.addEventListener('touchmove', function(e) {
            // Cancel long-press if finger moves significantly
            if (!touchStartInfo) return;
            const t = e.touches[0];
            const dx = Math.abs((t.clientX || t.pageX) - touchStartInfo.x);
            const dy = Math.abs((t.clientY || t.pageY) - touchStartInfo.y);
            if (dx > 10 || dy > 10) {
                if (longPressTimer) {
                    clearTimeout(longPressTimer);
                    longPressTimer = null;
                }
                touchStartInfo = null;
            }
        }, { passive: true });

        document.addEventListener('touchend', function(e) {
            // If long-press was triggered, just clear timers
            if (longPressTimer) {
                clearTimeout(longPressTimer);
                longPressTimer = null;
            }
            if (!touchStartInfo) return;
            const duration = Date.now() - touchStartInfo.time;
            // Treat as tap if short duration and small movement
            if (!longPressTriggered && duration < 300) {
                const touch = e.changedTouches ? e.changedTouches[0] : null;
                const x = touch ? (touch.clientX || touch.pageX) : touchStartInfo.x;
                const y = touch ? (touch.clientY || touch.pageY) : touchStartInfo.y;
                const targetMessage = touchStartInfo.target;
                if (targetMessage) {
                // Prevent default behavior that might scroll to top
                try { if (e.cancelable) e.preventDefault(); } catch (err) {}
                try { if (e.stopPropagation) e.stopPropagation(); } catch (err) {}
                    const syntheticEvent = {
                        preventDefault: () => {},
                        pageX: x,
                        pageY: y,
                        clientX: x,
                        clientY: y
                    };
                    // Open context menu as mobile bottom sheet on tap
                    showContextMenu(syntheticEvent, targetMessage);
                    // Prevent the immediate click from hiding it
                    suppressClickUntil = Date.now() + 500;
                }
            }
            touchStartInfo = null;
            longPressTriggered = false;
        }, { passive: false });

        // Prevent default navigation for anchors that use '#' or empty hrefs which can cause scroll-to-top on mobile
        document.addEventListener('click', function(e) {
            const a = e.target.closest && e.target.closest('a');
            if (!a) return;
            const href = a.getAttribute('href');
            if (!href || href === '#' || href.toLowerCase().startsWith('javascript:void')) {
                e.preventDefault();
                return false;
            }
        });

        // Prevent context menu on regular clicks for messages that had long press
        document.addEventListener('click', function(e) {
            const messageElement = e.target.closest('.chat-message');
            if (messageElement && longPressTriggered) {
                e.preventDefault();
                longPressTriggered = false;
            }
        });
    }

    // Setup event listeners
    setupMessageEventListeners();

    // Socket listeners for real-time updates
    socket.on('message_updated', function(data) {
        const messageElement = document.querySelector(`[data-message-id="${data.message_id}"]`);
        if (messageElement) {
            const textElement = messageElement.querySelector('.message-text');
            if (textElement) {
                textElement.innerHTML = data.text + ' <span class="text-muted ms-1">(edited)</span>';
            }
            updateReactionsDisplay(messageElement, data.reactions);
        }
    });

    socket.on('message_deleted', function(data) {
        const messageElement = document.querySelector(`[data-message-id="${data.message_id}"]`);
        if (messageElement) {
            messageElement.style.opacity = '0.5';
            const textElement = messageElement.querySelector('.message-text');
            if (textElement) {
                textElement.innerHTML = '<em>Message deleted</em>';
            }
        }
    });

    // Additional mobile scroll protection for chat inputs
    function protectChatInputs() {
        const isMobile = window.innerWidth <= 768;
        if (!isMobile) return;
        
        const chatInputs = ['dmChatInput', 'assistantChatInput', 'groupChatInput'];
        
        chatInputs.forEach(inputId => {
            const input = document.getElementById(inputId);
            if (input) {
                input.addEventListener('focus', function() {
                    const currentY = window.pageYOffset || document.documentElement.scrollTop || 0;
                    
                    // Multiple checks to prevent any scroll jumping
                    const checkAndRestore = () => {
                        const newY = window.pageYOffset || document.documentElement.scrollTop || 0;
                        if (Math.abs(newY - currentY) > 20) {
                            console.log(`Chat input focus scroll detected (${inputId}), restoring position`);
                            if (window.safeRestoreScroll && typeof window.safeRestoreScroll === 'function') {
                                window.safeRestoreScroll(currentY, { behavior: 'auto', timeout: 200 });
                            } else {
                                try { window.scrollTo(0, currentY); } catch(e) {}
                            }
                        }
                    };
                    
                    setTimeout(checkAndRestore, 50);
                    setTimeout(checkAndRestore, 100);
                    setTimeout(checkAndRestore, 200);
                    setTimeout(checkAndRestore, 300);
                }, { passive: true });
            }
        });
    }
    
    // Initialize chat input protection
    protectChatInputs();
    
    // Re-initialize on window resize
    window.addEventListener('resize', function() {
        clearTimeout(this.chatResizeTimeout);
        this.chatResizeTimeout = setTimeout(protectChatInputs, 250);
    });

</script>
<script>
document.addEventListener('DOMContentLoaded', function() {
  (async function() {
    // Socket.IO setup
    if (!window.socket) {
        window.socket = io();
    }
    const socket = window.socket;
    let currentUsername = null;
    // --- Backend helpers for persistence (only last selected DM user) ---
    async function saveChatState() {
        const dmUserSelectEl = document.getElementById('dmUserSelect');
        await fetch('/chat/state', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({
                lastDmUser: dmUserSelectEl ? dmUserSelectEl.value : ''
            })
        });
    }
    async function loadChatState() {
        try {
            const resp = await fetch('/chat/state');
            const data = await resp.json();
            window._lastDmUser = data.lastDmUser || '';
        } catch (e) {
            window._lastDmUser = '';
        }
    }
    // --- Restore state on page load ---
    await loadChatState();

    // Mark unread as read when user views the chat page
    try {
        fetch('/chat/reset-unread', { method: 'POST' }).then(r => {
            if (!r.ok) console.warn('Failed to reset unread on view');
        }).catch(e => console.warn('Error resetting unread on view', e));
    } catch (e) {
        console.warn('Error sending reset unread request', e);
    }

    // Populate DM and group user selects
    fetch('/assistant/chat-users').then(r => r.json()).then(data => {
        const dmUserSelect = document.getElementById('dmUserSelect');
        dmUserSelect.innerHTML = '';
        data.users.forEach(u => {
            const opt1 = document.createElement('option');
            opt1.value = u;
            opt1.textContent = u;
            dmUserSelect.appendChild(opt1);
        });
        currentUsername = data.current_user;
        // --- DM tab auto-select logic from URL ---
        const params = new URLSearchParams(window.location.search);
        const dmParam = params.get('dm');
        // If opened with focus param from unread link, attempt to focus that conversation
        const focusParam = params.get('focus');
        if (focusParam) {
            try {
                const focus = JSON.parse(decodeURIComponent(focusParam));
                if (focus && focus.type === 'dm' && focus.id) {
                    if (Array.from(dmUserSelect.options).some(opt => opt.value === focus.id)) {
                        dmUserSelect.value = focus.id;
                        const dmTab = document.getElementById('dm-tab');
                        if (dmTab) dmTab.click();
                    }
                }
            } catch (e) {
                console.warn('Invalid focus param', e);
            }
        }
        if (dmParam && Array.from(dmUserSelect.options).some(opt => opt.value === dmParam)) {
            dmUserSelect.value = dmParam;
            // Switch to DM tab
            const dmTab = document.getElementById('dm-tab');
            if (dmTab) dmTab.click();
        }
        // Restore last selected DM user
        const lastDmUser = window._lastDmUser;
        if (!dmParam && lastDmUser && Array.from(dmUserSelect.options).some(opt => opt.value === lastDmUser)) {
            dmUserSelect.value = lastDmUser;
        }
        // Attach event listener after populating
        dmUserSelect.addEventListener('change', function() {
            loadDmHistory();
            saveChatState();
        });
        // Load initial DM chat history
        loadDmHistory();
        // Load initial assistant chat history
        loadAssistantHistory();
    });

    // --- Group Chat: setup ---
    const groupNameInput = document.getElementById('groupNameInput');
    const joinGroupBtn = document.getElementById('joinGroupBtn');
    const leaveGroupBtn = document.getElementById('leaveGroupBtn');
    const groupChatInput = document.getElementById('groupChatInput');
    const groupSendBtn = document.getElementById('groupSendBtn');
    const groupChatContainer = document.getElementById('groupChatContainer');
    const currentGroupLabel = document.getElementById('currentGroupLabel');
    const groupMembersList = document.getElementById('groupMembersList');

    let currentGroup = '';

    async function loadGroupHistory(group) {
        groupChatContainer.innerHTML = '';
        if (!group) return;
        try {
            const resp = await fetch(`/chat/group-history?group=${encodeURIComponent(group)}`);
            const data = await resp.json();
            (data.history || []).forEach(msg => {
                const div = document.createElement('div');
                div.className = 'mb-2 chat-message';
                div.setAttribute('data-message-id', msg.id || '');
                div.setAttribute('data-sender', msg.sender);
                div.innerHTML = `
                    <strong>${msg.sender === currentUsername ? 'You' : msg.sender}:</strong>
                    <span class="message-text">${msg.text}</span>
                    ${((msg.reactions_summary && msg.reactions_summary.length > 0) ? msg.reactions_summary : (msg.reactions || [])).length > 0 ? `<span class="message-reactions">${((msg.reactions_summary && msg.reactions_summary.length > 0) ? msg.reactions_summary : (msg.reactions || [])).map(r => (r.count != null ? `${r.emoji} ${r.count}` : `${r.emoji}`)).join(' ')}</span>` : ''}
                    ${msg.edited ? '<span class="text-muted ms-1">(edited)</span>' : ''}
                `;
                groupChatContainer.appendChild(div);
            });
            groupChatContainer.scrollTop = groupChatContainer.scrollHeight;
        } catch (e) {
            console.warn('Failed to load group history', e);
        }
    }

    function setCurrentGroup(group) {
        currentGroup = group || '';
        currentGroupLabel.textContent = currentGroup ? `Group: ${currentGroup}` : '';
    }

    joinGroupBtn && joinGroupBtn.addEventListener('click', async function() {
        const group = (groupNameInput && groupNameInput.value.trim()) || 'main';
        if (!group) return;
        socket.emit('join_group', { group });
        socket.emit('add_user_to_group', { group, username: currentUsername });
        setCurrentGroup(group);
        await loadGroupHistory(group);
        // Refresh authoritative member list from server
        await refreshGroupMembers(group);
    });

    leaveGroupBtn && leaveGroupBtn.addEventListener('click', async function() {
        if (!currentGroup) return;
        socket.emit('leave_group', { group: currentGroup });
        socket.emit('remove_user_from_group', { group: currentGroup, username: currentUsername });
        // Give server a moment to update persisted membership, then refresh
        setCurrentGroup('');
        groupChatContainer.innerHTML = '';
        await refreshGroupMembers(currentGroup);
        groupMembersList.innerHTML = '';
    });

    groupSendBtn && groupSendBtn.addEventListener('click', function() {
        const text = groupChatInput ? groupChatInput.value.trim() : '';
        if (!text || !currentGroup) return;
        socket.emit('group_chat_message', { group: currentGroup, text });
        groupChatInput.value = '';
    });

    groupChatInput && groupChatInput.addEventListener('keypress', function(e) {
        if (e.key === 'Enter' && !e.shiftKey) {
            e.preventDefault();
            groupSendBtn && groupSendBtn.click();
        }
    });

    // --- New: Populate member dropdown and handle adding members to the group ---
    const addMemberSelect = document.getElementById('addMemberSelect');
    const addMemberBtn = document.getElementById('addMemberBtn');

    async function populateMemberDropdown() {
        if (!addMemberSelect) return;
        try {
            const resp = await fetch('/api/chat/users');
            const users = await resp.json();
            addMemberSelect.innerHTML = '';
            const emptyOpt = document.createElement('option');
            emptyOpt.value = '';
            emptyOpt.textContent = '-- Select teammate --';
            addMemberSelect.appendChild(emptyOpt);
            users.forEach(u => {
                const opt = document.createElement('option');
                opt.value = u.username;
                opt.textContent = u.username;
                addMemberSelect.appendChild(opt);
            });
        } catch (e) {
            console.warn('Failed to populate member dropdown', e);
        }
    }

    addMemberBtn && addMemberBtn.addEventListener('click', function() {
        const selected = addMemberSelect ? addMemberSelect.value : '';
        if (!selected || !currentGroup) {
            alert('Select a teammate and join a group first.');
            return;
        }
        // Emit socket event to add user to group
        socket.emit('add_user_to_group', { group: currentGroup, username: selected });
        // Refresh authoritative members list from server (after a brief delay to allow server write)
        setTimeout(() => refreshGroupMembers(currentGroup), 200);
    });

    // Fetch authoritative members from server for a group and update the UI
    async function refreshGroupMembers(group) {
        if (!group) return;
        try {
            const resp = await fetch(`/chat/group-members?group=${encodeURIComponent(group)}`);
            if (!resp.ok) return;
            const data = await resp.json();
            const members = data.members || [];
            groupMembersList.innerHTML = '';
            // Ensure current user appears as '(you)'
            members.forEach(m => {
                const li = document.createElement('li');
                li.textContent = m === currentUsername ? `${m} (you)` : m;
                groupMembersList.appendChild(li);
            });
        } catch (e) {
            console.warn('Failed to refresh group members', e);
        }
    }

    // --- New: 'Chats I'm in' list management (loads from /chat/state and updates) ---
    const myChatsList = document.getElementById('myChatsList');

    async function loadMyChatsState() {
        try {
            const resp = await fetch('/chat/state');
            const data = await resp.json();
            const joined = data.joinedGroups || [];
            myChatsList.innerHTML = '';
            // Add group entries
            joined.forEach(g => {
                const li = document.createElement('li');
                li.className = 'my-chat-item';
                li.style.cursor = 'pointer';
                li.textContent = `Group: ${g}`;
                li.onclick = () => {
                    // Switch to groups tab and join that group locally
                    const groupsTab = document.getElementById('groups-tab');
                    if (groupsTab) groupsTab.click();
                    groupNameInput.value = g;
                    joinGroupBtn && joinGroupBtn.click();
                };
                myChatsList.appendChild(li);
            });
            // Add DMs list entry if lastDmUser present
            if (data.lastDmUser) {
                const li = document.createElement('li');
                li.className = 'my-chat-item';
                li.style.cursor = 'pointer';
                li.textContent = `DM: ${data.lastDmUser}`;
                li.onclick = () => {
                    const dmTab = document.getElementById('dm-tab');
                    if (dmTab) dmTab.click();
                    const dmSelect = document.getElementById('dmUserSelect');
                    if (dmSelect && Array.from(dmSelect.options).some(o => o.value === data.lastDmUser)) {
                        dmSelect.value = data.lastDmUser;
                        loadDmHistory();
                    }
                };
                myChatsList.appendChild(li);
            }
        } catch (e) {
            console.warn('Failed to load chat state', e);
        }
    }

    async function saveJoinedGroupToState(group) {
        try {
            const resp = await fetch('/chat/state');
            const data = await resp.json();
            data.joinedGroups = data.joinedGroups || [];
            if (!data.joinedGroups.includes(group)) {
                data.joinedGroups.push(group);
            }
            data.currentGroup = group;
            await fetch('/chat/state', { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify(data) });
            loadMyChatsState();
        } catch (e) {
            console.warn('Failed to save chat state', e);
        }
    }

    async function removeJoinedGroupFromState(group) {
        try {
            const resp = await fetch('/chat/state');
            const data = await resp.json();
            data.joinedGroups = (data.joinedGroups || []).filter(g => g !== group);
            if (data.currentGroup === group) data.currentGroup = '';
            await fetch('/chat/state', { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify(data) });
            loadMyChatsState();
        } catch (e) {
            console.warn('Failed to remove joined group from state', e);
        }
    }

    // Integrate with join/leave buttons to persist membership
    const originalJoinHandler = joinGroupBtn && joinGroupBtn.onclick;
    joinGroupBtn && joinGroupBtn.addEventListener('click', function() {
        const group = (groupNameInput && groupNameInput.value.trim()) || 'main';
        if (!group) return;
        saveJoinedGroupToState(group);
    });

    leaveGroupBtn && leaveGroupBtn.addEventListener('click', function() {
        if (!currentGroup) return;
        removeJoinedGroupFromState(currentGroup);
    });

    // Initial population
    populateMemberDropdown();
    loadMyChatsState();

    // Handle incoming group messages
    socket.on('group_message', function(msg) {
        if (!msg || !msg.group) return;
        if (msg.group !== currentGroup) return;
        const div = document.createElement('div');
        div.className = 'mb-2 chat-message';
        div.setAttribute('data-message-id', msg.id || '');
        div.setAttribute('data-sender', msg.sender);
        div.innerHTML = `
            <strong>${msg.sender === currentUsername ? 'You' : msg.sender}:</strong>
            <span class="message-text">${msg.text}</span>
            ${((msg.reactions_summary && msg.reactions_summary.length > 0) ? msg.reactions_summary : (msg.reactions || [])).length > 0 ? `<span class="message-reactions">${((msg.reactions_summary && msg.reactions_summary.length > 0) ? msg.reactions_summary : (msg.reactions || [])).map(r => (r.count != null ? `${r.emoji} ${r.count}` : `${r.emoji}`)).join(' ')}</span>` : ''}
        `;
        groupChatContainer.appendChild(div);
        groupChatContainer.scrollTop = groupChatContainer.scrollHeight;
    });

    // --- Assistant Chat History ---
    function loadAssistantHistory() {
        const assistantChatContainer = document.getElementById('assistantChatContainer');
        assistantChatContainer.innerHTML = '';
        fetch('/assistant/history')
            .then(r => r.json())
            .then(data => {
                (data.history || []).forEach(msg => {
                    const div = document.createElement('div');
                    div.className = 'mb-2 chat-message';
                    div.setAttribute('data-message-id', msg.id || '');
                    div.setAttribute('data-sender', msg.sender);
                    div.innerHTML = `
                        <strong>${msg.sender === 'assistant' ? 'Assistant' : 'You'}:</strong> 
                        <span class="message-text">${msg.text}</span>
                        ${msg.reactions && msg.reactions.length > 0 ? 
                            `<span class="message-reactions">${((msg.reactions_summary && msg.reactions_summary.length > 0) ? msg.reactions_summary : (msg.reactions || [])).map(r => (r.count != null ? `${r.emoji} ${r.count}` : `${r.emoji}`)).join(' ')}</span>` 
                            : ''}
                        ${msg.edited ? '<span class="text-muted ms-1">(edited)</span>' : ''}
                    `;
                    assistantChatContainer.appendChild(div);
                });
                assistantChatContainer.scrollTop = assistantChatContainer.scrollHeight;
            });
    }

    // --- DM Chat History ---
    function loadDmHistory() {
        const dmUserSelect = document.getElementById('dmUserSelect');
        const dmChatContainer = document.getElementById('dmChatContainer');
        dmChatContainer.innerHTML = '';
        const recipient = dmUserSelect ? dmUserSelect.value : null;
        if (!recipient) return;
        fetch(`/chat/dm-history?user=${encodeURIComponent(recipient)}`)
            .then(r => r.json())
            .then(data => {
                (data.history || []).forEach(msg => {
                    const div = document.createElement('div');
                    div.className = 'mb-2 chat-message';
                    div.setAttribute('data-message-id', msg.id || '');
                    div.setAttribute('data-sender', msg.sender);
                    div.innerHTML = `
                        <strong>${msg.sender === currentUsername ? 'You' : msg.sender}:</strong> 
                        <span class="message-text">${msg.text}</span>
                        ${msg.reactions && msg.reactions.length > 0 ? 
                            `<span class="message-reactions">${((msg.reactions_summary && msg.reactions_summary.length > 0) ? msg.reactions_summary : (msg.reactions || [])).map(r => (r.count != null ? `${r.emoji} ${r.count}` : `${r.emoji}`)).join(' ')}</span>` 
                            : ''}
                        ${msg.edited ? '<span class="text-muted ms-1">(edited)</span>' : ''}
                    `;
                    dmChatContainer.appendChild(div);
                });
                dmChatContainer.scrollTop = dmChatContainer.scrollHeight;
            });
    }

    // Listen for real-time DM messages
    socket.on('dm_message', function(msg) {
        const dmUserSelect = document.getElementById('dmUserSelect');
        if (!dmUserSelect) return;
        // Only show if the message is for the current DM chat
        const selectedUser = dmUserSelect.value;
        if (
            (msg.sender === currentUsername && msg.recipient === selectedUser) ||
            (msg.sender === selectedUser && msg.recipient === currentUsername)
        ) {
            // Append the message to the DM chat container
            const dmChatContainer = document.getElementById('dmChatContainer');
            const div = document.createElement('div');
            div.className = 'mb-2 chat-message';
            div.setAttribute('data-message-id', msg.id || '');
            div.setAttribute('data-sender', msg.sender);
            div.innerHTML = `
                <strong>${msg.sender === currentUsername ? 'You' : msg.sender}:</strong> 
                <span class="message-text">${msg.text}</span>
                ${msg.reactions && msg.reactions.length > 0 ? 
                    `<span class="message-reactions">${((msg.reactions_summary && msg.reactions_summary.length > 0) ? msg.reactions_summary : (msg.reactions || [])).map(r => (r.count != null ? `${r.emoji} ${r.count}` : `${r.emoji}`)).join(' ')}</span>` 
                    : ''}
            `;
            dmChatContainer.appendChild(div);
            dmChatContainer.scrollTop = dmChatContainer.scrollHeight;
        }
    });

    // Group messaging disabled on this deployment; all related UI and socket handlers removed.
    // Assistant tab logic: send message to /assistant/ask and display response
    const assistantSendBtn = document.getElementById('assistantSendBtn');
    const assistantChatInput = document.getElementById('assistantChatInput');
    const assistantChatContainer = document.getElementById('assistantChatContainer');
    const assistantClearBtn = document.getElementById('assistantClearBtn');
    if (assistantSendBtn) {
        assistantSendBtn.addEventListener('click', async function() {
            const question = assistantChatInput.value.trim();
            if (!question) return;
            // Show user message
            const userDiv = document.createElement('div');
            userDiv.className = 'mb-2 chat-message';
            userDiv.setAttribute('data-sender', currentUsername);
            userDiv.innerHTML = `<strong>You:</strong> <span class="message-text">${question}</span>`;
            assistantChatContainer.appendChild(userDiv);
            assistantChatInput.value = '';
            assistantChatContainer.scrollTop = assistantChatContainer.scrollHeight;
            // Send to backend
            const response = await fetch('/assistant/ask', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ question })
            });
            const data = await response.json();
            const botDiv = document.createElement('div');
            botDiv.className = 'mb-2 chat-message';
            botDiv.setAttribute('data-sender', 'assistant');
            botDiv.innerHTML = `<strong>Assistant:</strong> <span class="message-text">${data.text || data.message || 'No response.'}</span>`;
            assistantChatContainer.appendChild(botDiv);
            assistantChatContainer.scrollTop = assistantChatContainer.scrollHeight;
        });
        assistantChatInput.addEventListener('keypress', function(e) {
            if (e.key === 'Enter') assistantSendBtn.click();
        });
    }
    if (assistantClearBtn) {
        assistantClearBtn.addEventListener('click', async function() {
            if (!confirm('Clear all assistant chat history?')) return;
            assistantChatContainer.innerHTML = '';
            const resp = await fetch('/assistant/clear-assistant-history', { method: 'POST' });
            const data = await resp.json();
            if (data.success) {
                // Add a small delay to ensure backend writes are complete
                setTimeout(() => {
                    loadAssistantHistory();
                }, 200);
            } else {
                alert('Failed to clear assistant history.');
            }
        });
    }
    // DM chat logic: send message to /chat/dm and display response
    const dmSendBtn = document.getElementById('dmSendBtn');
    const dmChatInput = document.getElementById('dmChatInput');
    const dmChatContainer = document.getElementById('dmChatContainer');
    if (dmSendBtn) {
        dmSendBtn.addEventListener('click', async function() {
            const dmUserSelect = document.getElementById('dmUserSelect');
            const recipient = dmUserSelect ? dmUserSelect.value : null;
            const message = dmChatInput.value.trim();
            if (!recipient || !message) return;
                // Disable the send button while the request is in-flight to avoid duplicates
                dmSendBtn.disabled = true;
                try {
                    const response = await fetch('/chat/dm', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({ recipient, message })
                    });
                    if (!response.ok) {
                        console.warn('Failed to send DM', response.status);
                    }
                    // Clear the input and reload authoritative history from the server.
                    // We avoid appending the message locally here to prevent duplication
                    // when loadDmHistory re-renders the full history.
                    dmChatInput.value = '';
                    // Give the server/socket a small moment to broadcast, then reload
                    setTimeout(() => loadDmHistory(), 150);
                } catch (e) {
                    console.error('Error sending DM', e);
                } finally {
                    dmSendBtn.disabled = false;
                }
        });
        dmChatInput.addEventListener('keypress', function(e) {
            if (e.key === 'Enter' && !e.shiftKey) {
                e.preventDefault();
                dmSendBtn.click();
            }
        });
    }
    
    /* Auto-scroll helpers: attempt to scroll to the last-read message if available
       Priority: template variable `last_read_message_id` (server), then URL param `last_read`,
       then URL `focus` JSON object (from unread link), else scroll to bottom. */
    function getLastReadMessageIdFromUrl() {
        try {
            const params = new URLSearchParams(window.location.search);
            const lr = params.get('last_read');
            if (lr) return lr;
            const focus = params.get('focus');
            if (focus) {
                try {
                    const obj = JSON.parse(decodeURIComponent(focus));
                    if (obj && obj.last_read) return obj.last_read;
                    if (obj && obj.id) return obj.id;
                } catch (e) {
                    // ignore
                }
            }
        } catch (e) {}
        return null;
    }

    function scrollToMessageOrBottom(container, messageId) {
        if (!container) return;
        if (messageId) {
            const el = container.querySelector(`[data-message-id="${messageId}"]`);
            if (el) {
                // Scroll so the target is visible with a small offset
                const offset = 8;
                const top = el.offsetTop - offset;
                try {
                    container.scrollTo({ top: top, behavior: 'auto' });
                } catch (e) {
                    container.scrollTop = top;
                }
                return true;
            }
        }
        // fallback to bottom
        try { container.scrollTo({ top: container.scrollHeight, behavior: 'auto' }); } catch(e) { container.scrollTop = container.scrollHeight; }
        return false;
    }

    // Try a server-provided last read id first (template variable), then URL
    let serverLastReadId = null;
    try {
        const dmEl = document.getElementById('dmChatContainer');
        if (dmEl) serverLastReadId = dmEl.getAttribute('data-last-read') || null;
    } catch (e) { serverLastReadId = null; }

    // Hook into DM history loader to attempt smart scroll after rendering
    const originalLoadDmHistory = loadDmHistory;
    loadDmHistory = function() {
        const dmChatContainerLocal = document.getElementById('dmChatContainer');
        // Call original which populates container and scrolls to bottom
        const promise = originalLoadDmHistory.apply(this, arguments);
        // After a short delay to ensure DOM updates, try to scroll to last-read
        setTimeout(() => {
            const urlLastRead = getLastReadMessageIdFromUrl();
            const chosen = serverLastReadId || urlLastRead || null;
            // Try to scroll to chosen id; if not found, leave at bottom
            scrollToMessageOrBottom(dmChatContainerLocal, chosen);
        }, 250);
        return promise;
    };
  })();
});
</script>
{% endblock %} 