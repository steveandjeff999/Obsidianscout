{% extends 'base.html' %}
{% block title %}Strategy Drawing{% endblock %}
{% block heading %}Strategy Drawing{% endblock %}

{% block content %}
<div class="row mb-3">
    <div class="col-md-6">
        <form id="match-select-form" class="d-flex align-items-center">
            <label for="event-select" class="me-2 fw-bold">Event:</label>
            <select id="event-select" class="form-select me-3 w-280" name="event_id">
                <option value="">-- Select Event --</option>
                {% for ev in events|dedupe_events %}
                    <option value="{{ ev.id }}" data-event-code="{{ ev.code|upper if ev.code else '' }}" {% if selected_event and selected_event.id == ev.id %}selected{% endif %}>{{ ev.year }} - {{ ev.name }}{% if ev.is_alliance %} (Alliance){% endif %}</option>
                {% endfor %}
            </select>

            <label for="match-select" class="me-2 fw-bold">Select Match:</label>
            <select id="match-select" class="form-select w-200" name="match_id">
                <option value="">-- Select Match --</option>
                {% for match in matches %}
                    <option value="{{ match.id }}">{{ match.match_type|capitalize }} {{ match.match_number }}</option>
                {% endfor %}
            </select>
        </form>
    </div>
    <div class="col-md-6 text-end">
        <label for="color-picker" class="me-2 fw-bold">Color:</label>
        <input type="color" id="color-picker" value="#ff0000">
        <label for="bg-upload" class="ms-3 btn btn-outline-secondary btn-sm mb-0">Upload Background</label>
        <input type="file" id="bg-upload" accept="image/*" class="d-none">
    </div>
</div>
<div class="position-relative u-max-w-900 mx-auto">
    <img id="field-image" src="{{ url_for('static', filename='Feild-2025.png') }}" alt="Field" class="img-no-drag" draggable="false">
    <canvas id="drawing-canvas" class="canvas-overlay"></canvas>
</div>
<div class="mt-3 text-center">
    <button id="clear-canvas" class="btn btn-warning">Clear Drawing</button>
    <button id="save-drawing" class="btn btn-primary ms-2">Save Drawing</button>
    <span id="save-status" class="ms-3 text-muted">Drawings are synced in real time and can be saved for later.</span>
</div>
<script src="{{ url_for('static', filename='js/vendor/socket.io.min.js') }}"></script>
<script>
const fieldImage = document.getElementById('field-image');
const canvas = document.getElementById('drawing-canvas');
const ctx = canvas.getContext('2d');
const colorPicker = document.getElementById('color-picker');
const clearBtn = document.getElementById('clear-canvas');
const matchSelect = document.getElementById('match-select');
const eventSelect = document.getElementById('event-select');
const bgUpload = document.getElementById('bg-upload');

let drawing = false;
let lastX = 0, lastY = 0;
let currentColor = colorPicker.value;
let currentMatchId = matchSelect.value;
let socket = io();
let drawingData = [];
let defaultFieldImage = "{{ url_for('static', filename='Feild-2025.png') }}";

function resizeCanvas() {
    // Size the canvas to match the displayed image size
    canvas.width = fieldImage.clientWidth;
    canvas.height = fieldImage.clientHeight;
    // Ensure the underlying image doesn't capture pointer events so the canvas receives them
    try {
        fieldImage.style.pointerEvents = 'none';
    } catch (e) {
        // ignore if not supported
    }
    redraw();
}

function redraw() {
    // Use the displayed size (bounding rect) so drawing matches pointer coordinates
    const rect = canvas.getBoundingClientRect();
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    for (const line of drawingData) {
        ctx.strokeStyle = line.color;
        ctx.lineWidth = 3;
        ctx.beginPath();
        ctx.moveTo(line.points[0].x * rect.width, line.points[0].y * rect.height);
        for (let i = 1; i < line.points.length; i++) {
            ctx.lineTo(line.points[i].x * rect.width, line.points[i].y * rect.height);
        }
        ctx.stroke();
    }
}

function startDraw(e) {
    // prevent touch from scrolling while drawing
    if (e.type && e.type.startsWith('touch')) e.preventDefault();
    drawing = true;
    const {x, y} = getPos(e);
    lastX = x;
    lastY = y;
    drawingData.push({color: currentColor, points: [{x, y}]});
}

function draw(e) {
    if (!drawing) return;
    if (e.type && e.type.startsWith('touch')) e.preventDefault();
    const {x, y} = getPos(e);
    const line = drawingData[drawingData.length - 1];
    line.points.push({x, y});
    redraw();
    lastX = x;
    lastY = y;
}

function endDraw() {
    if (drawing) {
        drawing = false;
        sendDrawingUpdate();
    }
}

function getPos(e) {
    let rect = canvas.getBoundingClientRect();
    let clientX, clientY;
    if (e.touches && e.touches.length) {
        clientX = e.touches[0].clientX;
        clientY = e.touches[0].clientY;
    } else {
        clientX = e.clientX;
        clientY = e.clientY;
    }
    // Normalize using the displayed size so coordinates are fractions [0..1]
    const x = (clientX - rect.left) / rect.width;
    const y = (clientY - rect.top) / rect.height;
    return {x, y};
}

function sendDrawingUpdate() {
    if (currentMatchId) {
        // Emit via Socket.IO for real-time sync
        try {
            socket.emit('drawing_update', {match_id: currentMatchId, data: drawingData});
        } catch (e) {
            console.warn('Socket emit failed:', e);
        }
        // Also POST to server as a reliable fallback so drawings are persisted even if socket fails
        fetch(`/matches/api/strategy_drawing/${currentMatchId}`, {
            method: 'POST',
            headers: {'Content-Type': 'application/json'},
            body: JSON.stringify({data: drawingData})
        }).then(res => res.json()).then(resp => {
            if (!resp || resp.error) console.warn('Persistent save failed', resp);
        }).catch(err => console.warn('Persistent save error', err));
    }
}

function joinMatchRoom(matchId) {
    socket.emit('join_strategy_room', {match_id: matchId});
}

function loadDrawing(matchId) {
    fetch(`/matches/api/strategy_drawing/${matchId}`)
        .then(res => res.json())
        .then(data => {
            drawingData = data.data || [];
            redraw();
        });
}

function setFieldImage(src) {
    fieldImage.src = src;
}

// Change upload to global
bgUpload.addEventListener('change', function() {
    if (!bgUpload.files.length) return;
    const formData = new FormData();
    formData.append('background', bgUpload.files[0]);
    fetch(`/matches/api/strategy_background`, {
        method: 'POST',
        body: formData
    })
    .then(res => res.json())
    .then(data => {
        if (data.background_image) {
            setFieldImage(data.background_image);
        }
    });
});

// Always use the global background if it exists
function checkGlobalBackground() {
    // Prefer team-specific background if available
    {% if current_user.is_authenticated and current_user.scouting_team_number %}
    const teamBg = `/matches/strategy_backgrounds/{{ current_user.scouting_team_number }}/default_bg.png`;
    fetch(teamBg)
        .then(res => {
            if (res.ok) {
                setFieldImage(teamBg);
            } else {
                // Try global default
                fetch('/matches/strategy_backgrounds/default_bg.png')
                    .then(res2 => {
                        if (res2.ok) {
                            setFieldImage('/matches/strategy_backgrounds/default_bg.png');
                        } else {
                            setFieldImage(defaultFieldImage);
                        }
                    });
            }
        });
    {% else %}
    fetch('/matches/strategy_backgrounds/default_bg.png')
        .then(res => {
            if (res.ok) {
                setFieldImage('/matches/strategy_backgrounds/default_bg.png');
            } else {
                setFieldImage(defaultFieldImage);
            }
        });
    {% endif %}
}

// Listen for real-time background image updates (global)
socket.on('background_image_update', data => {
    if (data.background_image) {
        setFieldImage(data.background_image);
    }
});

matchSelect.addEventListener('change', () => {
    currentMatchId = matchSelect.value;
    if (currentMatchId) {
        joinMatchRoom(currentMatchId);
        loadDrawing(currentMatchId);
        checkGlobalBackground();
    } else {
        drawingData = [];
        setFieldImage(defaultFieldImage);
        redraw();
    }
});

// When the event changes, reload the page with the selected event_id so server filters matches
if (eventSelect) {
    eventSelect.addEventListener('change', () => {
        const ev = eventSelect.value;
        const params = new URLSearchParams(window.location.search);
        if (ev) {
            params.set('event_id', ev);
        } else {
            params.delete('event_id');
        }
        // Preserve other query params if needed and reload
        window.location.search = params.toString();
    });
}

canvas.addEventListener('mousedown', startDraw);
canvas.addEventListener('mousemove', draw);
canvas.addEventListener('mouseup', endDraw);
canvas.addEventListener('mouseleave', endDraw);
canvas.addEventListener('touchstart', startDraw);
canvas.addEventListener('touchmove', draw);
canvas.addEventListener('touchend', endDraw);

window.addEventListener('resize', resizeCanvas);
fieldImage.onload = resizeCanvas;
fieldImage.addEventListener('dragstart', e => e.preventDefault());

// Socket.IO events
socket.on('drawing_data', data => {
    if (data.match_id == currentMatchId && data.data) {
        drawingData = data.data;
        redraw();
    }
});

// Initialize
if (matchSelect.value) {
    currentMatchId = matchSelect.value;
    joinMatchRoom(currentMatchId);
    loadDrawing(currentMatchId);
    checkGlobalBackground();
}

// Only resize the canvas after the image is loaded (or immediately if already loaded)
if (fieldImage.complete && fieldImage.naturalWidth !== 0) {
    resizeCanvas();
} else {
    fieldImage.onload = resizeCanvas;
}

clearBtn.addEventListener('click', () => {
    drawingData = [];
    redraw();
    sendDrawingUpdate();
});

// Keep currentColor in sync with the color picker
colorPicker.addEventListener('input', (e) => {
    currentColor = e.target.value;
});

// Manual save button: persist drawing to server and show status
const saveBtn = document.getElementById('save-drawing');
const saveStatus = document.getElementById('save-status');
async function saveDrawingToServer() {
    if (!currentMatchId) {
        saveStatus.textContent = 'Select a match before saving.';
        return;
    }
    saveStatus.textContent = 'Saving...';
    saveBtn.disabled = true;
    try {
        const resp = await fetch(`/matches/api/strategy_drawing/${currentMatchId}`, {
            method: 'POST',
            headers: {'Content-Type': 'application/json'},
            body: JSON.stringify({data: drawingData})
        });
        const json = await resp.json();
        if (resp.ok && json && json.success) {
            saveStatus.textContent = 'Saved.';
            setTimeout(() => { saveStatus.textContent = 'Saved.'; }, 1000);
        } else {
            saveStatus.textContent = json && json.error ? `Save failed: ${json.error}` : 'Save failed';
        }
    } catch (e) {
        console.warn('Save error', e);
        saveStatus.textContent = 'Save error (see console)';
    } finally {
        saveBtn.disabled = false;
        setTimeout(() => { if (saveStatus.textContent.startsWith('Saved')) saveStatus.textContent = 'Drawings are synced in real time and can be saved for later.'; }, 3000);
    }
}

saveBtn.addEventListener('click', saveDrawingToServer);
</script>
{% endblock %} 