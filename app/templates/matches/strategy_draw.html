{% extends 'base.html' %}
{% block title %}Strategy Drawing{% endblock %}
{% block heading %}Strategy Drawing{% endblock %}

{% block content %}
<div class="row mb-3">
    <div class="col-md-6">
        <form id="match-select-form" class="d-flex align-items-center">
            <label for="event-select" class="me-2 fw-bold">Event:</label>
            <select id="event-select" class="form-select me-3 w-280" name="event_id">
                <option value="">-- Select Event --</option>
                {% for ev in events|dedupe_events %}
                    <option value="{{ ev.id }}" data-event-code="{{ ev.code|upper if ev.code else '' }}" {% if selected_event and selected_event.id == ev.id %}selected{% endif %}>{{ ev.year }} - {{ ev.name }}{% if ev.is_alliance %} (Alliance){% endif %}</option>
                {% endfor %}
            </select>

            <label for="match-select" class="me-2 fw-bold">Select Match:</label>
            <select id="match-select" class="form-select w-200" name="match_id">
                <option value="">-- Select Match --</option>
                {% for match in matches %}
                    <option value="{{ match.id }}">{{ match.match_type|capitalize }} {{ match.match_number }}</option>
                {% endfor %}
            </select>
        </form>
    </div>
    <div class="col-md-6 text-end">
        <label for="color-picker" class="me-2 fw-bold">Color:</label>
        <input type="color" id="color-picker" value="#ff0000">
        <button id="preset-red" class="btn btn-sm ms-2 preset-color" title="Preset Red" aria-label="Preset Red" style="background:#ff0000;border:1px solid #b30000"></button>
        <button id="preset-blue" class="btn btn-sm ms-1 preset-color" title="Preset Blue" aria-label="Preset Blue" style="background:#0000ff;border:1px solid #00008b"></button>
        <label id="text-tool" class="ms-3 btn btn-outline-secondary btn-sm mb-0" role="button" title="Text Tool">Text</label>
        <label id="select-tool" class="ms-1 btn btn-outline-secondary btn-sm mb-0" role="button" title="Select Tool">Select</label>
        <label id="eraser-tool" class="ms-1 btn btn-outline-secondary btn-sm mb-0" role="button" title="Eraser">Eraser</label>
        <input id="eraser-size" type="range" min="6" max="60" value="20" class="ms-2" title="Eraser size" style="vertical-align:middle">
        <label for="bg-upload" class="ms-2 btn btn-outline-secondary btn-sm mb-0">Upload Background</label>
        <input type="file" id="bg-upload" accept="image/*" class="d-none">
    </div>
</div>
<div class="position-relative u-max-w-900 mx-auto">
    <img id="field-image" src="{{ url_for('static', filename='Feild-2025.png') }}" alt="Field" class="img-no-drag" draggable="false">
    <canvas id="drawing-canvas" class="canvas-overlay"></canvas>
    <input type="text" id="text-input-overlay" class="d-none" maxlength="200" aria-label="Canvas text input">
    <button id="delete-text" class="d-none" aria-label="Delete text">âœ•</button>
</div>
<div class="mt-3 text-center">
    <button id="clear-canvas" class="btn btn-warning">Clear Drawing</button>
    <button id="undo-drawing" class="btn btn-secondary ms-2">Undo</button>
    <button id="redo-drawing" class="btn btn-secondary ms-1">Redo</button>
    <button id="save-drawing" class="btn btn-primary ms-2">Save Drawing</button>
    <span id="save-status" class="ms-3 text-muted">Drawings are synced in real time and can be saved for later.</span>
</div>
<div class="mt-2 text-center">
    <small class="text-muted">ðŸ’¡ Tip: Tap text to edit; on mobile, use the <strong>Select</strong> tool and the on-screen <strong>Delete</strong> button to remove text (or clear input and press Delete/Backspace)</small>
</div>
<style>
#text-input-overlay {
    position: absolute;
    z-index: 1000;
    padding: 4px 8px;
    border: 2px solid #007bff;
    border-radius: 4px;
    background: white;
    font-size: 16px;
    min-width: 100px;
    box-shadow: 0 2px 8px rgba(0,0,0,0.2);
}
#delete-text {
    position: absolute;
    z-index: 1001;
    border: none;
    background: #dc3545;
    color: white;
    border-radius: 50%;
    width: 32px;
    height: 32px;
    display: inline-flex;
    align-items: center;
    justify-content: center;
    font-size: 16px;
    box-shadow: 0 2px 6px rgba(0,0,0,0.2);
}
#delete-text.d-none { display: none; }
.preset-color {
    width: 26px;
    height: 26px;
    padding: 0;
    border-radius: 4px;
    box-shadow: none;
}
.preset-color.active {
    outline: 3px solid rgba(0,0,0,0.12);
    transform: translateY(-1px);
}
</style>
<script src="{{ url_for('static', filename='js/vendor/socket.io.min.js') }}"></script>
<script>
const fieldImage = document.getElementById('field-image');
const canvas = document.getElementById('drawing-canvas');
const ctx = canvas.getContext('2d');
const colorPicker = document.getElementById('color-picker');
const clearBtn = document.getElementById('clear-canvas');
const matchSelect = document.getElementById('match-select');
const eventSelect = document.getElementById('event-select');
const bgUpload = document.getElementById('bg-upload');

let drawing = false;
let lastX = 0, lastY = 0;
let currentColor = colorPicker.value;
let currentMatchId = matchSelect.value;
let socket = io();
let drawingData = [];
// Undo/Redo stacks: store snapshots of drawingData before each user action
let undoStack = [];
let redoStack = [];
const UNDO_LIMIT = 30;
let drawingLastUpdated = null; // ISO timestamp of the drawing on server (used to detect updates) 
let defaultFieldImage = "{{ url_for('static', filename='Feild-2025.png') }}";
let hoveredTextId = null;
let eraserSize = parseInt(document.getElementById('eraser-size')?.value || 20, 10);

function resizeCanvas() {
    // Size the canvas to match the displayed image size
    canvas.width = fieldImage.clientWidth;
    canvas.height = fieldImage.clientHeight;
    // Ensure the underlying image doesn't capture pointer events so the canvas receives them
    try {
        fieldImage.style.pointerEvents = 'none';
    } catch (e) {
        // ignore if not supported
    }
    redraw();
}

function redraw() {
    // Use the displayed size (bounding rect) so drawing matches pointer coordinates
    const rect = canvas.getBoundingClientRect();
    ctx.clearRect(0, 0, canvas.width, canvas.height);

    // Walk items in order and render each. Erasers are drawn in-place so they only
    // affect drawings that occurred earlier in the history, which allows new
    // strokes to be placed on top of erased regions.
    for (const item of drawingData) {
        if (!item) continue;

        if (item.type === 'erase') {
            // immediate application of erase stroke
            ctx.save();
            ctx.globalCompositeOperation = 'destination-out';
            ctx.lineJoin = 'round';
            ctx.lineCap = 'round';
            const size = item.size || eraserSize || 20;
            ctx.lineWidth = size;
            if (item.points && item.points.length) {
                ctx.beginPath();
                ctx.moveTo(item.points[0].x * rect.width, item.points[0].y * rect.height);
                for (let i = 1; i < item.points.length; i++) {
                    ctx.lineTo(item.points[i].x * rect.width, item.points[i].y * rect.height);
                }
                ctx.stroke();
                // draw circles to avoid gaps
                for (const p of item.points) {
                    ctx.beginPath();
                    ctx.arc(p.x * rect.width, p.y * rect.height, size / 2, 0, Math.PI * 2);
                    ctx.fill();
                }
            }
            ctx.restore();
            continue;
        }

        if (item.type === 'text') {
            ctx.fillStyle = item.color || '#000';
            ctx.textBaseline = 'middle';
            const baseFont = item.fontSize || 24;
            const fontSize = Math.max(10, Math.round(baseFont * rect.width / 900));
            ctx.font = `${fontSize}px sans-serif`;

            // Draw highlight if this text is hovered
            if (hoveredTextId === item.id) {
                ctx.save();
                const metrics = ctx.measureText(item.text);
                const textX = item.x * rect.width;
                const textY = item.y * rect.height;
                const padding = 5;
                ctx.fillStyle = 'rgba(135, 206, 250, 0.3)'; // Light blue highlight
                ctx.fillRect(textX - padding, textY - fontSize / 2 - padding, 
                           metrics.width + padding * 2, fontSize + padding * 2);
                ctx.restore();
                ctx.fillStyle = item.color || '#000';
            }

            // Simple single-line text rendering for now
            ctx.fillText(item.text, item.x * rect.width, item.y * rect.height);
        } else if (item.points && item.points.length) {
            ctx.strokeStyle = item.color;
            ctx.lineWidth = 3;
            ctx.beginPath();
            ctx.moveTo(item.points[0].x * rect.width, item.points[0].y * rect.height);
            for (let i = 1; i < item.points.length; i++) {
                ctx.lineTo(item.points[i].x * rect.width, item.points[i].y * rect.height);
            }
            ctx.stroke();
        }
    }
}

function pushUndoSnapshot() {
    try {
        const snap = JSON.parse(JSON.stringify(drawingData || []));
        undoStack.push(snap);
        if (undoStack.length > UNDO_LIMIT) undoStack.shift();
        // New user action invalidates the redo history
        redoStack = [];
    } catch (e) { /* ignore snapshot failures */ }
}

function startDraw(e) {
    // Only draw when in draw or eraser mode
    if (toolMode && toolMode !== 'draw' && toolMode !== 'eraser') return;
    // prevent touch from scrolling while drawing
    if (e.type && e.type.startsWith('touch')) e.preventDefault();
    drawing = true;
    const {x, y} = getPos(e);
    lastX = x;
    lastY = y;
    // Snapshot before starting a new stroke (for undo)
    pushUndoSnapshot();
    if (toolMode === 'eraser') {
        drawingData.push({type: 'erase', size: eraserSize, points: [{x, y}]});
    } else {
        drawingData.push({color: currentColor, points: [{x, y}]});
    }
}

function draw(e) {
    if (!drawing) return;
    if (e.type && e.type.startsWith('touch')) e.preventDefault();
    const {x, y} = getPos(e);
    const line = drawingData[drawingData.length - 1];
    if (line && line.points) line.points.push({x, y});
    redraw();
    lastX = x;
    lastY = y;
}

function endDraw() {
    if (drawing) {
        drawing = false;
        sendDrawingUpdate();
    }
}

function getPos(e) {
    let rect = canvas.getBoundingClientRect();
    let clientX, clientY;
    if (e.touches && e.touches.length) {
        clientX = e.touches[0].clientX;
        clientY = e.touches[0].clientY;
    } else {
        clientX = e.clientX;
        clientY = e.clientY;
    }
    // Normalize using the displayed size so coordinates are fractions [0..1]
    const x = (clientX - rect.left) / rect.width;
    const y = (clientY - rect.top) / rect.height;
    return {x, y};
}

function sendDrawingUpdate() {
    if (currentMatchId) {
        // Emit via Socket.IO for real-time sync
        try {
            socket.emit('drawing_update', {match_id: currentMatchId, data: drawingData});
        } catch (e) {
            console.warn('Socket emit failed:', e);
        }
        // Also POST to server as a reliable fallback so drawings are persisted even if socket fails
        fetch(`/matches/api/strategy_drawing/${currentMatchId}`, {
            method: 'POST',
            headers: {'Content-Type': 'application/json'},
            body: JSON.stringify({data: drawingData})
        }).then(res => res.json()).then(resp => {
            if (!resp || resp.error) console.warn('Persistent save failed', resp);
        }).catch(err => console.warn('Persistent save error', err));
    }
}

function joinMatchRoom(matchId) {
    socket.emit('join_strategy_room', {match_id: matchId});
}

function loadDrawing(matchId) {
    fetch(`/matches/api/strategy_drawing/${matchId}`)
        .then(res => res.json())
        .then(data => {
            // Update only if there's new content (or on first load)
            if (String(data.last_updated) !== String(drawingLastUpdated)) {
                const incoming = data.data || [];
                if (JSON.stringify(incoming) !== JSON.stringify(drawingData)) {
                    drawingData = incoming;
                    // Reset local undo/redo history when remote state replaces local
                    undoStack = [];
                    redoStack = [];
                }
                drawingLastUpdated = data.last_updated || null;
                redraw();
            }
        }).catch(err => { /* ignore transient errors */ });
}

function setFieldImage(src) {
    fieldImage.src = src;
}

// Change upload to global
bgUpload.addEventListener('change', function() {
    if (!bgUpload.files.length) return;
    const formData = new FormData();
    formData.append('background', bgUpload.files[0]);
    fetch(`/matches/api/strategy_background`, {
        method: 'POST',
        body: formData
    })
    .then(res => res.json())
    .then(data => {
        if (data.background_image) {
            setFieldImage(data.background_image);
        }
    });
});

// Text tool support
const textTool = document.getElementById('text-tool');
const textInput = document.getElementById('text-input-overlay');
let toolMode = 'draw';
let pendingTextPos = null;
let lastToolBeforeEdit = null;
let skipBlurCommit = false; // used to prevent blur from committing when delete is tapped
const selectTool = document.getElementById('select-tool');
const deleteBtn = document.getElementById('delete-text');

if (textTool) {
    textTool.addEventListener('click', (e) => {
        if (toolMode === 'text') {
            // deactivate
            toolMode = 'draw';
            textTool.classList.remove('btn-primary');
            textTool.classList.add('btn-outline-secondary');
        } else {
            toolMode = 'text';
            // deactivate select tool if active
            if (selectTool) { selectTool.classList.remove('btn-primary'); selectTool.classList.add('btn-outline-secondary'); }
                // deactivate eraser if active
                const et = document.getElementById('eraser-tool'); if (et) { et.classList.remove('btn-primary'); et.classList.add('btn-outline-secondary'); }
            textTool.classList.remove('btn-outline-secondary');
            textTool.classList.add('btn-primary');
        }
    });
}

if (selectTool) {
    selectTool.addEventListener('click', (e) => {
        if (toolMode === 'select') {
            toolMode = 'draw';
            selectTool.classList.remove('btn-primary');
            selectTool.classList.add('btn-outline-secondary');
        } else {
            toolMode = 'select';
            // deactivate text tool if active
            if (textTool) { textTool.classList.remove('btn-primary'); textTool.classList.add('btn-outline-secondary'); }
            // deactivate eraser if active
            const et2 = document.getElementById('eraser-tool'); if (et2) { et2.classList.remove('btn-primary'); et2.classList.add('btn-outline-secondary'); }
            selectTool.classList.remove('btn-outline-secondary');
            selectTool.classList.add('btn-primary');
        }
    });
}

function hideTextInput() {
    pendingTextPos = null;
    if (textInput) {
        textInput.classList.add('d-none');
        textInput.style.display = '';
        textInput.value = '';
    }
    if (deleteBtn) {
        deleteBtn.classList.add('d-none');
    }
    // Restore previous tool that was active before editing (if any)
    if (lastToolBeforeEdit === 'select') {
        toolMode = 'select';
        if (selectTool) { selectTool.classList.remove('btn-outline-secondary'); selectTool.classList.add('btn-primary'); }
        if (textTool) { textTool.classList.remove('btn-primary'); textTool.classList.add('btn-outline-secondary'); }
    } else {
        toolMode = 'draw';
        if (textTool) { textTool.classList.remove('btn-primary'); textTool.classList.add('btn-outline-secondary'); }
        if (selectTool) { selectTool.classList.remove('btn-primary'); selectTool.classList.add('btn-outline-secondary'); }
    }
    lastToolBeforeEdit = null;
}

function commitText() {
    if (!pendingTextPos || !textInput) return hideTextInput();
    const val = textInput.value.trim();
    if (val) {
        // Snapshot before mutating for undo
        pushUndoSnapshot();
        // Check if we're editing existing text
        if (pendingTextPos.editingId) {
            // Update existing text
            const textItem = drawingData.find(item => item.id === pendingTextPos.editingId);
            if (textItem) {
                textItem.text = val;
                textItem.color = currentColor;
            }
        } else {
            // Create new text
            drawingData.push({type: 'text', text: val, x: pendingTextPos.x, y: pendingTextPos.y, color: currentColor, fontSize: 24, id: Date.now()});
        }
        redraw();
        sendDrawingUpdate();
    }
    hideTextInput();
}

function cancelTextInput() {
    hideTextInput();
}

function handleCanvasClickForText(e) {
    if (toolMode !== 'text') {
        // Check if user clicked on existing text to edit it
        const {x, y} = getPos(e);
        const rect = canvas.getBoundingClientRect();
        const clickX = x * rect.width;
        const clickY = y * rect.height;
        
        // Find if we clicked on any text
        for (let i = drawingData.length - 1; i >= 0; i--) {
            const item = drawingData[i];
            if (item && item.type === 'text') {
                const baseFont = item.fontSize || 24;
                const fontSize = Math.max(10, Math.round(baseFont * rect.width / 900));
                ctx.font = `${fontSize}px sans-serif`;
                const metrics = ctx.measureText(item.text);
                const textX = item.x * rect.width;
                const textY = item.y * rect.height;
                
                // Check if click is within text bounds (with some padding)
                const padding = 10;
                if (clickX >= textX - padding && clickX <= textX + metrics.width + padding &&
                    clickY >= textY - fontSize / 2 - padding && clickY <= textY + fontSize / 2 + padding) {
                    // Found a text item - record where we came from and enter edit mode
                    lastToolBeforeEdit = toolMode;
                    toolMode = 'text';
                    textTool.classList.remove('btn-outline-secondary');
                    textTool.classList.add('btn-primary');
                    
                    if (textInput) {
                        textInput.style.left = textX + 'px';
                        textInput.style.top = textY + 'px';
                        textInput.style.transform = 'translate(-50%, -50%)';
                        textInput.classList.remove('d-none');
                        textInput.style.display = 'block';
                        textInput.value = item.text;
                        pendingTextPos = {x: item.x, y: item.y, editingId: item.id};
                        // Position and show delete button near input for easy mobile access
                        if (deleteBtn) {
                            deleteBtn.style.left = (textX + 20) + 'px';
                            deleteBtn.style.top = (textY - 20) + 'px';
                            deleteBtn.classList.remove('d-none');
                        }
                        setTimeout(() => textInput.focus(), 20);
                    }
                    e.preventDefault();
                    return;
                }
            }
        }
        return;
    }
    
    if (e.type && e.type.startsWith('touch')) e.preventDefault();
    const {x, y} = getPos(e);
    const rect = canvas.getBoundingClientRect();
    if (textInput) {
        textInput.style.left = (x * rect.width) + 'px';
        textInput.style.top = (y * rect.height) + 'px';
        textInput.style.transform = 'translate(-50%, -50%)';
        textInput.classList.remove('d-none');
        textInput.style.display = 'block';
        textInput.value = '';
        pendingTextPos = {x, y};
        if (deleteBtn) deleteBtn.classList.add('d-none');
        setTimeout(() => textInput.focus(), 20);
    }
}

if (textInput) {
    textInput.addEventListener('keydown', (e) => {
        if (e.key === 'Enter') { commitText(); }
        else if (e.key === 'Escape') { cancelTextInput(); }
        else if ((e.key === 'Delete' || e.key === 'Backspace') && textInput.value === '' && pendingTextPos && pendingTextPos.editingId) {
            // Delete the text item if input is empty and we're editing
            e.preventDefault();
            // snapshot for undo
            pushUndoSnapshot();
            drawingData = drawingData.filter(item => item.id !== pendingTextPos.editingId);
            redraw();
            sendDrawingUpdate();
            hideTextInput();
        }
    });
    textInput.addEventListener('blur', (e) => {
        // If a pointerdown on delete just occurred, skip committing on blur so delete can run first
        if (skipBlurCommit) {
            // Clear flag after short delay to avoid swallowing future blurs
            setTimeout(() => { skipBlurCommit = false; }, 0);
            return;
        }
        commitText();
    });
}

if (deleteBtn) {
    // Ensure deletion runs before blur handlers by listening to pointerdown/touchstart
    deleteBtn.addEventListener('pointerdown', (e) => {
        // Mark that blur should not commit (delete will run next)
        skipBlurCommit = true;
    });
    deleteBtn.addEventListener('click', (e) => {
        e.preventDefault();
        e.stopPropagation();
        if (pendingTextPos && pendingTextPos.editingId) {
            pushUndoSnapshot();
            drawingData = drawingData.filter(item => item.id !== pendingTextPos.editingId);
            redraw();
            sendDrawingUpdate();
        }
        // Reset flag in case blur occurs after
        skipBlurCommit = false;
        hideTextInput();
    });
}
// make canvas click handle text insertion
canvas.addEventListener('click', handleCanvasClickForText);

// Add cursor change when hovering over text
canvas.addEventListener('mousemove', (e) => {
    if (drawing) return; // Don't interfere while drawing
    
    const {x, y} = getPos(e);
    const rect = canvas.getBoundingClientRect();
    const clickX = x * rect.width;
    const clickY = y * rect.height;
    
    // Check if hovering over any text
    let hoveringText = false;
    let newHoveredId = null;
    for (let i = drawingData.length - 1; i >= 0; i--) {
        const item = drawingData[i];
        if (item && item.type === 'text') {
            const baseFont = item.fontSize || 24;
            const fontSize = Math.max(10, Math.round(baseFont * rect.width / 900));
            ctx.font = `${fontSize}px sans-serif`;
            const metrics = ctx.measureText(item.text);
            const textX = item.x * rect.width;
            const textY = item.y * rect.height;
            
            const padding = 10;
            if (clickX >= textX - padding && clickX <= textX + metrics.width + padding &&
                clickY >= textY - fontSize / 2 - padding && clickY <= textY + fontSize / 2 + padding) {
                hoveringText = true;
                newHoveredId = item.id;
                break;
            }
        }
    }
    
    // Update hover state and redraw if changed
    if (newHoveredId !== hoveredTextId) {
        hoveredTextId = newHoveredId;
        redraw();
    }
    
    canvas.style.cursor = hoveringText ? 'pointer' : 'crosshair';
});

// Always use the global background if it exists
function checkGlobalBackground() {
    // Prefer team-specific background if available
    {% if current_user.is_authenticated and current_user.scouting_team_number %}
    const teamBg = `/matches/strategy_backgrounds/{{ current_user.scouting_team_number }}/default_bg.png`;
    fetch(teamBg)
        .then(res => {
            if (res.ok) {
                setFieldImage(teamBg);
            } else {
                // Try global default
                fetch('/matches/strategy_backgrounds/default_bg.png')
                    .then(res2 => {
                        if (res2.ok) {
                            setFieldImage('/matches/strategy_backgrounds/default_bg.png');
                        } else {
                            setFieldImage(defaultFieldImage);
                        }
                    });
            }
        });
    {% else %}
    fetch('/matches/strategy_backgrounds/default_bg.png')
        .then(res => {
            if (res.ok) {
                setFieldImage('/matches/strategy_backgrounds/default_bg.png');
            } else {
                setFieldImage(defaultFieldImage);
            }
        });
    {% endif %}
}

// Listen for real-time background image updates (global)
socket.on('background_image_update', data => {
    if (data.background_image) {
        setFieldImage(data.background_image);
    }
});

matchSelect.addEventListener('change', () => {
    currentMatchId = matchSelect.value;
    if (currentMatchId) {
        joinMatchRoom(currentMatchId);
        loadDrawing(currentMatchId);
        checkGlobalBackground();
        startStrategyPolling(); // begin periodic checks for updates
    } else {
        drawingData = [];
        setFieldImage(defaultFieldImage);
        redraw();
    }
});

// When the event changes, reload the page with the selected event_id so server filters matches
if (eventSelect) {
    eventSelect.addEventListener('change', () => {
        const ev = eventSelect.value;
        const params = new URLSearchParams(window.location.search);
        if (ev) {
            params.set('event_id', ev);
        } else {
            params.delete('event_id');
        }
        // Preserve other query params if needed and reload
        window.location.search = params.toString();
    });
}

canvas.addEventListener('mousedown', startDraw);
canvas.addEventListener('mousemove', draw);
canvas.addEventListener('mouseup', endDraw);
canvas.addEventListener('mouseleave', endDraw);
canvas.addEventListener('touchstart', startDraw);
canvas.addEventListener('touchmove', draw);
canvas.addEventListener('touchend', endDraw);

window.addEventListener('resize', resizeCanvas);
fieldImage.onload = resizeCanvas;
fieldImage.addEventListener('dragstart', e => e.preventDefault());

// Socket.IO events
socket.on('drawing_data', data => {
    if (data.match_id == currentMatchId) {
        // Some emits may send null/empty - handle gracefully
        const incoming = data.data || [];
        // Only update if content actually changed; avoid clearing undo/redo when this is our own broadcast
        if (JSON.stringify(incoming) !== JSON.stringify(drawingData)) {
            drawingData = incoming;
            // Remote load replaces local state; clear undo/redo history to avoid incompatibility
            undoStack = [];
            redoStack = [];
            drawingLastUpdated = data.last_updated || null;
            redraw();
        } else {
            // Update timestamp even if content same
            drawingLastUpdated = data.last_updated || null;
        }
    }
});

// Poll server periodically to detect updates (covers multi-process / missing socket broadcasts)
let _strategy_poll_interval = null;
function startStrategyPolling() {
    if (_strategy_poll_interval) return;
    _strategy_poll_interval = setInterval(() => {
        if (!currentMatchId) return;
        // Lightweight check: compare last_updated timestamp
        fetch(`/matches/api/strategy_drawing/${currentMatchId}`)
            .then(res => res.json())
            .then(data => {
                    if (!data) return;
                    if (String(data.last_updated) !== String(drawingLastUpdated)) {
                        const incoming = data.data || [];
                        // Only replace state if content actually differs to avoid wiping local undo/redo
                        if (JSON.stringify(incoming) !== JSON.stringify(drawingData)) {
                            drawingData = incoming;
                            // Remote load replaces local state; clear undo/redo history to avoid incompatibility
                            undoStack = [];
                            redoStack = [];
                        }
                        drawingLastUpdated = data.last_updated || null;
                        redraw();
                    }
            }).catch(() => { /* ignore errors */ });
    }, 3000);
}
function stopStrategyPolling() {
    if (_strategy_poll_interval) { clearInterval(_strategy_poll_interval); _strategy_poll_interval = null; }
}

socket.on('connect', () => {
    console.debug('Strategy drawing socket connected');
    if (currentMatchId) {
        joinMatchRoom(currentMatchId); // ensure we're in the right room after reconnect
        loadDrawing(currentMatchId);   // fetch latest drawing on reconnect
    }
    // keep polling running to handle cross-process cases where broadcasts are missed
});

socket.on('disconnect', (reason) => {
    console.warn('Strategy drawing socket disconnected:', reason);
    // still keep polling running so updates arrive via REST
});

// Initialize - prefer current event's first match when present
if (matchSelect.value) {
    currentMatchId = matchSelect.value;
    joinMatchRoom(currentMatchId);
    loadDrawing(currentMatchId);
    checkGlobalBackground();
    startStrategyPolling();
} else if (eventSelect && eventSelect.value) {
    // Auto-select the first available match (skip the placeholder option)
    let firstMatchOpt = null;
    for (const opt of matchSelect.options) {
        if (opt.value) { firstMatchOpt = opt.value; break; }
    }
    if (firstMatchOpt) {
        matchSelect.value = firstMatchOpt;
        currentMatchId = matchSelect.value;
        joinMatchRoom(currentMatchId);
        loadDrawing(currentMatchId);
        checkGlobalBackground();
        startStrategyPolling();
    } else {
        // No matches for this event, still ensure background is set
        checkGlobalBackground();
    }
} else {
    // No event selected and no match chosen
    checkGlobalBackground();
}

// Only resize the canvas after the image is loaded (or immediately if already loaded)
if (fieldImage.complete && fieldImage.naturalWidth !== 0) {
    resizeCanvas();
} else {
    fieldImage.onload = resizeCanvas;
}

clearBtn.addEventListener('click', () => {
    // Snapshot before clearing so user can undo
    pushUndoSnapshot();
    drawingData = [];
    redraw();
    sendDrawingUpdate();
});

// Eraser tool and size handling
const eraserToolBtn = document.getElementById('eraser-tool');
const eraserSizeInput = document.getElementById('eraser-size');
if (eraserToolBtn) {
    eraserToolBtn.addEventListener('click', (e) => {
        if (toolMode === 'eraser') {
            toolMode = 'draw';
            eraserToolBtn.classList.remove('btn-primary');
            eraserToolBtn.classList.add('btn-outline-secondary');
        } else {
            toolMode = 'eraser';
            // deactivate other tools
            if (textTool) { textTool.classList.remove('btn-primary'); textTool.classList.add('btn-outline-secondary'); }
            if (selectTool) { selectTool.classList.remove('btn-primary'); selectTool.classList.add('btn-outline-secondary'); }
            eraserToolBtn.classList.remove('btn-outline-secondary');
            eraserToolBtn.classList.add('btn-primary');
        }
    });
}
if (eraserSizeInput) {
    eraserSizeInput.addEventListener('input', (e) => {
        eraserSize = parseInt(e.target.value || 20, 10);
    });
}

// Undo button
const undoBtn = document.getElementById('undo-drawing');
if (undoBtn) {
    undoBtn.addEventListener('click', (e) => {
        if (undoStack.length === 0) return;
        // Push current state to redo stack before undoing
        try { redoStack.push(JSON.parse(JSON.stringify(drawingData || []))); if (redoStack.length > UNDO_LIMIT) redoStack.shift(); } catch (e) {}
        const prev = undoStack.pop();
        if (prev) {
            drawingData = prev;
            redraw();
            sendDrawingUpdate();
        }
    });
}
// Redo button handling
const redoBtnEl = document.getElementById('redo-drawing');
if (redoBtnEl) {
    redoBtnEl.addEventListener('click', (e) => {
        if (redoStack.length === 0) return;
        // Push current state to undo stack so redo can be undone
        try { undoStack.push(JSON.parse(JSON.stringify(drawingData || []))); if (undoStack.length > UNDO_LIMIT) undoStack.shift(); } catch (e) {}
        const next = redoStack.pop();
        if (next) {
            drawingData = next;
            redraw();
            sendDrawingUpdate();
        }
    });
}

// Keep currentColor in sync with the color picker
colorPicker.addEventListener('input', (e) => {
    currentColor = e.target.value;
    // clear preset active states when user picks a custom color
    if (presetRed) presetRed.classList.remove('active');
    if (presetBlue) presetBlue.classList.remove('active');
});

// Preset color buttons (red/blue)
const presetRed = document.getElementById('preset-red');
const presetBlue = document.getElementById('preset-blue');
function setPresetColor(hex, btn) {
    colorPicker.value = hex;
    currentColor = hex;
    if (presetRed) presetRed.classList.remove('active');
    if (presetBlue) presetBlue.classList.remove('active');
    if (btn) btn.classList.add('active');
}
if (presetRed) {
    presetRed.addEventListener('click', (e) => { setPresetColor('#ff0000', presetRed); });
}
if (presetBlue) {
    presetBlue.addEventListener('click', (e) => { setPresetColor('#0000ff', presetBlue); });
}
// Initialize preset active state if color matches
if (colorPicker && colorPicker.value) {
    const val = colorPicker.value.toLowerCase();
    if (val === '#ff0000' && presetRed) presetRed.classList.add('active');
    else if ((val === '#0000ff' || val === '#00f') && presetBlue) presetBlue.classList.add('active');
}

// Manual save button: persist drawing to server and show status
const saveBtn = document.getElementById('save-drawing');
const saveStatus = document.getElementById('save-status');
async function saveDrawingToServer() {
    if (!currentMatchId) {
        saveStatus.textContent = 'Select a match before saving.';
        return;
    }
    saveStatus.textContent = 'Saving...';
    saveBtn.disabled = true;
    try {
        const resp = await fetch(`/matches/api/strategy_drawing/${currentMatchId}`, {
            method: 'POST',
            headers: {'Content-Type': 'application/json'},
            body: JSON.stringify({data: drawingData})
        });
        const json = await resp.json();
        if (resp.ok && json && json.success) {
            saveStatus.textContent = 'Saved.';
            setTimeout(() => { saveStatus.textContent = 'Saved.'; }, 1000);
        } else {
            saveStatus.textContent = json && json.error ? `Save failed: ${json.error}` : 'Save failed';
        }
    } catch (e) {
        console.warn('Save error', e);
        saveStatus.textContent = 'Save error (see console)';
    } finally {
        saveBtn.disabled = false;
        setTimeout(() => { if (saveStatus.textContent.startsWith('Saved')) saveStatus.textContent = 'Drawings are synced in real time and can be saved for later.'; }, 3000);
    }
}

saveBtn.addEventListener('click', saveDrawingToServer);
</script>
{% endblock %} 