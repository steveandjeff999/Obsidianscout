{% extends 'base.html' %}

{% block title %}Live Strategy Monitor{% endblock %}

{% block heading %}Live Strategy Monitor{% endblock %}
{% block subheading %}Automatically tracks your team's next match and advances after the scheduled start time{% endblock %}

{% block content %}
<div class="container">
    <!-- ===== Controls Row ===== -->
    <div class="row mb-3">
        <div class="col-md-6">
            <div class="card">
                <div class="card-header"><strong>Select Event &amp; Team</strong></div>
                <div class="card-body">
                    <div class="row g-2">
                        <div class="col-md-6 mb-2">
                            <label for="event_select" class="form-label">Event</label>
                            <select id="event_select" class="form-select">
                                <option value="">-- Select event --</option>
                                {% for ev in events|dedupe_events %}
                                <option value="{{ ev.id }}" data-event-code="{{ ev.code|upper if ev.code else '' }}" {% if selected_event and ev.id == selected_event.id %}selected{% endif %}>{{ ev.name }} ({{ ev.year }}){% if ev.is_alliance %} (Alliance){% endif %}</option>
                                {% endfor %}
                            </select>
                        </div>
                        <div class="col-md-6 mb-2">
                            <label for="team_select" class="form-label">Team</label>
                            <select id="team_select" class="form-select">
                                <option value="">-- Select team --</option>
                                {% for t in teams %}
                                <option value="{{ t.team_number }}">{{ t.team_number }}{% if t.team_name %} — {{ t.team_name }}{% endif %}</option>
                                {% endfor %}
                            </select>
                        </div>
                    </div>
                    <button id="start_btn" class="btn btn-primary w-100" disabled>Start Live Strategy</button>

                    <div class="mt-3">
                        <label for="manual_match_select" class="form-label">Manual Match Override</label>
                        <div class="input-group">
                            <select id="manual_match_select" class="form-select">
                                <option value="">-- Select match manually --</option>
                            </select>
                            <button id="manual_select_btn" class="btn btn-outline-primary">Show Match</button>
                        </div>
                        <div class="mt-1 text-muted small">Manual selection pauses auto-advance for 5 minutes.</div>
                    </div>
                </div>
            </div>
        </div>

        <div class="col-md-6">
            <div class="card">
                <div class="card-header"><strong>Status</strong></div>
                <div class="card-body">
                    <div id="status_box" class="fw-semibold">Idle — choose an event and team, then click Start.</div>
                    <div id="auto_advance_info" class="mt-2 text-muted small"></div>
                    <div id="schedule_summary" class="mt-2 text-muted small"></div>
                </div>
            </div>
        </div>
    </div>

    <!-- ===== Current Match Card ===== -->
    <div id="current_match_card" class="row d-none">
        <div class="col-12">
            <div class="card">
                <div class="card-header bg-secondary text-white">
                    <strong>Current Match for Team <span id="display_team"></span></strong>
                </div>
                <div class="card-body">
                    <div id="match_info">Loading...</div>
                    <div class="mt-3">
                        <button id="load_strategy_btn" class="btn btn-outline-primary">Reload Strategy</button>
                        <button id="force_next_btn" class="btn btn-outline-secondary ms-2">Force Advance &rarr;</button>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- ===== Raw Strategy JSON (fallback display) ===== -->
    <div id="strategy_json" class="row mt-3 d-none">
        <div class="col-12">
            <div class="card">
                <div class="card-header"><strong>Strategy JSON (raw)</strong></div>
                <div class="card-body">
                    <pre id="strategy_pre" class="pre-wrap">-</pre>
                </div>
            </div>
        </div>
    </div>

    <!-- ===== Rich Strategy Results ===== -->
    <div id="strategyResults" class="row mt-3 d-none">
        <div class="col-12">
            <div class="card">
                <div class="card-header">
                    <strong>Strategy Overview</strong>
                    <span class="float-end">
                        <span id="redAllianceScore" class="badge bg-danger">--</span>
                        <span id="blueAllianceScore" class="badge bg-primary ms-1">--</span>
                    </span>
                </div>
                <div class="card-body">
                    <div id="matchOverview" class="row mb-3"></div>
                    <div id="predictedOutcome" class="mb-3"></div>
                    <div class="row">
                        <div class="col-md-6"><div id="redAllianceStrategy"></div></div>
                        <div class="col-md-6"><div id="blueAllianceStrategy"></div></div>
                    </div>
                    <div class="row mt-3">
                        <div class="col-md-4"><canvas id="allianceComparisonChart" class="chart-h-200"></canvas></div>
                        <div class="col-md-4"><canvas id="performanceRadarChart" class="chart-h-200"></canvas></div>
                    </div>
                    <div id="keyBattles" class="mt-3"></div>
                    <div id="matchupAnalysis" class="mt-3"></div>
                </div>
            </div>
        </div>
    </div>
</div>

<!-- Chart libraries -->
<script src="{{ url_for('static', filename='js/vendor/chart.umd.min.js') }}"></script>
<script src="{{ url_for('static', filename='js/vendor/chartjs-adapter-date-fns.bundle.min.js') }}"></script>

<script>
/* ======================================================================
   LIVE STRATEGY MONITOR — Rewrite v3 (Feb 2026)
   ---------------------------------------------------------------
   Architecture (per user spec):
     1. Fetch full schedule from /matches/data every 15 minutes
     2. Cache the schedule client-side
     3. Client picks the next match for the selected team from the cache
     4. 2 minutes after a match's scheduled start → advance to next match
     5. Re-fetch schedule every 15 min to pick up time changes from API sync
   ====================================================================== */
(function () {
'use strict';

// ── Constants ──────────────────────────────────────────────────────────
var SCHEDULE_REFRESH_MS = 15 * 60 * 1000;  // re-fetch schedule every 15 minutes
var TICK_MS             = 1000;             // advance check every 1 second
var ADVANCE_DELAY_MS    = 2 * 60 * 1000;   // advance 2 min after scheduled start
var MANUAL_TIMEOUT_MS   = 5 * 60 * 1000;   // manual override lasts 5 minutes
var STRATEGY_RETRIES    = 2;

// ── State ──────────────────────────────────────────────────────────────
var S = {
    eventId:           null,
    teamNumber:        null,
    isRunning:         false,

    // Schedule cache (from /matches/data)
    allMatches:        [],      // ALL event matches from server
    teamMatches:       [],      // filtered + sorted for selected team
    lastScheduleFetch: 0,       // epoch ms when schedule was last fetched
    serverDelta:       0,       // (server_time - client_time) ms, for clock sync
    eventTimezone:     {{ (event_timezone | tojson) if event_timezone else 'null' }},    // IANA timezone string from event (e.g. 'America/Chicago')

    // Current display
    currentMatchId:    null,
    currentMatch:      null,
    currentIdx:        -1,      // index into teamMatches

    // Manual overrides
    skipIds:           [],      // match IDs manually advanced past
    manualUntil:       0,       // epoch ms when manual override expires

    // Timers
    scheduleTimer:     null,    // 15-min schedule refresh
    tickTimer:         null,    // 1-sec advance check

    // Strategy
    strategyData:      null
};

// ── DOM helpers ────────────────────────────────────────────────────────
function $(id) { return document.getElementById(id); }
function setStatus(msg)   { var el = $('status_box');       if (el) el.textContent = msg; }
function setAdvanceInfo(msg) { var el = $('auto_advance_info'); if (el) el.textContent = msg; }
function setScheduleSummary(msg) { var el = $('schedule_summary'); if (el) el.textContent = msg; }

// ── Match utilities ────────────────────────────────────────────────────
var MATCH_TYPE_ORDER = {
    practice:1, qualification:2, qualifier:2, quarterfinal:3, quarterfinals:3, qf:3,
    semifinal:4, semifinals:4, sf:4, playoff:5, elimination:5, final:6, finals:6, f:6
};

function matchSortKey(m) {
    var t = ((m.comp_level || m.match_type) || '').toLowerCase();
    var order = MATCH_TYPE_ORDER[t] || 99;
    var num = parseInt(String(m.match_number || 0), 10) || 0;
    return order * 100000 + num;
}

function compareMatches(a, b) { return matchSortKey(a) - matchSortKey(b); }

function teamInMatch(tn, m) {
    var t = String(tn);
    try {
        var red  = (m.alliances && m.alliances.red  && m.alliances.red.teams)  || [];
        var blue = (m.alliances && m.alliances.blue && m.alliances.blue.teams) || [];
        return red.concat(blue).map(String).indexOf(t) >= 0;
    } catch (e) { return false; }
}

/** Get match scheduled time as UTC epoch ms.
 *  Uses the server-computed scheduled_time_ms (UTC epoch) directly
 *  to avoid any browser timezone parsing issues with ISO strings. */
function getMatchEpochMs(m) {
    if (!m) return null;
    // Prefer the server-computed UTC epoch (no parsing ambiguity)
    if (m.scheduled_time_ms != null) return m.scheduled_time_ms;
    // Fallback: parse ISO string (should have +00:00 suffix)
    var raw = m.predicted_time || m.scheduled_time || null;
    if (!raw) return null;
    var d = new Date(raw);
    return isNaN(d.getTime()) ? null : d.getTime();
}

/** Format a match time for display in the EVENT's timezone
 *  (matching how the /matches page displays times).
 *  Uses the server-provided `display_time` which is pre-formatted
 *  in the event timezone by `format_time_with_timezone`.
 *  Falls back to browser-local time if display_time is unavailable. */
function formatLocalTime(m) {
    if (!m) return 'Time TBD';
    // Prefer server-provided display_time (formatted in event timezone, like /matches)
    if (m.display_time) return m.display_time;
    // Fallback: convert UTC epoch to event timezone on client if possible
    var epoch = getMatchEpochMs(m);
    if (epoch == null) return 'Time TBD';
    var d = new Date(epoch);
    // If we know the event timezone, format in that timezone
    if (S.eventTimezone) {
        try {
            return d.toLocaleTimeString([], {
                hour: '2-digit', minute: '2-digit',
                timeZone: S.eventTimezone
            });
        } catch (e) {
            // Fallback if browser doesn't support the timeZone option
        }
    }
    // Last resort: browser local time
    return d.toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' });
}

function isMatchCompleted(m) {
    if (!m) return false;
    if (m.status === 'completed') return true;
    if (m.actual_time) return true;
    var r = m.alliances && m.alliances.red  ? m.alliances.red.score  : null;
    var b = m.alliances && m.alliances.blue ? m.alliances.blue.score : null;
    return (r !== null && r !== undefined) || (b !== null && b !== undefined);
}

// ── Schedule Fetching ──────────────────────────────────────────────────

function fetchSchedule() {
    var url = '/matches/data';
    if (S.eventId) url += '?event_id=' + encodeURIComponent(S.eventId);

    setStatus('Fetching schedule from server\u2026');

    return fetch(url, { credentials: 'same-origin' })
        .then(function (resp) {
            if (!resp.ok) throw new Error('Server returned ' + resp.status);
            return resp.json();
        })
        .then(function (data) {
            if (!data || !data.success) throw new Error(data ? data.error || 'Unknown' : 'Empty response');

            S.allMatches = (data.matches || []).slice();
            S.lastScheduleFetch = Date.now();

            // Sync clock: compute delta between server UTC and client clock
            if (data.server_time_ms) {
                S.serverDelta = data.server_time_ms - Date.now();
                console.log('[LiveStrategy] Clock delta:', S.serverDelta, 'ms (' + (S.serverDelta/1000).toFixed(1) + 's)');
            }

            // Capture event timezone from server (used for display, matching /matches page)
            if (data.current_event && data.current_event.timezone) {
                S.eventTimezone = data.current_event.timezone;
                console.log('[LiveStrategy] Event timezone:', S.eventTimezone);
            }

            // Filter to team's matches and sort
            rebuildTeamMatches();

            console.log('[LiveStrategy] Schedule fetched:', S.allMatches.length,
                        'total,', S.teamMatches.length, 'for team', S.teamNumber);
        })
        .catch(function (e) {
            console.warn('fetchSchedule failed:', e);
            setStatus('Failed to fetch schedule: ' + e.message);
        });
}

/** Get the server-synced "now" (UTC epoch ms adjusted by clock delta) */
function serverNow() {
    return Date.now() + S.serverDelta;
}

function rebuildTeamMatches() {
    if (!S.teamNumber) { S.teamMatches = []; return; }
    S.teamMatches = S.allMatches
        .filter(function (m) { return teamInMatch(S.teamNumber, m); })
        .sort(compareMatches);

    // Update summary — count matches whose time+2min has passed vs upcoming
    var now = serverNow();
    var total = S.teamMatches.length;
    var passed = 0;
    for (var i = 0; i < S.teamMatches.length; i++) {
        var t = getMatchEpochMs(S.teamMatches[i]);
        if (t !== null && now >= t + ADVANCE_DELAY_MS) passed++;
    }
    setScheduleSummary(total + ' matches total \u00b7 ' + passed + ' past \u00b7 ' + (total - passed) + ' upcoming');
}

// ── Match Selection (client-side, purely time-based) ───────────────────

/**
 * Find the match closest to the current time whose scheduled_time + 2 min
 * has NOT yet passed.  "Completed" status is ignored — only the clock matters.
 *
 * Walk the sorted team schedule:
 *   1. Skip any match in the skip list.
 *   2. Skip any match whose time + 2 min is already past.
 *   3. First remaining match is the one to show.
 *
 * Fallback: if every match is past the 2-min threshold, show the last
 * non-skipped match (the one furthest in the schedule).
 */
function pickCurrentMatch() {
    var now = serverNow();
    var matches = S.teamMatches;
    if (!matches.length) return { match: null, idx: -1, advanceAt: null, hasNext: false };

    var selectedIdx = -1;

    // Pass 1: first match whose time + 2 min hasn't passed yet
    for (var i = 0; i < matches.length; i++) {
        if (S.skipIds.indexOf(matches[i].id) >= 0) continue;

        var epochMs = getMatchEpochMs(matches[i]);
        if (epochMs === null) {
            // No scheduled time — treat as viable (show it)
            selectedIdx = i;
            break;
        }
        if (now < epochMs + ADVANCE_DELAY_MS) {
            // This match's window is still open
            selectedIdx = i;
            break;
        }
        // time + 2 min passed → skip to next
    }

    // Pass 2: all matches are past 2-min → show the last non-skipped match
    if (selectedIdx < 0) {
        for (var j = matches.length - 1; j >= 0; j--) {
            if (S.skipIds.indexOf(matches[j].id) < 0) {
                selectedIdx = j;
                break;
            }
        }
    }

    // Pass 3: everything is skipped — just show the last match
    if (selectedIdx < 0) {
        selectedIdx = matches.length - 1;
    }

    var selected = matches[selectedIdx];
    var selectedEpoch = getMatchEpochMs(selected);
    var advanceAtMs = selectedEpoch ? (selectedEpoch + ADVANCE_DELAY_MS) : null;

    // Is there a next non-skipped match after this one?
    var hasNext = false;
    for (var k = selectedIdx + 1; k < matches.length; k++) {
        if (S.skipIds.indexOf(matches[k].id) < 0) {
            hasNext = true;
            break;
        }
    }

    // No next match → no advance timer
    if (!hasNext) advanceAtMs = null;

    // Debug logging
    console.log('[LiveStrategy] pickCurrentMatch: serverNow=' + new Date(now).toISOString()
        + ' selected=#' + selected.match_number
        + ' time=' + (getMatchEpochMs(selected) ? new Date(getMatchEpochMs(selected)).toISOString() : 'none')
        + ' advanceAt=' + (advanceAtMs ? new Date(advanceAtMs).toISOString() : 'none')
        + ' hasNext=' + hasNext
        + ' delta=' + S.serverDelta + 'ms');

    return { match: selected, idx: selectedIdx, advanceAt: advanceAtMs, hasNext: hasNext };
}

// ── Display ────────────────────────────────────────────────────────────

function renderMatchInfo(m) {
    if (!m) return '<div class="text-muted">No upcoming match found for this team.</div>';
    // Display time in the EVENT timezone (matching /matches page behavior)
    var timeStr = formatLocalTime(m);
    // Show timezone label if available
    var tzLabel = '';
    if (S.eventTimezone) {
        // Extract short name like "Chicago" from "America/Chicago"
        var parts = S.eventTimezone.split('/');
        tzLabel = '<br><small class="text-muted">' + parts[parts.length - 1].replace(/_/g, ' ') + '</small>';
    }
    var teamsRed  = (m.alliances && m.alliances.red  && m.alliances.red.teams)  ? m.alliances.red.teams.join(', ')  : '\u2014';
    var teamsBlue = (m.alliances && m.alliances.blue && m.alliances.blue.teams) ? m.alliances.blue.teams.join(', ') : '\u2014';
    var level = m.comp_level || '';
    return '<div class="row text-center">'
        + '<div class="col-md-3"><strong>Match</strong><div class="fs-5">' + (m.match_number || '--') + '</div><small class="text-muted">' + level + '</small></div>'
        + '<div class="col-md-3"><strong>Scheduled</strong><div>' + timeStr + '</div>' + tzLabel + '</div>'
        + '<div class="col-md-3"><strong class="text-danger">Red Alliance</strong><div>' + teamsRed + '</div></div>'
        + '<div class="col-md-3"><strong class="text-primary">Blue Alliance</strong><div>' + teamsBlue + '</div></div>'
        + '</div>';
}

function showMatch(match, advanceAt, hasNext) {
    if (!match) {
        $('match_info').innerHTML = renderMatchInfo(null);
        $('current_match_card').classList.add('d-none');
        $('strategyResults').classList.add('d-none');
        $('strategy_json').classList.add('d-none');
        return;
    }

    var changed = (match.id !== S.currentMatchId);
    S.currentMatchId = match.id;
    S.currentMatch   = match;
    S.currentIdx     = -1; // will be set by caller or findIdx
    // Store advance info for the tick timer
    S._advanceAt = advanceAt;
    S._hasNext   = hasNext;

    $('current_match_card').classList.remove('d-none');
    $('display_team').textContent = S.teamNumber || '';
    $('match_info').innerHTML = renderMatchInfo(match);

    var matchNum = match.match_number || '';
    var level    = match.comp_level || '';
    setStatus('Showing match ' + matchNum + (level ? ' (' + level + ')' : ''));

    if (changed) {
        // Hide old strategy until new one loads
        $('strategyResults').classList.add('d-none');
        $('strategy_json').classList.add('d-none');
        loadStrategy(match.id);
    }
}

// ── Tick Timer (1-second) — advance check + countdown display ──────────

function stopTick() {
    if (S.tickTimer) { clearInterval(S.tickTimer); S.tickTimer = null; }
}

function startTick() {
    stopTick();
    S.tickTimer = setInterval(tick, TICK_MS);
    tick(); // immediate first tick
}

function tick() {
    if (!S.isRunning) return;
    var now = serverNow();

    // Manual override active?
    if (S.manualUntil > now) {
        var rem = S.manualUntil - now;
        var sec = Math.floor(rem / 1000) % 60;
        var min = Math.floor(rem / 60000);
        setAdvanceInfo('Manual mode \u2014 auto-advance resumes in ' + min + 'm ' + sec + 's');
        return;
    }

    // Re-pick the current match from cache (handles advance automatically)
    var pick = pickCurrentMatch();
    if (!pick.match) {
        setAdvanceInfo('No matches found for this team.');
        return;
    }

    // Did the match change? (auto-advance happened)
    if (pick.match.id !== S.currentMatchId) {
        console.log('[LiveStrategy] Auto-advancing to match', pick.match.match_number);
        showMatch(pick.match, pick.advanceAt, pick.hasNext);
        return;
    }

    // Update countdown display
    if (!pick.advanceAt) {
        if (!pick.hasNext) {
            setAdvanceInfo('This is the last upcoming match for this team. No auto-advance needed.');
        } else {
            setAdvanceInfo('No scheduled time — will advance when schedule updates.');
        }
        return;
    }

    var remain = pick.advanceAt - now;
    if (remain <= 0) {
        if (pick.hasNext) {
            setAdvanceInfo('Scheduled start + 2 min passed \u2014 advancing\u2026');
        } else {
            setAdvanceInfo('Scheduled time passed. Last upcoming match for this team.');
        }
    } else {
        var s2 = Math.floor(remain / 1000) % 60;
        var m2 = Math.floor(remain / 60000);
        setAdvanceInfo('Auto-advance in ' + m2 + 'm ' + (s2 < 10 ? '0' : '') + s2 + 's');
    }
}

// ── Schedule Refresh Timer (15-min) ────────────────────────────────────

function stopScheduleRefresh() {
    if (S.scheduleTimer) { clearInterval(S.scheduleTimer); S.scheduleTimer = null; }
}

function startScheduleRefresh() {
    stopScheduleRefresh();
    S.scheduleTimer = setInterval(function () {
        console.log('[LiveStrategy] 15-min schedule refresh');
        fetchSchedule().then(function () {
            populateManualSelect();
            // Re-evaluate current match with fresh schedule
            if (S.manualUntil <= Date.now()) {
                var pick = pickCurrentMatch();
                if (pick.match && pick.match.id !== S.currentMatchId) {
                    showMatch(pick.match, pick.advanceAt, pick.hasNext);
                }
            }
        });
    }, SCHEDULE_REFRESH_MS);
}

// ── Main Start / Stop ──────────────────────────────────────────────────

function stopAll() {
    S.isRunning = false;
    stopTick();
    stopScheduleRefresh();
}

function startLive() {
    S.isRunning = true;
    S.skipIds = [];
    S.manualUntil = 0;
    stopAll();
    S.isRunning = true;

    setStatus('Fetching schedule for team ' + S.teamNumber + '\u2026');

    fetchSchedule().then(function () {
        populateManualSelect();

        // Pick initial match
        var pick = pickCurrentMatch();
        if (pick.match) {
            showMatch(pick.match, pick.advanceAt, pick.hasNext);
        } else {
            setStatus('No matches found for team ' + S.teamNumber + ' at this event.');
            setAdvanceInfo('');
        }

        // Start the 1-second tick for advance checks
        startTick();
        // Start the 15-minute schedule refresh
        startScheduleRefresh();
    });
}

// ── Strategy Loading ───────────────────────────────────────────────────

function loadStrategy(matchId) {
    if (!matchId) return;
    var url = '/matches/strategy/analyze/' + matchId;
    var attempt = 0;

    function doAttempt() {
        attempt++;
        setStatus('Loading strategy analysis' + (attempt > 1 ? ' (retry ' + (attempt-1) + ')' : '') + '\u2026');

        fetch(url, { credentials: 'same-origin' })
            .then(function (resp) {
                if (!resp.ok) {
                    return resp.text().then(function (txt) {
                        if (resp.status === 401 || resp.status === 403) {
                            setStatus('Strategy analysis: not authorized (' + resp.status + ')');
                            throw { done: true };
                        }
                        throw new Error(resp.status + ' ' + txt.substring(0, 200));
                    });
                }
                return resp.json();
            })
            .then(function (data) {
                S.strategyData = data;
                try {
                    displayStrategyResults(data);
                    $('strategyResults').classList.remove('d-none');
                    $('strategy_json').classList.add('d-none');
                    setStatus('Strategy loaded for match ' + (S.currentMatch ? S.currentMatch.match_number : matchId));
                } catch (renderErr) {
                    console.warn('Strategy render failed, showing raw JSON:', renderErr);
                    $('strategy_pre').textContent = JSON.stringify(data, null, 2);
                    $('strategy_json').classList.remove('d-none');
                    $('strategyResults').classList.add('d-none');
                }
            })
            .catch(function (e) {
                if (e && e.done) return;
                console.warn('Strategy fetch error (attempt ' + attempt + '):', e);
                if (attempt <= STRATEGY_RETRIES) {
                    setTimeout(doAttempt, 2000 * attempt);
                } else {
                    setStatus('Strategy analysis failed: ' + (e.message || e));
                    try {
                        $('strategy_pre').textContent = 'Error loading strategy:\n' + (e.message || String(e));
                        $('strategy_json').classList.remove('d-none');
                        $('strategyResults').classList.add('d-none');
                    } catch (_) {}
                }
            });
    }

    doAttempt();
}

// ── Manual Match Select ────────────────────────────────────────────────

function populateManualSelect() {
    var sel = $('manual_match_select');
    if (!sel) return;

    var prev = sel.value;
    sel.innerHTML = '<option value="">-- Select match manually --</option>';

    var list = S.teamMatches.length ? S.teamMatches : S.allMatches.slice().sort(compareMatches);

    list.forEach(function (m) {
        var red  = (m.alliances && m.alliances.red  && m.alliances.red.teams)  ? m.alliances.red.teams.join(',') : '';
        var blue = (m.alliances && m.alliances.blue && m.alliances.blue.teams) ? m.alliances.blue.teams.join(',') : '';
        var timeLabel = ' @ ' + formatLocalTime(m);
        var lbl = (m.comp_level || '') + ' ' + (m.match_number || '--') + timeLabel + ' \u2014 Red: ' + red + ' vs Blue: ' + blue;
        var opt = document.createElement('option');
        opt.value = m.id;
        opt.textContent = lbl;
        if (String(m.id) === String(prev)) opt.selected = true;
        sel.appendChild(opt);
    });
}

// ── Force Advance ──────────────────────────────────────────────────────

function forceNextMatch() {
    if (!S.currentMatchId) return;
    if (S.skipIds.indexOf(S.currentMatchId) < 0) {
        S.skipIds.push(S.currentMatchId);
    }
    S.manualUntil = 0; // clear manual override

    var pick = pickCurrentMatch();
    if (pick.match) {
        showMatch(pick.match, pick.advanceAt, pick.hasNext);
        setStatus('Force-advanced to match ' + (pick.match.match_number || pick.match.id));
    } else {
        setStatus('No more matches to advance to.');
    }
}

// ── Manual Override ────────────────────────────────────────────────────

function manualSelectMatch() {
    var sel = $('manual_match_select');
    var matchId = sel ? parseInt(sel.value, 10) : NaN;
    if (!matchId || isNaN(matchId)) {
        alert('Choose a match to show manually.');
        return;
    }

    var match = null;
    var allSrc = S.allMatches.length ? S.allMatches : S.teamMatches;
    for (var i = 0; i < allSrc.length; i++) {
        if (allSrc[i].id === matchId) { match = allSrc[i]; break; }
    }
    if (!match) {
        alert('Match not found in cache. Try refreshing the page.');
        return;
    }

    S.manualUntil = Date.now() + MANUAL_TIMEOUT_MS;
    showMatch(match, null, false);
    setStatus('Manual mode \u2014 showing match ' + (match.match_number || matchId) + '. Auto-advance paused for 5 minutes.');
}

// ───────────────────────────────────────────────────────────────────────
// STRATEGY DISPLAY FUNCTIONS
// (Rendering strategy analysis results — fully functional, kept intact)
// ───────────────────────────────────────────────────────────────────────

var allianceChart = null;
var radarChart = null;

function normalizeTeamEntry(t) {
    if (!t) return null;
    if (typeof t === 'number' || typeof t === 'string') return { team: { team_number: Number(t) } };
    if (t.team) return t;
    if (t.team_number) return { team: { team_number: t.team_number, team_name: t.team_name } };
    return null;
}

function uniqTeamEntries(arr) {
    var map = {};
    (arr || []).forEach(function (item) {
        var e = normalizeTeamEntry(item);
        if (!e || !e.team) return;
        var key = String(e.team.team_number || '');
        if (!key) return;
        if (!map[key]) {
            map[key] = e;
        } else {
            var prev = map[key];
            var pMet = prev.metrics && Object.keys(prev.metrics).length > 0;
            var nMet = e.metrics && Object.keys(e.metrics).length > 0;
            if (!pMet && nMet) map[key] = e;
        }
    });
    var vals = [];
    for (var k in map) { if (map.hasOwnProperty(k)) vals.push(map[k]); }
    return vals;
}

function displayStrategyResults(data) {
    if (!data) return;
    displayMatchOverview(data.match);
    displayPredictedOutcome(data.predicted_outcome || {});
    displayAllianceStrategy(data.red_alliance || {}, 'red');
    displayAllianceStrategy(data.blue_alliance || {}, 'blue');
    displayKeyBattles(data.key_battles || []);
    displayMatchupAnalysis(data.matchup_analysis || {});
    createVisualizationCharts(data.graph_data || {});
    $('strategyResults').classList.remove('d-none');
}

function displayMatchOverview(matchData) {
    if (!matchData) matchData = {};
    var container = $('matchOverview');
    container.innerHTML = ''
        + '<div class="col-md-3">'
        + '  <div class="text-center">'
        + '    <h4>' + (matchData.type || matchData.match_type || '') + ' ' + (matchData.number || matchData.match_number || '') + '</h4>'
        + '    <p class="text-muted">' + (matchData.event || '') + '</p>'
        + '  </div>'
        + '</div>'
        + '<div class="col-md-9">'
        + '  <div class="row">'
        + '    <div class="col-md-6">'
        + '      <h6 class="text-danger">Red Alliance</h6>'
        + '      <div id="redTeamsList"></div>'
        + '    </div>'
        + '    <div class="col-md-6">'
        + '      <h6 class="text-primary">Blue Alliance</h6>'
        + '      <div id="blueTeamsList"></div>'
        + '    </div>'
        + '  </div>'
        + '</div>';

    try {
        var redList = $('redTeamsList');
        var blueList = $('blueTeamsList');
        var rawRed = matchData.red_teams || (S.strategyData && S.strategyData.red_alliance && S.strategyData.red_alliance.teams) || [];
        var rawBlue = matchData.blue_teams || (S.strategyData && S.strategyData.blue_alliance && S.strategyData.blue_alliance.teams) || [];
        uniqTeamEntries(rawRed).forEach(function (t) {
            var tn = (t.team && t.team.team_number) || t;
            var name = (t.team && t.team.team_name) || '';
            var div = document.createElement('div');
            div.innerHTML = '<div class="mb-1"><strong>Team ' + tn + '</strong>' + (name ? '<br><small class="text-muted">' + name + '</small>' : '') + '</div>';
            redList.appendChild(div);
        });
        uniqTeamEntries(rawBlue).forEach(function (t) {
            var tn = (t.team && t.team.team_number) || t;
            var name = (t.team && t.team.team_name) || '';
            var div = document.createElement('div');
            div.innerHTML = '<div class="mb-1"><strong>Team ' + tn + '</strong>' + (name ? '<br><small class="text-muted">' + name + '</small>' : '') + '</div>';
            blueList.appendChild(div);
        });
    } catch (e) { console.warn(e); }
}

function displayPredictedOutcome(prediction) {
    var container = $('predictedOutcome');
    function fmt(v) { return (v !== null && v !== undefined && !isNaN(Number(v))) ? Math.round(Number(v)) : '--'; }
    var winnerClass = prediction.predicted_winner === 'red' ? 'text-danger' : 'text-primary';
    var winnerText  = prediction.predicted_winner === 'red' ? 'Red Alliance' : 'Blue Alliance';
    container.innerHTML = ''
        + '<div class="row">'
        + '  <div class="col-md-4"><div class="text-center"><h2 class="' + winnerClass + '">' + winnerText + '</h2><p class="lead">Predicted Winner</p></div></div>'
        + '  <div class="col-md-4"><div class="text-center"><h2>' + fmt(prediction.red_score) + ' - ' + fmt(prediction.blue_score) + '</h2><p class="lead">Expected Score</p></div></div>'
        + '  <div class="col-md-4"><div class="text-center"><h2 class="text-info">' + (typeof prediction.confidence === 'number' ? Math.round(prediction.confidence * 100) + '%' : (prediction.confidence || '')) + '</h2><p class="lead">Confidence Level</p></div></div>'
        + '</div>'
        + '<div class="mt-3"><h6>Analysis Reasoning:</h6><ul class="mb-0">'
        + (prediction.reasoning || []).map(function(r){ return '<li>' + r + '</li>'; }).join('')
        + '</ul></div>';
}

function displayAllianceStrategy(allianceData, color) {
    var container = $(color + 'AllianceStrategy');
    try {
        var badge = $(color === 'red' ? 'redAllianceScore' : 'blueAllianceScore');
        var score = null;
        if (S.strategyData && S.strategyData.predicted_outcome) {
            score = S.strategyData.predicted_outcome[color + '_score'];
        }
        if (score === undefined || score === null) {
            score = allianceData.predicted_score;
        }
        badge.textContent = (score !== null && score !== undefined && !isNaN(Number(score))) ? Math.round(Number(score)) + ' pts' : '--';
    } catch (e) { console.warn(e); }

    var teams = uniqTeamEntries(allianceData.teams || []);
    var teamsHtml = teams.map(function (td) {
        var tn = (td.team && td.team.team_number) || '';
        var nm = (td.team && td.team.team_name) || '';
        var tot = (td.metrics && (td.metrics.tot || td.metrics.total_points)) || 0;
        return '<div class="col-md-4 mb-3"><div class="card"><div class="card-body p-2">'
            + '<h6 class="card-title">Team ' + tn + '</h6>'
            + '<small class="text-muted">' + nm + '</small>'
            + '<div class="mt-2"><small class="text-success">Total: ' + tot + ' pts</small></div>'
            + '</div></div></div>';
    }).join('');

    var strats = (allianceData.strategy && allianceData.strategy.key_strategies) || [];
    container.innerHTML = ''
        + '<div class="mb-4"><h6>Team Composition:</h6><div class="row">' + teamsHtml + '</div></div>'
        + '<div class="mb-4"><h6>Key Strategies:</h6><ul class="mb-0">' + strats.map(function(s){ return '<li>' + s + '</li>'; }).join('') + '</ul></div>';
}

function displayKeyBattles(battles) {
    var container = $('keyBattles');
    var filtered = (battles || []).filter(function (b) { return !/(Endgame Showdown|Autonomous Battle)/i.test(b.title || ''); });
    if (!filtered.length) { container.innerHTML = '<p class="text-muted">No key battles identified.</p>'; return; }
    container.innerHTML = filtered.map(function (b) {
        return '<div class="card mb-3"><div class="card-body">'
            + '<h6 class="card-title">' + b.title + '</h6><p>' + b.description + '</p>'
            + '<div class="row"><div class="col-md-6"><span class="badge bg-danger">Team ' + b.red_team + '</span></div>'
            + '<div class="col-md-6"><span class="badge bg-primary">Team ' + b.blue_team + '</span></div></div>'
            + '<small class="text-muted">Key Factor: ' + b.key_factor + '</small>'
            + '</div></div>';
    }).join('');
}

function displayMatchupAnalysis(matchupData) {
    var container = $('matchupAnalysis');
    if (!matchupData || !matchupData.overall_comparison) {
        container.innerHTML = '<p class="text-muted">No matchup analysis available.</p>';
        return;
    }
    var overall = matchupData.overall_comparison;
    var period  = matchupData.period_analysis || {};
    var pred    = (S.strategyData && S.strategyData.predicted_outcome) || null;

    var red_val  = (pred && pred.red_score  != null) ? Number(pred.red_score)  : Number(overall.red_alliance_total  || 0);
    var blue_val = (pred && pred.blue_score != null) ? Number(pred.blue_score) : Number(overall.blue_alliance_total || 0);
    var margin   = (pred && pred.margin != null)     ? Number(pred.margin)     : Math.abs(red_val - blue_val);
    var advantage = (pred && pred.predicted_winner) ? pred.predicted_winner : (overall.advantage || (red_val > blue_val ? 'red' : 'blue'));

    function periodBadge(p, name) {
        var adv = (p && p.advantage) || 'blue';
        return '<div class="mb-2"><div class="d-flex justify-content-between"><span>' + name + ':</span>'
            + '<span class="badge ' + (adv === 'red' ? 'bg-danger' : 'bg-primary') + '">' + (adv === 'red' ? 'Red' : 'Blue') + '</span></div></div>';
    }

    // Key insights (deduplicated)
    var insightsArr = matchupData.key_insights || [];
    var seen = {};
    var insightsHtml = '';
    insightsArr.forEach(function (s) {
        var k = String(s).trim().toLowerCase();
        if (!seen[k]) {
            seen[k] = true;
            insightsHtml += '<li>' + s + '</li>';
        }
    });

    container.innerHTML = ''
        + '<div class="row mb-4">'
        + '  <div class="col-md-6">'
        + '    <h6>Overall Comparison</h6>'
        + '    <div class="card"><div class="card-body">'
        + '      <div class="row">'
        + '        <div class="col-6 text-center"><h4 class="text-danger">' + red_val.toFixed(1) + '</h4><p class="mb-0">Red Alliance</p></div>'
        + '        <div class="col-6 text-center"><h4 class="text-primary">' + blue_val.toFixed(1) + '</h4><p class="mb-0">Blue Alliance</p></div>'
        + '      </div>'
        + '      <div class="text-center mt-3">'
        + '        <span class="badge ' + (advantage === 'red' ? 'bg-danger' : 'bg-primary') + '">' + (advantage === 'red' ? 'Red' : 'Blue') + ' Alliance Advantage</span>'
        + '        <br><small class="text-muted">Margin: ' + margin.toFixed(1) + ' points</small>'
        + '      </div>'
        + '    </div></div>'
        + '  </div>'
        + '  <div class="col-md-6">'
        + '    <h6>Period Analysis</h6>'
        + '    <div class="card"><div class="card-body">'
        + periodBadge(period.autonomous, 'Autonomous')
        + periodBadge(period.teleop, 'Teleop')
        + periodBadge(period.endgame, 'Endgame')
        + '    </div></div>'
        + '  </div>'
        + '</div>'
        + '<div class="row"><div class="col-12"><h6>Key Insights</h6><ul class="mb-0">' + insightsHtml + '</ul></div></div>';
}

function createVisualizationCharts(graphData) {
    try {
        if (!graphData) return;
        if (graphData.alliance_comparison) createAllianceComparisonChart(graphData.alliance_comparison);
        if (graphData.radar_chart_data)    createPerformanceRadarChart(graphData.radar_chart_data);
    } catch (e) { console.warn('Chart creation failed', e); }
}

function createAllianceComparisonChart(data) {
    try {
        var ctx = $('allianceComparisonChart').getContext('2d');
        if (allianceChart) allianceChart.destroy();
        allianceChart = new Chart(ctx, {
            type: 'bar',
            data: {
                labels: data.categories || [],
                datasets: [
                    { label: 'Red Alliance',  data: data.red_alliance  || [], backgroundColor: 'rgba(220,53,69,0.7)' },
                    { label: 'Blue Alliance', data: data.blue_alliance || [], backgroundColor: 'rgba(13,110,253,0.7)' }
                ]
            },
            options: { responsive: true, maintainAspectRatio: false }
        });
    } catch (e) { console.warn(e); }
}

function createPerformanceRadarChart(data) {
    try {
        var ctx = $('performanceRadarChart').getContext('2d');
        if (radarChart) radarChart.destroy();
        radarChart = new Chart(ctx, {
            type: 'radar',
            data: {
                labels: data.labels || [],
                datasets: [
                    { label: 'Red',  data: data.red_alliance  || [], backgroundColor: 'rgba(220,53,69,0.2)' },
                    { label: 'Blue', data: data.blue_alliance || [], backgroundColor: 'rgba(13,110,253,0.2)' }
                ]
            },
            options: { responsive: true, maintainAspectRatio: false }
        });
    } catch (e) { console.warn(e); }
}

// ───────────────────────────────────────────────────────────────────────
// INITIALIZATION
// ───────────────────────────────────────────────────────────────────────

// ───────────────────────────────────────────────────────────────────────
// INITIALIZATION
// ───────────────────────────────────────────────────────────────────────

document.addEventListener('DOMContentLoaded', function () {
    var eventSel = $('event_select');
    var teamSel  = $('team_select');
    var startBtn = $('start_btn');

    S.eventId = eventSel.value || null;

    // ── Event change: reload page so server populates teams for new event ──
    eventSel.addEventListener('change', function () {
        var v = eventSel.value;
        try { localStorage.setItem('strategy_live_selected_event', v || ''); } catch (_) {}
        if (v) {
            var url = new URL(window.location.href);
            url.searchParams.set('event_id', v);
            window.location.href = url.toString();
        }
    });

    // ── Team change: enable start button ──
    teamSel.addEventListener('change', function () {
        var v = teamSel.value;
        try { localStorage.setItem('strategy_live_selected_team', v || ''); } catch (_) {}
        startBtn.disabled = !v;
        if (v) {
            S.teamNumber = v;
            setTimeout(function () { startBtn.click(); }, 150);
        } else {
            S.teamNumber = null;
        }
    });

    // ── Start button ──
    startBtn.addEventListener('click', function () {
        S.teamNumber = teamSel.value;
        S.eventId    = eventSel.value || null;
        if (!S.teamNumber) { alert('Select a team first.'); return; }

        try {
            localStorage.setItem('strategy_live_selected_team',  S.teamNumber || '');
            localStorage.setItem('strategy_live_selected_event', S.eventId || '');
        } catch (_) {}

        startLive();
    });

    // ── Buttons ──
    $('load_strategy_btn').addEventListener('click', function () {
        if (S.currentMatchId) loadStrategy(S.currentMatchId);
    });
    $('force_next_btn').addEventListener('click', forceNextMatch);
    $('manual_select_btn').addEventListener('click', manualSelectMatch);

    // ── Restore cached selections ──
    try {
        var cachedEvent = localStorage.getItem('strategy_live_selected_event');
        var cachedTeam  = localStorage.getItem('strategy_live_selected_team');

        if (cachedEvent && String(cachedEvent) !== String(eventSel.value)) {
            if (window.location.search.indexOf('event_id=' + cachedEvent) < 0) {
                var url = new URL(window.location.href);
                url.searchParams.set('event_id', cachedEvent);
                window.location.href = url.toString();
                return;
            }
        }

        if (cachedTeam && teamSel) {
            var opts = teamSel.options;
            for (var i = 0; i < opts.length; i++) {
                if (String(opts[i].value) === String(cachedTeam)) {
                    teamSel.value = cachedTeam;
                    S.teamNumber  = cachedTeam;
                    startBtn.disabled = false;
                    break;
                }
            }
        }
    } catch (_) {}

    // ── Auto-start if team was already selected ──
    if (teamSel.value) {
        startBtn.disabled = false;
        setTimeout(function () { startBtn.click(); }, 300);
    }
});

})();
</script>

<style>
#strategy_pre { max-height: 50vh; overflow: auto; background: #f8f9fa; padding: 1rem; }
</style>
{% endblock %}
