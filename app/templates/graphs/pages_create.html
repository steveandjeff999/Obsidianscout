{% extends 'base.html' %}
{% block title %}{% if page is defined %}Edit Custom Page{% else %}Create Custom Page{% endif %}{% endblock %}
{% block heading %}{% if page is defined %}Edit Custom Page{% else %}Create Custom Page{% endif %}{% endblock %}

{% block content %}
<form method="post" id="pageCreateForm">
  <div class="row">
    <div class="col-lg-4">
      <div class="card mb-3">
        <div class="card-header">Page Details</div>
        <div class="card-body">
          <div class="mb-3">
            <label class="form-label">Title</label>
            <input type="text" name="title" id="page_title_input" class="form-control" required value="{{ page.title if page is defined else '' }}" />
          </div>
          <div class="form-text mb-2">Drag widgets from the toolbox into the canvas. Configure each widget and click Create.</div>
          <input type="hidden" name="widgets_json" id="widgets_json_hidden">
        </div>
      </div>

      <div class="card">
        <div class="card-header">Toolbox</div>
        <div class="card-body">
          <div class="toolbox-item list-group mb-2" draggable="true" data-widget-type="graph" style="cursor:grab;">
            <div class="list-group-item d-flex align-items-center">
              <i class="fas fa-chart-bar me-2"></i>
              <div>
                <div class="fw-semibold">Graph Widget</div>
                <div class="small text-muted">Plot a metric or scoring element</div>
              </div>
            </div>
          </div>
          <div class="toolbox-item list-group mb-2" draggable="true" data-widget-type="text" style="cursor:grab;">
            <div class="list-group-item d-flex align-items-center">
              <i class="fas fa-align-left me-2"></i>
              <div>
                <div class="fw-semibold">Text Widget</div>
                <div class="small text-muted">Add descriptive text / notes</div>
              </div>
            </div>
          </div>
          <div class="form-text">Tip: drag multiple widgets into the canvas and reorder them.</div>
        </div>
      </div>
    </div>

    <div class="col-lg-8">
      <div class="card">
        <div class="card-header">Canvas</div>
        <div class="card-body">
          <div id="canvas" class="border rounded p-3" style="min-height:320px; background:#f8f9fa; max-height:60vh; overflow:auto; position:relative;">
            <div id="canvasEmpty" class="text-muted">Drop widgets here</div>
          </div>
          <div class="form-text mt-2">Canvas is scrollable. Widgets can be resized by dragging the handle at the bottom-right of each widget.</div>
        </div>
        <div class="card-footer d-flex justify-content-between">
          <div>
            <button class="btn btn-primary" type="submit">{% if page is defined %}Update{% else %}Create{% endif %}</button>
            <a class="btn btn-secondary" href="{{ url_for('graphs.pages_index') }}">Cancel</a>
          </div>
          <div class="text-muted small">Widgets will be saved as JSON</div>
        </div>
      </div>

      <div class="card mt-3">
        <div class="card-header">Available Metrics & Scoring Elements</div>
        <div class="card-body small">
          <div class="row">
            <div class="col-md-6">
              <h6>Metrics</h6>
              <ul class="small">
                {% for metric in metrics %}
                  <li>{{ metric.name }} (id={{ metric.id }})</li>
                {% endfor %}
              </ul>
            </div>
            <div class="col-md-6">
              <h6>Scoring Elements</h6>
              <ul class="small">
                {% for el in scoring_elements %}
                  <li>{{ el.name }} ({{ el.period }} - id={{ el.id }})</li>
                {% endfor %}
              </ul>
            </div>
          </div>
        </div>
      </div>
    </div>
  </div>
</form>

<!-- Embed metric and scoring element lists as JSON script tags to keep templates safe -->
<script id="page_builder_metrics_json" type="application/json">{{ metrics|tojson|safe }}</script>
<script id="page_builder_scoring_json" type="application/json">{{ scoring_elements|tojson|safe }}</script>
<script id="page_builder_teams_json" type="application/json">{{ teams|tojson|safe }}</script>
<script id="page_builder_initial_widgets" type="application/json">{{ initial_widgets|tojson|safe }}</script>
<script id="page_builder_initial_page" type="application/json">{% if page is defined %}{{ {'title': page.title, 'id': page.id}|tojson|safe }}{% else %}{}{% endif %}</script>

<style>
/* Custom multi-select dropdown styling */
.custom-multiselect {
  position: relative;
  display: inline-block;
  width: 100%;
}

.custom-multiselect .dropdown-toggle {
  width: 100%;
  text-align: left;
  overflow: hidden;
  text-overflow: ellipsis;
  white-space: nowrap;
}

.custom-multiselect .dropdown-menu {
  max-height: 300px;
  overflow-y: auto;
  width: 100%;
}

.custom-multiselect .dropdown-menu .form-check {
  padding: 0.5rem 1rem;
  margin: 0;
}

.custom-multiselect .dropdown-menu .form-check:hover {
  background-color: #f8f9fa;
}

.custom-multiselect .dropdown-menu .form-check-input {
  cursor: pointer;
}

.custom-multiselect .dropdown-menu .form-check-label {
  cursor: pointer;
  user-select: none;
  width: 100%;
}
</style>

<script>
// Ensure DOM is fully loaded before running page builder code
document.addEventListener('DOMContentLoaded', function() {
  const PAGE_BUILDER_METRICS = JSON.parse(document.getElementById('page_builder_metrics_json').textContent || '[]');
  const PAGE_BUILDER_SCORING = JSON.parse(document.getElementById('page_builder_scoring_json').textContent || '[]');
  const PAGE_BUILDER_TEAMS = JSON.parse(document.getElementById('page_builder_teams_json').textContent || '[]');

  const toolboxItems = document.querySelectorAll('.toolbox-item');
  const canvas = document.getElementById('canvas');
  const canvasEmpty = document.getElementById('canvasEmpty');
  const form = document.getElementById('pageCreateForm');
  const hiddenField = document.getElementById('widgets_json_hidden');

  let draggedToolType = null;
  let draggedWidget = null;

  toolboxItems.forEach(item => {
    item.addEventListener('dragstart', (e) => {
      draggedToolType = item.dataset.widgetType;
      e.dataTransfer.setData('text/plain', draggedToolType);
    });
  });

  // Make canvas accept drops
  canvas.addEventListener('dragover', (e) => { e.preventDefault(); });
  canvas.addEventListener('drop', (e) => {
    e.preventDefault();
    const type = e.dataTransfer.getData('text/plain') || draggedToolType;
    if (!type) return;
    addWidgetToCanvas(type);
  });

  // Allow reordering of widgets inside canvas using native drag on widget cards
  function enableWidgetDnD(widgetEl){
    widgetEl.setAttribute('draggable','true');
    widgetEl.addEventListener('dragstart', (e)=>{ draggedWidget = widgetEl; e.dataTransfer.setData('text/plain','widget'); widgetEl.classList.add('dragging'); });
    widgetEl.addEventListener('dragend', ()=>{ draggedWidget = null; widgetEl.classList.remove('dragging'); });
    widgetEl.addEventListener('dragover', (e)=>{ e.preventDefault(); const target = e.currentTarget; if (draggedWidget && draggedWidget !== target) {
      const rect = target.getBoundingClientRect();
      const before = (e.clientY - rect.top) < (rect.height / 2);
      canvas.insertBefore(draggedWidget, before ? target : target.nextSibling);
    }});
  }

  function addWidgetToCanvas(type, initial){
    if (canvasEmpty) canvasEmpty.style.display = 'none';
    const id = 'w_' + Date.now() + '_' + Math.floor(Math.random()*1000);
    const wrapper = document.createElement('div');
    wrapper.className = 'card mb-3 widget-card';
    // Ensure wrappers are positioned so resize handle can be absolute
    wrapper.style.position = 'relative';
    
    // Set default sizes - can be overridden by initial config or resized by user
    const defaultWidth = type === 'text' ? '400px' : '600px';
    const defaultHeight = type === 'text' ? '200px' : '400px';
    
    wrapper.style.width = defaultWidth;
    wrapper.style.height = defaultHeight;
    wrapper.dataset.widgetType = type;
    wrapper.dataset.widgetId = id;
    wrapper.innerHTML = widgetInnerHtml(type, id, initial || {});
    canvas.appendChild(wrapper);
    enableWidgetDnD(wrapper);
    attachWidgetControls(wrapper);
    attachResizeHandlers(wrapper);
    // Apply initial size if provided (override defaults)
    if (initial && initial.width) wrapper.style.width = (typeof initial.width === 'number' ? initial.width + 'px' : initial.width);
    if (initial && initial.height) wrapper.style.height = (typeof initial.height === 'number' ? initial.height + 'px' : initial.height);
    
    // Convert any multi-select dropdowns in this widget to custom dropdowns
    wrapper.querySelectorAll('select[multiple]').forEach(makeCustomMulti);
  }

  function widgetInnerHtml(type, id, initial){
      if (type === 'graph'){
      // build metric options
      let metricOptions = PAGE_BUILDER_METRICS.map(m => `<option value="${m.id}" ${initial.metric==m.id? 'selected':''}>${m.name}</option>`).join('');
      // include scoring elements as optgroup
      const scoringOptions = PAGE_BUILDER_SCORING.map(s => `<option value="se:${s.id}" ${initial.metric && initial.metric==('se:'+s.id)? 'selected':''}>${s.period}: ${s.name}</option>`).join('');
      // build team options for initial selection. Include 'All Teams' option at top.
      let teamOptionsHtml = '';
      try{
        // If initial.teams is not provided or is empty, treat as 'all'
        const initialTeamsEmpty = !initial.hasOwnProperty('teams') || (Array.isArray(initial.teams) && initial.teams.length === 0);
        const allSelected = initialTeamsEmpty || (initial.teams && initial.teams.indexOf('all') !== -1);
        teamOptionsHtml += `<option value="all" ${allSelected ? 'selected' : ''}>All Teams</option>`;
        PAGE_BUILDER_TEAMS.forEach(t => {
          const sel = (initial.teams && Array.isArray(initial.teams) && initial.teams.indexOf(t.id) !== -1) ? 'selected' : '';
          teamOptionsHtml += `<option value="${t.id}" ${sel}>${t.name}</option>`;
        });
      } catch(e){ teamOptionsHtml = ''; }
      return `
        <div class="card-header d-flex justify-content-between align-items-center">
          <strong>Graph Widget</strong>
          <div>
            <button type="button" class="btn btn-sm btn-outline-danger btn-remove-widget" title="Remove"><i class="fas fa-trash"></i></button>
          </div>
        </div>
        <div class="card-body">
          <div class="mb-2">
            <label class="form-label">Metric / Scoring Element</label>
            <div class="input-group">
              <select class="form-select widget-metric">
                <optgroup label="Metrics">${metricOptions}</optgroup>
                <optgroup label="Scoring Elements">${scoringOptions}</optgroup>
              </select>
              <span class="input-group-text">
                <label class="mb-0"><input type="checkbox" class="form-check-input ms-1 widget-user-select" ${initial.user_select ? 'checked' : ''} /> User Select</label>
              </span>
            </div>
            <div class="form-text">If "User Select" is checked, the viewer of this page will be able to choose the metric/scoring element when viewing the page.</div>
          </div>
          <div class="mb-2">
            <label class="form-label">Graph Type</label>
            <div class="input-group">
              <select class="form-select widget-graph-type" multiple data-placeholder="Select graph types...">
                <option value="bar" ${initial.graph_types && initial.graph_types.includes('bar') ? 'selected' : ''}>bar</option>
                <option value="line" ${initial.graph_types && initial.graph_types.includes('line') ? 'selected' : ''}>line</option>
                <option value="scatter" ${initial.graph_types && initial.graph_types.includes('scatter') ? 'selected' : ''}>scatter</option>
                <option value="histogram" ${initial.graph_types && initial.graph_types.includes('histogram') ? 'selected' : ''}>histogram</option>
              </select>
              <span class="input-group-text">
                <label class="mb-0"><input type="checkbox" class="form-check-input ms-1 widget-graphtype-user-select" ${initial.graphtype_user_select ? 'checked' : ''} /> User Select</label>
              </span>
            </div>
            <div class="form-text">If "User Select" is checked, viewers can choose graph types when viewing this widget.</div>
          </div>
          <div class="mb-2">
            <label class="form-label">Teams</label>
            <div class="input-group">
              <select class="form-select widget-teams-select" multiple data-placeholder="Select teams...">
                ${teamOptionsHtml}
              </select>
              <span class="input-group-text">
                <label class="mb-0"><input type="checkbox" class="form-check-input ms-1 widget-teams-user-select" ${initial.teams_user_select ? 'checked' : ''} /> User Select</label>
              </span>
            </div>
            <div class="form-text">Select teams to include in this widget. If "User Select" is checked, viewers can change the teams shown.</div>
          </div>
        </div>`;
    } else if (type === 'text'){
      return `
        <div class="card-header d-flex justify-content-between align-items-center">
          <strong>Text Widget</strong>
          <div>
            <button type="button" class="btn btn-sm btn-outline-danger btn-remove-widget" title="Remove"><i class="fas fa-trash"></i></button>
          </div>
        </div>
        <div class="card-body">
          <div class="mb-2">
            <label class="form-label">Content</label>
            <textarea class="form-control widget-text" rows="3">${initial.text || ''}</textarea>
          </div>
        </div>`;
    }
    return '';
  }

  function attachWidgetControls(wrapper){
    const removeBtn = wrapper.querySelector('.btn-remove-widget');
    if (removeBtn) removeBtn.addEventListener('click', ()=>{ 
      wrapper.remove(); 
      // Check if there are any remaining widget cards
      if (canvas.querySelectorAll('.widget-card').length === 0) {
        if (canvasEmpty) canvasEmpty.style.display='block';
      }
    });
  }

  // Attach resize handle and handlers to a widget wrapper
  function attachResizeHandlers(wrapper){
    // Create handle
    let handle = wrapper.querySelector('.resize-handle');
    if (!handle){
      handle = document.createElement('div');
      handle.className = 'resize-handle';
      // style it
      handle.style.position = 'absolute';
      handle.style.width = '14px';
      handle.style.height = '14px';
      handle.style.right = '6px';
      handle.style.bottom = '6px';
      handle.style.cursor = 'se-resize';
      handle.style.background = 'rgba(0,0,0,0.15)';
      handle.style.borderRadius = '3px';
      wrapper.appendChild(handle);
    }

    let resizing = false;
    let startX=0, startY=0, startW=0, startH=0;

    function onPointerDown(e){
      e.preventDefault();
      resizing = true;
      document.body.style.userSelect = 'none';
      startX = (e.touches ? e.touches[0].clientX : e.clientX);
      startY = (e.touches ? e.touches[0].clientY : e.clientY);
      const rect = wrapper.getBoundingClientRect();
      startW = rect.width;
      startH = rect.height;
      window.addEventListener('mousemove', onPointerMove);
      window.addEventListener('touchmove', onPointerMove, { passive:false });
      window.addEventListener('mouseup', onPointerUp);
      window.addEventListener('touchend', onPointerUp);
    }

    function onPointerMove(e){
      if(!resizing) return;
      e.preventDefault();
      const clientX = (e.touches ? e.touches[0].clientX : e.clientX);
      const clientY = (e.touches ? e.touches[0].clientY : e.clientY);
      const dx = clientX - startX;
      const dy = clientY - startY;
      const newW = Math.max(200, startW + dx);
      const newH = Math.max(80, startH + dy);
      wrapper.style.width = newW + 'px';
      wrapper.style.height = newH + 'px';
    }

    function onPointerUp(){
      resizing = false;
      document.body.style.userSelect = '';
      window.removeEventListener('mousemove', onPointerMove);
      window.removeEventListener('touchmove', onPointerMove);
      window.removeEventListener('mouseup', onPointerUp);
      window.removeEventListener('touchend', onPointerUp);
    }

    handle.addEventListener('mousedown', onPointerDown);
    handle.addEventListener('touchstart', onPointerDown, { passive:false });
  }

  // Auto-scroll canvas when dragging a widget near the edges
  function autoScrollDuringDrag(e){
    if (!draggedWidget) return;
    const rect = canvas.getBoundingClientRect();
    const y = e.clientY;
    const margin = 40;
    const scrollSpeed = 10;
    if (y < rect.top + margin) {
      canvas.scrollTop -= scrollSpeed;
    } else if (y > rect.bottom - margin) {
      canvas.scrollTop += scrollSpeed;
    }
  }

  // Hook into global dragover to enable auto-scroll
  document.addEventListener('dragover', function(e){
    try { autoScrollDuringDrag(e); } catch(err){}
  });

  // Build JSON from canvas widgets
  function buildWidgetsJson(){
    const widgets = [];
    canvas.querySelectorAll('.widget-card').forEach(card => {
      const type = card.dataset.widgetType;
      // capture computed width/height so widget size persists
      const computed = window.getComputedStyle(card);
      const widthPx = computed.width;
      const heightPx = computed.height;
      if (type === 'graph'){
        const metricSel = card.querySelector('.widget-metric');
        const graphTypeSel = card.querySelector('.widget-graph-type');
        const teamsSel = card.querySelector('.widget-teams-select');
        const metricVal = metricSel ? metricSel.value : null;
        const graphTypes = graphTypeSel ? Array.from(graphTypeSel.selectedOptions).map(o=>o.value) : [];
        let teams = [];
        if (teamsSel){
          const vals = Array.from(teamsSel.selectedOptions).map(o=>o.value);
          if (vals.indexOf('all') !== -1){
            teams = ['all'];
          } else {
            teams = vals.map(v => parseInt(v)).filter(v => !isNaN(v));
          }
        }
        const graphtypeUserSelect = !!(card.querySelector('.widget-graphtype-user-select') && card.querySelector('.widget-graphtype-user-select').checked);
        const metricUserSelect = !!(card.querySelector('.widget-user-select') && card.querySelector('.widget-user-select').checked);
        const teamsUserSelect = !!(card.querySelector('.widget-teams-user-select') && card.querySelector('.widget-teams-user-select').checked);
        widgets.push({ type: 'graph', metric: metricVal, graph_types: graphTypes, teams: teams, width: parseInt(widthPx), height: parseInt(heightPx), user_select: metricUserSelect, graphtype_user_select: graphtypeUserSelect, teams_user_select: teamsUserSelect });
      } else if (type === 'text'){
        const text = card.querySelector('.widget-text') ? card.querySelector('.widget-text').value : '';
        widgets.push({ type: 'text', text: text, width: parseInt(widthPx), height: parseInt(heightPx) });
      }
    });
    return widgets;
  }

  // Update hidden field before submit
  form.addEventListener('submit', function(e){
    const widgets = buildWidgetsJson();
    hiddenField.value = JSON.stringify(widgets);
    // Let the form submit normally (POST)
  });

  // Allow double-click on toolbox to add widget (convenience)
  document.querySelectorAll('.toolbox-item').forEach(it => {
    it.addEventListener('dblclick', () => addWidgetToCanvas(it.dataset.widgetType));
  });

  // If initial widgets were provided (edit mode), populate the canvas
  try{
    const initialWidgets = JSON.parse(document.getElementById('page_builder_initial_widgets').textContent || '[]');
    const initialPage = JSON.parse(document.getElementById('page_builder_initial_page').textContent || '{}');
    if (initialPage && initialPage.title && document.getElementById('page_title_input')){
      document.getElementById('page_title_input').value = initialPage.title;
    }
    if (Array.isArray(initialWidgets) && initialWidgets.length){
      // clear placeholder
      if (canvasEmpty) canvasEmpty.style.display = 'none';
      initialWidgets.forEach(w => {
        // add widget with initial data
        addWidgetToCanvas(w.type || 'graph', w);
      });
    }
  }catch(e){ console.warn('No initial widgets to preload', e); }
  
  // Convert multi-selects in page builder widget cards into compact checkbox dropdowns
  function makeCustomMulti(el){
    if (!el || el.dataset.customized) return;
    el.dataset.customized = '1';
    const wrapper = document.createElement('div');
    wrapper.className = 'custom-multiselect dropdown';

        const btn = document.createElement('button');
        btn.type = 'button';
        btn.className = 'btn btn-outline-secondary dropdown-toggle';
        btn.setAttribute('data-bs-toggle','dropdown');
        btn.textContent = (el.getAttribute('data-placeholder') || 'Select...');

        const menu = document.createElement('div');
        menu.className = 'dropdown-menu';

        Array.from(el.options).forEach(opt => {
          const item = document.createElement('div');
          item.className = 'form-check';
          const cb = document.createElement('input');
          cb.type = 'checkbox';
          cb.className = 'form-check-input';
          cb.id = 'cb_' + Math.random().toString(36).slice(2,9);
          cb.checked = opt.selected;
          // store the original option value so we can reconstruct selections from the wrapper
          cb.dataset.value = opt.value;
          const label = document.createElement('label');
          label.className = 'form-check-label';
          label.htmlFor = cb.id;
          label.textContent = opt.text;
          cb.addEventListener('change', function(){
            opt.selected = cb.checked;
            el.dispatchEvent(new Event('input', { bubbles: true }));
            el.dispatchEvent(new Event('change', { bubbles: true }));
            updateBtnText();
          });
          item.appendChild(cb);
          item.appendChild(label);
          menu.appendChild(item);
        });

        function updateBtnText(){
          const sel = Array.from(el.selectedOptions).map(o=>o.text);
          const placeholder = el.getAttribute('data-placeholder') || 'Select...';
          if (sel.length === 0) {
            btn.textContent = placeholder;
          } else if (sel.length <= 2) {
            btn.textContent = sel.join(', ');
          } else {
            btn.textContent = sel.length + ' selected';
          }
        }

  // hide original select but keep it in DOM
  // copy any data-* attributes (eg. placeholder or widget-index) to wrapper
  Array.from(el.attributes).forEach(attr => { if (attr.name.startsWith('data-')) wrapper.setAttribute(attr.name, attr.value); });
  el.style.display = 'none';
  el.parentNode.insertBefore(wrapper, el);
  wrapper.appendChild(btn);
  wrapper.appendChild(menu);
  updateBtnText();
  document.addEventListener('click', function(e){ if (!wrapper.contains(e.target)) bootstrap.Dropdown && bootstrap.Dropdown.getOrCreateInstance(btn).hide(); });
}

// Convert any present and future widget multi-selects (widgets may be added dynamically)
function convertAllMultiSelects(){ 
  document.querySelectorAll('.widget-card select[multiple]').forEach(makeCustomMulti); 
}

// Set up MutationObserver to convert multi-selects when new widgets are added
const multiSelectObserver = new MutationObserver(()=>convertAllMultiSelects());
multiSelectObserver.observe(canvas, { childList: true, subtree: true });

// Initial conversion of any existing multi-selects
convertAllMultiSelects();

});
</script>
{% endblock %}
