<!DOCTYPE html>
<html lang="en" class="h-100">
<head>
    <!-- Early theme detection: apply dark-mode class to <html> before CSS loads to prevent white flash -->
    <script>
        // Server-side indication whether liquid glass buttons are allowed for this team.
        // This is a small, early flag used by client scripts to decide whether to honor
        // per-user 'liquid_glass_buttons' preference stored in localStorage.
        window.__server_liquid_glass_allowed = {{ 'true' if liquid_glass_buttons_enabled|default(False) else 'false' }};
    </script>
    <script>
        (function(){
            try {
                // Check explicit user preference stored in localStorage (string 'true' / 'false')
                var stored = null;
                try { stored = localStorage.getItem('darkMode'); } catch (e) { stored = null; }
                var prefersDark = false;
                try { prefersDark = window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches; } catch(e) { prefersDark = false; }
                var useDark = null;
                if (stored === 'true') useDark = true;
                else if (stored === 'false') useDark = false;
                else useDark = prefersDark;

                if (useDark) {
                    // Apply to documentElement so early CSS can target html.dark-mode or body.dark-mode
                    document.documentElement.classList.add('dark-mode');
                    // Also set a small inline style to ensure background is dark immediately
                    var css = 'html.dark-mode, html.dark-mode body { background: #0b0b0d; color: #e6e6e6; }';
                    var s = document.createElement('style');
                    s.setAttribute('data-ob-theme','early');
                    s.appendChild(document.createTextNode(css));
                    // Insert before other head children
                    var head = document.getElementsByTagName('head')[0];
                    if (head) head.insertBefore(s, head.firstChild);
                }
            } catch (e) { /* fail silently - don't block page */ }
        })();
    </script>
    <script>
        (function(){
            try {
                // Check explicit user preference stored in localStorage for rounded UI
                var storedRounded = null;
                try { storedRounded = localStorage.getItem('rounded_ui'); } catch (e) { storedRounded = null; }
                // Default to rounded UI (false) when user hasn't set a preference
                var useRounded = null;
                if (storedRounded === 'true') useRounded = true;
                else if (storedRounded === 'false') useRounded = false;
                else useRounded = true; // default: rounded UI enabled for modern look

                if (useRounded) {
                    document.documentElement.classList.add('rounded-ui');
                    // Apply very small inline style to reduce flash and ensure early layout
                        var css = 'html.rounded-ui, body.rounded-ui { --border-radius: 1.25rem; }';
                    var s = document.createElement('style');
                    s.setAttribute('data-ob-rounded','early');
                    s.appendChild(document.createTextNode(css));
                    var headEl = document.getElementsByTagName('head')[0];
                    if (headEl) headEl.insertBefore(s, headEl.firstChild);
                }
                // Apply navbar theme early to avoid flash
                try {
                    var storedNavbar = null;
                    try { storedNavbar = localStorage.getItem('navbar_theme'); } catch(e) { storedNavbar = null; }
                    var themeVal = (storedNavbar !== null) ? storedNavbar : 'neutral';
                    document.documentElement.classList.add('nav-theme-'+themeVal);
                    document.body.classList.add('nav-theme-'+themeVal);
                } catch(e) { /* ignore */ }
                // Button shape customization removed: no early UI-shape class is applied
                // Accent color is removed from per-user settings; rely on theme defaults.

                    var br = null; try { br = localStorage.getItem('border_radius'); } catch(e) { br = null; }
                    if (br) { try { document.documentElement.style.setProperty('--border-radius', br+'px'); document.body.style.setProperty('--border-radius', br+'px'); try{ document.documentElement.style.setProperty('--card-radius', Math.max(parseInt(br,10),4) + 'px'); document.body.style.setProperty('--card-radius', Math.max(parseInt(br,10),4) + 'px'); document.documentElement.style.setProperty('--control-radius', Math.max(parseInt(br,10) - 4,4) + 'px'); document.body.style.setProperty('--control-radius', Math.max(parseInt(br,10) - 4,4) + 'px'); }catch(e){} } catch(e) {} }

                    /* Button size customization removed: no early btn-size class applied */

                    var elev = null; try { elev = localStorage.getItem('card_elevation'); } catch(e) { elev = null; }
                    if (elev) { try { document.documentElement.classList.add('card-elevation-'+elev); document.body.classList.add('card-elevation-'+elev); } catch(e) {} }

                    var glass = null; try { glass = localStorage.getItem('glass_effect'); } catch(e) { glass = null; }
                    // Default: glass effects enabled unless user explicitly turns them off.
                    // Treat several legacy 'false' variants as disabled so toggles remain consistent.
                    try {
                        var glassVal = String(glass || '').toLowerCase();
                        var disabled = (glassVal === 'false' || glassVal === '0' || glassVal === 'off' || glassVal === 'disabled');
                        // Debug: log early glass preference state when in development
                        try { if(window && window.console && window.console.debug) console.debug('[early-theme] glass_effect=', glass, ' => disabled?', disabled); } catch(e) {}
                        if (disabled) {
                            document.documentElement.classList.add('glass-off');
                            document.body.classList.add('glass-off');
                        }
                    } catch(e) {}
                
                    // Per-user per-team "liquid glass" buttons preference.
                    // Server controls whether this appearance feature is allowed for the team.
                    // - If the server has enabled the feature for the team, the server's
                    //   default will be used unless the user has an explicit local preference.
                    // - If the server has disabled the feature, user preferences are ignored.
                    // Expose a small helper value (set via Jinja below) so this early script
                    // can decide the initial state and avoid visual flashes.
                    try {
                        var serverAllowsLiquid = (typeof window.__server_liquid_glass_allowed !== 'undefined') ? (window.__server_liquid_glass_allowed === true || window.__server_liquid_glass_allowed === 'true') : false;
                        var storedLiquid = null;
                        try { storedLiquid = localStorage.getItem('liquid_glass_buttons'); } catch(e) { storedLiquid = null; }

                        // Honor explicit per-user preference when present; otherwise fall back to server default.
                        if (storedLiquid === 'true') {
                            try { document.documentElement.classList.add('liquid-glass-buttons'); document.body.classList.add('liquid-glass-buttons'); } catch(e) {}
                        } else if (storedLiquid === 'false') {
                            try { document.documentElement.classList.remove('liquid-glass-buttons'); document.body.classList.remove('liquid-glass-buttons'); } catch(e) {}
                        } else {
                            // No per-user pref: fall back to server allowance/template default.
                            if (!serverAllowsLiquid) {
                                try { document.documentElement.classList.remove('liquid-glass-buttons'); document.body.classList.remove('liquid-glass-buttons'); } catch(e) {}
                            }
                            // else leave server default as rendered by template
                        }
                    } catch(e) { /* non-fatal */ }
                } catch(e) {}
            } catch (e) { /* silently ignore */ }
        })();
    </script>
    <script>
    // Ensure suggestion dropdowns use dark background when the app is in dark mode.
    (function(){
        function applyDarkToSuggestions(root){
            try{
                const els = (root || document).querySelectorAll('.enhanced-search-suggestions, .enhanced-search-suggestions-main, #suggestions, #searchSuggestionsTop');
                els.forEach(el => {
                    // Use setProperty with priority 'important' to overwrite inline !important styles
                    el.style.setProperty('background', '#0b0b0d', 'important');
                    el.style.setProperty('color', '#ffffff', 'important');
                    el.style.setProperty('border-color', 'rgba(255,255,255,0.04)', 'important');
                });
            }catch(e){console && console.warn && console.warn('applyDarkToSuggestions error', e);}    
        }

        function init() {
            if (document.documentElement.classList.contains('dark-mode')) {
                applyDarkToSuggestions(document);

                // Watch for new suggestion elements being added dynamically
                const bodyObs = new MutationObserver(mutations => {
                    mutations.forEach(m => {
                        m.addedNodes && m.addedNodes.forEach(node => {
                            if (node.nodeType === 1) {
                                if (node.matches && (node.matches('.enhanced-search-suggestions') || node.matches('.enhanced-search-suggestions-main') || node.id === 'searchSuggestionsTop' || node.id === 'suggestions')) {
                                    applyDarkToSuggestions(node.parentNode || document);
                                }
                            }
                        });
                    });
                });
                bodyObs.observe(document.body, { childList: true, subtree: true });

                // Also observe html element class changes (theme toggles)
                const htmlObs = new MutationObserver(mutations => {
                    mutations.forEach(m => {
                        if (m.attributeName === 'class') {
                            if (document.documentElement.classList.contains('dark-mode')) applyDarkToSuggestions(document);
                        }
                    });
                });
                htmlObs.observe(document.documentElement, { attributes: true });
            }
        }

        if (document.readyState === 'loading') document.addEventListener('DOMContentLoaded', init); else init();
    })();
    </script>
    <script>
    // Aggressive short-duration re-apply to catch suggestion elements created very early
    (function(){
        function reapplyDark() {
            try {
                if (!document.documentElement.classList.contains('dark-mode')) return;
                const sel = ['.enhanced-search-suggestions', '.enhanced-search-suggestions-main', '#suggestions', '#searchSuggestionsTop'];
                sel.forEach(s => {
                    document.querySelectorAll(s).forEach(el => {
                        el.style.setProperty('background', '#0b0b0d', 'important');
                        el.style.setProperty('color', '#ffffff', 'important');
                        el.style.setProperty('border-color', 'rgba(255,255,255,0.04)', 'important');
                        el.querySelectorAll('.suggestion-item').forEach(it => {
                            it.style.setProperty('background', 'transparent', 'important');
                            it.style.setProperty('color', '#ffffff', 'important');
                        });
                    });
                });
            } catch (e) { console && console.debug && console.debug('reapplyDark error', e); }
        }

        if (document.readyState === 'complete' || document.readyState === 'interactive') {
            // Run immediately and schedule short repeated attempts
            reapplyDark();
        } else {
            document.addEventListener('DOMContentLoaded', reapplyDark);
        }

        // Run repeatedly for a short window to catch dynamically added inline-styled elements
        let tries = 0;
        const id = setInterval(() => {
            reapplyDark();
            tries += 1;
            if (tries > 20) clearInterval(id); // ~2 seconds at 100ms intervals
        }, 100);
    })();
    </script>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover, shrink-to-fit=no">
    <meta name="csrf-token" content="{{ csrf_token() if csrf_token else '' }}">
    <title>{% block title %}ObsidianScout{% endblock %}</title>
    
    {% if game_config %}
    <meta name="auto_duration" content="{{ game_config.get('auto_period', {}).get('duration_seconds', 15) }}">
    <meta name="teleop_duration" content="{{ game_config.get('teleop_period', {}).get('duration_seconds', 120) }}">
    <meta name="endgame_duration" content="{{ game_config.get('endgame_period', {}).get('duration_seconds', 30) }}">
    <script>
        // Pass game configuration as a JavaScript variable to avoid HTML escaping issues
        window.GAME_CONFIG = JSON.parse('{{ game_config|tojson|safe }}');
    </script>
    {% endif %}
    
    <link href="{{ url_for('static', filename='css/vendor/bootstrap.min.css') }}" rel="stylesheet">
    
    <link href="{{ url_for('static', filename='css/vendor/fontawesome-all.min.css') }}" rel="stylesheet">
    <!-- Modern fonts: Inter for UI + Poppins for headings -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;600;700&family=Poppins:wght@400;600;700&display=swap" rel="stylesheet">
    
    {# Google Fonts are internet-hosted; fallback to system fonts for offline use #}
    <style>body{font-family: Roboto, Montserrat, system-ui, -apple-system, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif;}</style>
    
    <link href="{{ url_for('static', filename='css/vendor/select2.min.css') }}" rel="stylesheet">
    <link href="{{ url_for('static', filename='css/vendor/select2-bootstrap-5-theme.min.css') }}" rel="stylesheet">
    
    <link rel="stylesheet" href="{{ url_for('static', filename='css/styles.css') }}">
    <link rel="stylesheet" href="{{ url_for('static', filename='css/theme-overrides.css') }}">
    <link rel="stylesheet" href="{{ url_for('static', filename='css/modal-fix.css') }}">
    <link rel="stylesheet" href="{{ url_for('static', filename='css/navbar-improvements.css') }}">
    <link rel="stylesheet" href="{{ url_for('static', filename='css/topbar-notifications.css') }}">
    <link rel="stylesheet" href="{{ url_for('static', filename='css/search-enhancements.css') }}">
    <link rel="stylesheet" href="{{ url_for('static', filename='css/sidebar.css') }}">
    <link rel="stylesheet" href="{{ url_for('static', filename='css/modern-ui.css') }}">
    <link rel="stylesheet" href="{{ url_for('static', filename='css/dark-mode-force.css') }}">
    <!-- Modern dark theme additions (more refined surfaces, softened shadows, updated accents) -->
    <link rel="stylesheet" href="{{ url_for('static', filename='css/dark-theme-modern.css') }}">
    <link rel="stylesheet" href="{{ url_for('static', filename='css/glass-theme.css') }}">
    <!-- Button shape customization removed: ui-rounded styles no longer included -->
    <link rel="stylesheet" href="{{ url_for('static', filename='css/mobile-fixes.css') }}">
    <!-- Use UMD build of Chart.js for compatibility with non-module script loading -->
    <script src="{{ url_for('static', filename='js/vendor/chart.umd.min.js') }}"></script>
    
    <!-- Dynamic Theme CSS Variables -->
    {% if theme_css_variables and theme_css_variables.strip() %}
    <style id="theme-variables">
        :root { {{ theme_css_variables | safe }} }
    </style>
    {% endif %}
    <style>
        /* Ensure card-bg variable uses the neutral, non-blue glass color in dark mode */
        body.dark-mode, body.modern-layout.dark-mode {
            --card-bg: rgba(24,24,26,0.78) !important;
            --glass-bg: rgba(22,22,24,0.70) !important;
            --glass-border: rgba(255,255,255,0.035) !important;
        }
        /* Force nested cards and small panels to match the neutral card background in dark mode.
           This duplicate inline rule helps in cases where external CSS is loaded before our override
           and prevents visual mismatches on initial render. */
        body.dark-mode .card .card,
        body.modern-layout.dark-mode .card .card,
        body.dark-mode .stat-card,
        body.modern-layout.dark-mode .stat-card,
        body.dark-mode .dashboard-card,
        body.modern-layout.dark-mode .dashboard-card {
            background: var(--card-bg) !important;
            background-color: var(--card-bg) !important;
            border: 1px solid rgba(0,0,0,0.45) !important;
            box-shadow: 0 2px 6px rgba(0,0,0,0.45) !important;
            color: var(--bs-body-color) !important;
            background-clip: padding-box !important;
            overflow: hidden !important;
        }
    </style>
    
    <link rel="manifest" href="{{ url_for('static', filename='manifest.json') }}">
    <link rel="icon" type="image/png" sizes="192x192" href="/static/obsidian-192.png">
    <link rel="apple-touch-icon" href="/static/obsidian-192.png">
    <meta name="theme-color" content="#1976d2">
    
    <style>
        .form-switch .form-check-input {
            height: 1.2rem;
            width: 2.2rem;
            cursor: pointer;
        }
        .form-check-label {
            cursor: pointer;
        }
        .dark-mode #darkModeIcon {
            color: #ffc107 !important;
        }
        .dark-mode #darkModeLabel {
            color: #e6e6e6;
        }
        .obsidian-gradient {
            background: linear-gradient(90deg, #7065a2 0%, #625591 100%);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            text-fill-color: transparent;
        }
        /* Small red dot used on user dropdown to indicate unread chat */
        .user-chat-dot {
            display: inline-block;
            width: 10px;
            height: 10px;
            border-radius: 50%;
            background: #dc3545; /* bootstrap danger */
            margin-left: 6px;
            vertical-align: middle;
        }
        
        /* Enhanced Search Component Styles */
        .search-wrapper {
            position: relative;
            flex: 1;
            max-width: 320px;
            min-width: 200px;
        }
        
        .enhanced-search-container {
            position: relative;
            width: 100%;
        }
        
        .search-input-wrapper {
            position: relative;
            display: flex;
            align-items: center;
            background: var(--bs-body-bg);
            border: 2px solid var(--bs-border-color);
            border-radius: 25px;
            transition: all 0.3s ease;
            overflow: hidden;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.08);
        }
        
        .search-input-wrapper:hover {
            border-color: var(--bs-primary);
            box-shadow: 0 4px 12px rgba(var(--bs-primary-rgb), 0.15);
        }
        
        .search-input-wrapper:focus-within {
            border-color: var(--bs-primary);
            box-shadow: 0 0 0 0.2rem rgba(var(--bs-primary-rgb), 0.25);
        }
        
        .search-icon {
            position: absolute;
            left: 14px;
            color: var(--bs-secondary);
            font-size: 0.9rem;
            z-index: 2;
            transition: color 0.3s ease;
        }
        
        .search-input-wrapper:focus-within .search-icon {
            color: var(--bs-primary);
        }
        
        .enhanced-search-input {
            flex: 1;
            border: none !important;
            outline: none !important;
            background: transparent !important;
            padding: 10px 45px 10px 40px !important;
            font-size: 0.9rem;
            color: var(--bs-body-color);
            box-shadow: none !important;
            border-radius: 0;
        }
        
        .enhanced-search-input::placeholder {
            color: var(--bs-secondary);
            font-style: italic;
        }
        
        .search-clear-btn {
            position: absolute;
            right: 45px;
            background: none;
            border: none;
            color: var(--bs-secondary);
            padding: 4px;
            border-radius: 50%;
            width: 20px;
            height: 20px;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            transition: all 0.2s ease;
            z-index: 2;
        }
        
        .search-clear-btn:hover {
            background: var(--bs-secondary-bg);
            color: var(--bs-danger);
        }
        
        .search-submit-btn {
            position: absolute;
            right: 4px;
            background: var(--bs-primary);
            border: none;
            color: white;
            padding: 8px;
            border-radius: 50%;
            width: 34px;
            height: 34px;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            transition: all 0.2s ease;
            z-index: 2;
        }
        
        .search-submit-btn:hover {
            background: var(--bs-primary);
            filter: brightness(110%);
            transform: scale(1.05);
        }
        
        .search-submit-btn:active {
            transform: scale(0.95);
        }

        /* Dark-mode overrides for navbar/main search so input is dark and text is white */
        body.dark-mode .search-input-wrapper,
        body.dark-mode .enhanced-search-input,
        body.dark-mode .search-input-wrapper .enhanced-search-input {
            background: #121212 !important;
            border-color: rgba(255,255,255,0.06) !important;
            color: #ffffff !important;
        }

        body.dark-mode .search-input-wrapper .search-icon,
        body.dark-mode .search-input-wrapper .search-clear-btn,
        body.dark-mode .search-input-wrapper .search-submit-btn {
            color: #ececec !important;
        }

        body.dark-mode .enhanced-search-input::placeholder {
            color: #bfbfbf !important;
            opacity: 1;
        }

        /* Make suggestions dropdown dark as well in dark mode */
        html.dark-mode .enhanced-search-suggestions,
        html.dark-mode .enhanced-search-suggestions.show,
        html.dark-mode .enhanced-search-suggestions-main,
        html.dark-mode .enhanced-search-suggestions-main.show,
        html.dark-mode #suggestions,
        body.dark-mode .enhanced-search-suggestions,
        body.dark-mode .enhanced-search-suggestions.show,
        body.dark-mode .enhanced-search-suggestions-main,
        body.dark-mode .enhanced-search-suggestions-main.show,
        body.dark-mode #suggestions {
            background: #0b0b0d !important;
            color: #ffffff !important;
            border-color: rgba(255,255,255,0.04) !important;
        }
        
        /* Enhanced Search Suggestions */
        .enhanced-search-suggestions {
            display: none !important;
        }
        
        .enhanced-search-suggestions.show {
            display: block !important;
            z-index: 9999 !important;
        }
        
        @keyframes searchFadeIn {
            from {
                opacity: 0;
                transform: translateY(-10px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }
        
        .suggestion-item {
            display: flex;
            align-items: center;
            padding: 12px 16px;
            cursor: pointer;
            border-bottom: 1px solid var(--bs-border-color);
            transition: all 0.2s ease;
            position: relative;
        }
        
        .suggestion-item:last-child {
            border-bottom: none;
        }
        
        .suggestion-item:hover,
        .suggestion-item.active {
            background: linear-gradient(135deg, rgba(var(--bs-primary-rgb), 0.1), rgba(var(--bs-primary-rgb), 0.05));
            transform: translateX(4px);
        }
        
        .suggestion-item.active::before {
            content: '';
            position: absolute;
            left: 0;
            top: 0;
            bottom: 0;
            width: 3px;
            background: var(--bs-primary);
            border-radius: 0 2px 2px 0;
        }
        
        .suggestion-icon {
            width: 20px;
            height: 20px;
            display: flex;
            align-items: center;
            justify-content: center;
            margin-right: 12px;
            background: rgba(var(--bs-primary-rgb), 0.1);
            border-radius: 6px;
            color: var(--bs-primary);
            font-size: 0.8rem;
            flex-shrink: 0;
        }
        
        .suggestion-content {
            flex: 1;
            min-width: 0;
        }
        
        .suggestion-title {
            font-weight: 600;
            color: var(--bs-body-color);
            margin-bottom: 2px;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
        }
        
        .suggestion-type {
            font-size: 0.75rem;
            color: var(--bs-secondary);
            text-transform: uppercase;
            letter-spacing: 0.5px;
            font-weight: 500;
        }
        
        .suggestion-category {
            padding: 8px 16px;
            background: var(--bs-secondary-bg);
            color: var(--bs-secondary);
            font-size: 0.75rem;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            border-bottom: 1px solid var(--bs-border-color);
            position: sticky;
            top: 0;
            z-index: 1;
        }
        
        .search-loading {
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 20px;
            color: var(--bs-secondary);
        }
        
        .search-loading-spinner {
            width: 16px;
            height: 16px;
            border: 2px solid var(--bs-secondary-bg);
            border-top: 2px solid var(--bs-primary);
            border-radius: 50%;
            animation: spin 1s linear infinite;
            margin-right: 8px;
        }
        
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
        
        .no-suggestions {
            padding: 20px;
            text-align: center;
            color: var(--bs-secondary);
            font-style: italic;
        }
        
        /* Mobile Search Button Enhancement */
        .modern-search-mobile {
            border-radius: 12px !important;
            background: var(--bs-primary) !important;
            border-color: var(--bs-primary) !important;
            color: white !important;
            transition: all 0.2s ease;
        }
        
        .modern-search-mobile:hover {
            background: var(--bs-primary) !important;
            border-color: var(--bs-primary) !important;
            color: white !important;
            transform: scale(1.05);
            filter: brightness(110%);
        }
        
        /* Responsive Design */
        @media (max-width: 1400px) {
            .search-wrapper {
                max-width: 280px;
                min-width: 180px;
            }
        }
        
        @media (max-width: 1200px) {
            .search-wrapper {
                max-width: 240px;
                min-width: 160px;
            }
            
            .enhanced-search-input {
                font-size: 0.85rem;
                padding: 9px 42px 9px 38px !important;
            }
            
            .search-icon {
                left: 12px;
                font-size: 0.85rem;
            }
            
            .search-submit-btn {
                width: 30px;
                height: 30px;
                right: 3px;
            }
        }
        
        @media (max-width: 992px) {
            .search-wrapper {
                max-width: 200px;
                min-width: 140px;
            }
        }
        
        @media (max-width: 768px) {
            .search-wrapper {
                max-width: auto;
                min-width: auto;
                flex: 0 0 auto;
            }
        }
        
        /* Dark Mode Support */
        .dark-mode .search-input-wrapper {
            background: var(--card-bg);
            border-color: rgba(255, 255, 255, 0.2);
        }
        
        .dark-mode .search-input-wrapper:hover {
            border-color: var(--bs-primary);
        }
        
        .dark-mode .enhanced-search-suggestions {
            background: var(--card-bg);
            border-color: rgba(255, 255, 255, 0.1);
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3);
        }
        
        .dark-mode .suggestion-item {
            border-bottom-color: rgba(255, 255, 255, 0.1);
        }
        
        .dark-mode .suggestion-item:hover,
        .dark-mode .suggestion-item.active {
            background: linear-gradient(135deg, rgba(var(--bs-primary-rgb), 0.2), rgba(var(--bs-primary-rgb), 0.1));
        }
        
        .dark-mode .suggestion-category {
            background: rgba(255, 255, 255, 0.05);
            border-bottom-color: rgba(255, 255, 255, 0.1);
        }
        
        /* Search functionality styles */
        .search-wrapper {
            position: relative;
            flex: 1;
            max-width: 280px;
            min-width: 160px;
        }
        
        /* Mobile Touch and Input Stability Fixes */
        @media (max-width: 768px) {
            /* Prevent iOS zoom on input focus */
            input, textarea, select, .form-control, .form-select {
                font-size: 16px !important;
                transform: translateZ(0);
                -webkit-transform: translateZ(0);
                -webkit-appearance: none;
                border-radius: 4px;
            }
            
            /* Prevent focus outline from causing scroll */
            input:focus, textarea:focus, select:focus, .form-control:focus, .form-select:focus {
                scroll-margin: 0 !important;
                scroll-behavior: auto !important;
                outline: 2px solid var(--bs-primary);
                outline-offset: -2px;
            }
            
            /* Stabilize form containers */
            .form-group, .input-group, .form-floating, .tab-content {
                contain: layout;
                transform: translateZ(0);
                -webkit-transform: translateZ(0);
            }
            
            /* Force hardware acceleration on interactive elements */
            button, .btn, [role="button"], .dropdown-toggle, .nav-link {
                transform: translateZ(0);
                -webkit-transform: translateZ(0);
                -webkit-tap-highlight-color: transparent;
            }
            
            /* Prevent dropdown and modal scroll issues */
            .dropdown-menu, .modal-dialog {
                transform: translateZ(0);
                -webkit-transform: translateZ(0);
            }
            
            /* Prevent body overflow during modal/dropdown interactions */
            body.modal-open, body.dropdown-open {
                overflow: hidden;
                position: fixed;
                width: 100%;
            }
        }
        
        /* Enhanced Mobile Click Protection */
        @media (max-width: 900px) {
            /* Prevent unwanted scroll during interactions */
            * {
                -webkit-overflow-scrolling: touch;
                touch-action: manipulation;
            }
            
            /* Specific protection for common culprits */
            a[href="#"], a[href=""], a[href="javascript:void(0)"] {
                touch-action: none !important;
            }
            
            /* Stable positioning for fixed elements */
            .topbar, .sidebar, .navbar-fixed-top {
                transform: translateZ(0);
                -webkit-transform: translateZ(0);
            }
        }
        
        @media (max-width: 1400px) {
            .search-wrapper {
                max-width: 220px;
                min-width: 140px;
            }
        }
        
        @media (max-width: 1200px) {
            .search-wrapper {
                max-width: 180px;
                min-width: 120px;
            }
        }
        
        @media (max-width: 992px) {
            .search-wrapper {
                max-width: 140px;
                min-width: 100px;
            }
        }
        
        @media (max-width: 768px) {
            .search-wrapper {
                max-width: auto;
                min-width: auto;
                flex: 0 0 auto;
            }
        }
        
        /* Make the navbar more responsive */
        .navbar-actions {
            flex-wrap: nowrap;
            align-items: center;
        }
        
        .navbar-actions > * {
            flex-shrink: 0;
        }
        
        /* Adjust button sizes for mobile */
        @media (max-width: 768px) {
            .btn-sm {
                padding: 0.25rem 0.5rem;
                font-size: 0.775rem;
            }
            
            .dropdown-toggle::after {
                margin-left: 0.255rem;
            }
        }
        
        .search-wrapper .form-control {
            transition: width 0.3s ease;
        }
        
        .search-wrapper .form-control:focus {
            width: 100%;
        }
        
        #searchSuggestions {
            position: absolute;
            top: 100%;
            left: 0;
            right: 0;
            background: var(--bs-body-bg);
            border: 1px solid var(--bs-border-color);
            border-radius: 0.375rem;
            box-shadow: 0 0.5rem 1rem rgba(0, 0, 0, 0.15);
            z-index: 1060; /* Higher than navbar dropdowns */
            max-height: 300px;
            overflow-y: auto;
            display: none;
        }
        
        .suggestion-item {
            cursor: pointer;
            border-bottom: 1px solid var(--bs-border-color);
            transition: background-color 0.15s ease-in-out;
        }
        
        .suggestion-item:last-child {
            border-bottom: none;
        }
        
        .suggestion-item:hover,
        .suggestion-item.active {
            background-color: var(--bs-secondary-bg);
        }
        
        .search-mobile-btn {
            border: none;
            background: none;
            color: var(--bs-nav-link-color);
            padding: 0.5rem;
            border-radius: 0.375rem;
            transition: background-color 0.15s ease-in-out;
        }
        
        .search-mobile-btn:hover {
            background-color: var(--bs-secondary-bg);
            color: var(--bs-nav-link-hover-color);
        }
    </style>
    
    <!-- Global dark-mode background fix: ensure a single uniform page background and
         make page-level layout containers transparent so the body background shows
         through. This prevents multi-band background artifacts when dark-mode is active. -->
    <style id="dark-mode-global-fix">
        /* Force a single solid background color for dark mode (applies early via inline style) */
        html.dark-mode, body.dark-mode {
            background-color: #0b0b0d !important;
            background-image: none !important;
            color: #e6e6e6 !important;
        }

        /* Allow page content containers to be transparent so the body background is visible
           (preserve topbar and sidebar glass surfaces so they keep their intended appearance). */
        html.dark-mode main,
        html.dark-mode footer,
        html.dark-mode .container,
        html.dark-mode .with-sidebar .container {
            background: transparent !important;
            background-image: none !important;
        }

        /* If any stylesheet injected a full-width background gradient on body > * elements,
           make them transparent in dark mode to avoid stacked bands. */
        html.dark-mode > body > *,
        body.dark-mode > * {
            background-image: none !important;
        }

        /* Tweak sidebar active indicator for dark mode: use a subtle neutral tint instead of vivid primary
           so the thin left bar doesn't appear as a harsh blue. Also hide the left bar when the sidebar is
           collapsed (it overlaps centered icons). */
        .dark-mode .sidebar .nav-link.active::before {
            background: rgba(255,255,255,0.10) !important;
            box-shadow: none !important;
        }

        /* When the sidebar is collapsed, remove the left indicator and center icons to avoid overlap */
        body.with-sidebar.sidebar-collapsed .sidebar .nav-link.active::before {
            display: none !important;
        }

        /* Ensure icon-only links are centered when collapsed and maintain a consistent icon width */
        body.with-sidebar.sidebar-collapsed .sidebar .nav-link {
            justify-content: center !important;
            padding-left: 0.25rem !important;
            padding-right: 0.25rem !important;
        }

        body.with-sidebar.sidebar-collapsed .sidebar .nav-link i {
            width: 28px !important;
            text-align: center !important;
            display: inline-block !important;
        }

        /* Center collapsed icons and the brand tile reliably.
           Instead of nudging individual icons, make the brand anchor a full-width
           flex container and center its contents; remove transforms so icon centering
           is predictable across browsers. */
        body.with-sidebar.sidebar-collapsed .sidebar .nav-link {
            justify-content: center !important;
            padding-left: 0.15rem !important;
            padding-right: 0.15rem !important;
        }

        body.with-sidebar.sidebar-collapsed .sidebar .nav-link i {
            width: 28px !important;
            text-align: center !important;
            display: inline-block !important;
            transform: none !important;
            margin: 0 !important;
        }

        /* Make the brand/anchor span the full width and center the brand-logo tile */
        body.with-sidebar.sidebar-collapsed .sidebar .sidebar-header .brand,
        body.with-sidebar.sidebar-collapsed .sidebar .brand {
            width: 100% !important;
            display: flex !important;
            justify-content: center !important;
            align-items: center !important;
            padding-left: 0 !important;
            padding-right: 0 !important;
        }

        body.with-sidebar.sidebar-collapsed .sidebar .brand-logo,
        body.with-sidebar.sidebar-collapsed .sidebar .sidebar-header .brand-logo {
            margin: 0 !important;
            width: 44px !important;
            height: 44px !important;
            padding: 4px !important;
            display: flex !important;
            align-items: center !important;
            justify-content: center !important;
        }

        body.with-sidebar.sidebar-collapsed .sidebar .brand-logo .brand-icon {
            font-size: 1.15rem !important;
            line-height: 1 !important;
        }

        /* Hide brand text and sub-labels when collapsed so only the icon shows */
        body.with-sidebar.sidebar-collapsed .sidebar .brand-info,
        body.with-sidebar.sidebar-collapsed .sidebar .brand-text,
        body.with-sidebar.sidebar-collapsed .sidebar .brand-sub {
            display: none !important;
        }

        /* Ensure nav link text is hidden and icons are perfectly centered in collapsed state */
        body.with-sidebar.sidebar-collapsed .sidebar .nav-link span,
        body.with-sidebar.sidebar-collapsed .sidebar .nav-link .nav-label {
            display: none !important;
            width: 0 !important;
            opacity: 0 !important;
        }

        body.with-sidebar.sidebar-collapsed .sidebar .nav-link {
            justify-content: center !important;
            padding-top: .5rem !important;
            padding-bottom: .5rem !important;
            padding-left: 0 !important;
            padding-right: 0 !important;
        }

        body.with-sidebar.sidebar-collapsed .sidebar .nav-link i {
            margin: 0 auto !important;
            display: inline-block !important;
            transform: none !important;
            left: auto !important;
        }

        /* Remove browser/blue focus ring on nav links and use a very subtle visible focus state for keyboard users */
        .sidebar .nav-link:focus { outline: none !important; box-shadow: none !important; }
        .sidebar .nav-link:focus-visible { outline: 2px solid rgba(255,255,255,0.06) !important; outline-offset: 2px !important; }
    </style>

    {% block head %}{% endblock %}
</head>
{# If an endpoint wants to render without the global chrome (topbar/sidebar)
    it can pass `no_chrome=True` in the template context (auth pages do this).
    When true we omit the sidebar/topbar helper classes so related JS/CSS
    won't add overlays or offsets on mobile which can cause tap/click
    coordinate mismatches. #}
<body class="d-flex flex-column h-100 modern-layout {% if not no_chrome %}with-sidebar topbar-fixed{% endif %} {% if liquid_glass_buttons_enabled %}liquid-glass-buttons{% endif %}">
    <!-- Global Top Bar (search + user) -->
    <div class="topbar glass navbar-glass d-flex align-items-center gap-2 px-3 py-2 shadow-sm" role="banner">
        <div class="d-flex align-items-center gap-2 flex-shrink-0">
            <button id="sidebarToggle" class="btn btn-outline-primary btn-sm rounded-pill-soft" aria-label="Toggle navigation"><i class="fas fa-bars"></i></button>
        </div>
        {% if current_user.is_authenticated %}
        <div class="top-search d-none d-sm-block">
            <form method="GET" action="{{ url_for('search.search_page') }}" class="position-relative" role="search" aria-label="Global search">
                <div class="enhanced-search-container w-100">
                    <div class="search-input-wrapper">
                        <i class="fas fa-search search-icon"></i>
                        <input type="text" class="form-control enhanced-search-input" name="q" placeholder="Search" id="quickSearchInputTop" autocomplete="off" aria-label="Search teams and users" aria-expanded="false" role="combobox">
                        <button type="button" class="search-clear-btn initially-hidden" id="searchClearBtnTop" aria-label="Clear search">
                            <i class="fas fa-times"></i>
                        </button>
                        <button class="search-submit-btn" type="submit" title="Search" aria-label="Submit search">
                            <i class="fas fa-arrow-right"></i>
                        </button>
                    </div>
                    <div id="searchSuggestionsTop" class="enhanced-search-suggestions" role="listbox" aria-label="Search suggestions"></div>
                </div>
            </form>
        </div>
        {# Mobile search button removed; navbar searchbar is present #}
        {% endif %}
        <!-- User dropdown and notifications -->
        <div class="ms-auto d-flex align-items-center flex-shrink-0 navbar-actions">
            {% if current_user.is_authenticated %}
                <div class="d-flex align-items-center">
                    <!-- Notifications dropdown -->
                    <div class="dropdown me-2 topbar-notifications">
                        <button id="notificationsToggle" class="btn btn-outline-secondary btn-sm rounded-pill-soft d-flex align-items-center dropdown-toggle" type="button" data-bs-toggle="dropdown" aria-expanded="false" aria-haspopup="true" aria-controls="notificationsMenu" aria-label="Notifications">
                            <i class="fas fa-bell"></i>
                            <span id="notificationsBadge" class="badge bg-danger ms-1 initially-hidden badge-small">0</span>
                        </button>
                        <div id="notificationsMenu" class="dropdown-menu dropdown-menu-end shadow notifications-dropdown" aria-labelledby="notificationsToggle">
                            <div class="dropdown-header d-flex align-items-center justify-content-between px-3 py-2">
                                <strong>Notifications</strong>
                                <button id="clearAllNotificationsBtn" class="btn btn-sm btn-link small" title="Clear all">Clear all</button>
                            </div>
                            <div id="notificationsList" class="list-group list-group-flush notifications-list">
                                <div class="list-group-item text-muted small">Loading...</div>
                            </div>
                            <div class="dropdown-footer text-center py-2">
                                <a href="{{ url_for('main.chat_page') }}" class="small">Open chat</a>
                            </div>
                        </div>
                    </div>
                    <div class="dropdown">
                        <button id="userToggle" class="btn btn-outline-primary btn-sm rounded-pill-soft d-flex align-items-center dropdown-toggle" type="button" data-bs-toggle="dropdown" aria-expanded="false" aria-haspopup="true" aria-controls="userMenu">
                            <i class="fas fa-user-circle me-1"></i>
                            <span class="d-none d-md-inline">{{ current_user.username }}</span>
                            <span id="userChatDot" class="user-chat-dot initially-hidden" title="You have unread chat messages"></span>
                        </button>
                        <ul id="userMenu" class="dropdown-menu dropdown-menu-end shadow notifications-dropdown navbar-glass" aria-labelledby="userToggle">
                            <li id="userDropdownUnreadItem" class="initially-hidden"><a id="openUnreadChatLink" class="dropdown-item py-2" href="{{ url_for('main.chat_page') }}"><i class="fas fa-comments me-2 text-danger"></i>Open unread chat</a></li>
                            <li><hr class="dropdown-divider my-1"></li>
                            <li>
                                <div class="dropdown-user-header d-flex align-items-center px-3 py-2">
                                    <div class="me-2">
                                        <i class="fas fa-user-circle fa-2x"></i>
                                    </div>
                                    <div class="flex-grow-1">
                                        <div class="user-name fw-semibold">{{ current_user.username or 'User' }}</div>
                                        <div class="user-roles text-muted small">
                                            {% for role in current_user.roles %}
                                                <span class="badge bg-secondary text-uppercase me-1">{{ role.name }}</span>
                                            {% else %}
                                                <span class="text-muted">No roles</span>
                                            {% endfor %}
                                        </div>
                                    </div>
                                </div>
                            </li>
                            <li><hr class="dropdown-divider my-1"></li>
                            <li><a class="dropdown-item py-2" href="{{ url_for('auth.profile') }}"><i class="fas fa-user-edit me-2 text-primary"></i>Profile</a></li>
                            {% if user_has_role('admin') or user_has_role('analytics') %}
                            <li><a class="dropdown-item py-2 {% if request.endpoint == 'main.config' %}active{% endif %}" href="{{ url_for('main.config') }}"><i class="fas fa-wrench me-2 text-primary"></i>Game Configuration</a></li>
                            {% endif %}
                            {% if user_has_role('superadmin') %}
                            <li><a class="dropdown-item py-2" href="{{ url_for('db_admin.database_status') }}"><i class="fas fa-database me-2 text-success"></i>Database Admin</a></li>
                            {% endif %}
                            <li><hr class="dropdown-divider my-1"></li>
                            <li><a class="dropdown-item py-2 text-danger" href="{{ url_for('auth.logout') }}"><i class="fas fa-sign-out-alt me-2"></i>Logout</a></li>
                        </ul>
                    </div>
                </div>
            {% else %}
            <a href="{{ url_for('auth.login') }}" class="btn btn-primary btn-sm">Login</a>
            {% endif %}
        </div>
    </div>

    <!-- Sidebar -->
    <aside id="appSidebar" class="sidebar glass" role="navigation" aria-label="Main sidebar">
        <div class="sidebar-header d-flex align-items-center justify-content-between">
            <a class="brand d-flex align-items-center text-decoration-none" href="{% if user_has_role('scout') and not user_has_role('admin') and not user_has_role('analytics') %}{{ url_for('scouting.index') }}{% else %}{{ url_for('main.index') }}{% endif %}">
                <div class="brand-logo d-flex align-items-center justify-content-center me-2" role="img" aria-label="ObsidianScout logo" tabindex="0">
                    <!-- Use the original FontAwesome clipboard icon inside the round tile -->
                    <i class="fas fa-clipboard brand-icon" aria-hidden="true"></i>
                </div>
                <div class="brand-info d-flex flex-column">
                    <span class="brand-text fw-bold"><span class="obsidian-gradient">Obsidian</span>Scout</span>
                    <small class="brand-sub text-muted">Modern FRC Scouting</small>
                </div>
            </a>
            <button id="sidebarClose" class="btn btn-outline-secondary btn-close-sidebar text-muted d-lg-none" aria-label="Close sidebar">
                <i class="fas fa-times" aria-hidden="true"></i>
                <span class="visually-hidden">Close sidebar</span>
            </button>
        </div>
    {# Removed quick search from sidebar (now in top bar) #}
        <nav class="sidebar-nav flex-grow-1" aria-label="Main navigation">
            {% if current_user.is_authenticated %}
            {% if user_has_role('superadmin') %}
            <div class="nav-group" id="group-superadmin">
                <button class="nav-group-title btn btn-toggle" aria-expanded="true" aria-controls="group-superadmin-items" data-group="group-superadmin">
                    Super Admin <i class="fas fa-chevron-down group-chevron ms-2" aria-hidden="true"></i>
                </button>
                <div class="nav-group-items" id="group-superadmin-items">
                    <a class="nav-link {% if request.endpoint == 'auth.manage_users' %}active{% endif %}" href="{{ url_for('auth.manage_users') }}"><i class="fas fa-user-shield"></i><span>Manage Users</span></a>
                    <a class="nav-link {% if request.endpoint == 'auth.add_user' %}active{% endif %}" href="{{ url_for('auth.add_user') }}"><i class="fas fa-user-plus"></i><span>Add User</span></a>
                    <a class="nav-link {% if request.endpoint == 'auth.manage_site_notifications' %}active{% endif %}" href="{{ url_for('auth.manage_site_notifications') }}"><i class="fas fa-bell"></i><span>Manage Notifications</span></a>
                </div>
            </div>
            {% endif %}
            {# Administration nav-group removed on request #}
            <div class="nav-group" id="group-core">
                <button class="nav-group-title btn btn-toggle" aria-expanded="true" aria-controls="group-core-items" data-group="group-core">
                    Core <i class="fas fa-chevron-down group-chevron ms-2" aria-hidden="true"></i>
                </button>
                <div class="nav-group-items" id="group-core-items">
                {% if not (user_has_role('scout') and not user_has_role('admin') and not user_has_role('analytics')) %}
                <a class="nav-link {% if request.endpoint == 'main.index' %}active{% endif %}" href="{{ url_for('main.index') }}"><i class="fas fa-home"></i><span>Dashboard</span></a>
                {% endif %}
                <a class="nav-link {% if request.endpoint == 'scouting.index' %}active{% endif %}" href="{{ url_for('scouting.index') }}"><i class="fas fa-clipboard"></i><span>Scouting Dashboard</span></a>
                <a class="nav-link {% if request.endpoint == 'scouting.scouting_form' %}active{% endif %}" href="{{ url_for('scouting.scouting_form') }}"><i class="fas fa-rocket"></i><span>Start Scouting</span></a>
                <a class="nav-link {% if request.endpoint == 'pit_scouting.index' %}active{% endif %}" href="{{ url_for('pit_scouting.index') }}"><i class="fas fa-wrench"></i><span>Pit Scouting</span></a>
                <a class="nav-link {% if request.endpoint and request.endpoint.startswith('scouting_alliances') %}active{% endif %}" href="{{ url_for('scouting_alliances.dashboard') }}"><i class="fas fa-users"></i><span>Scouting Alliances</span></a>
                <a class="nav-link {% if request.endpoint == 'scouting.list_data' %}active{% endif %}" href="{{ url_for('scouting.list_data') }}"><i class="fas fa-list"></i><span>All Data</span></a>
                <a class="nav-link {% if request.endpoint == 'scouting.view_text_elements' %}active{% endif %}" href="{{ url_for('scouting.view_text_elements') }}"><i class="fas fa-comment-alt"></i><span>Text Elements</span></a>
                </div>
            </div>
            {% if user_has_role('admin') or user_has_role('analytics') %}
            <div class="nav-group" id="group-analytics">
                <button class="nav-group-title btn btn-toggle" aria-expanded="true" aria-controls="group-analytics-items" data-group="group-analytics">
                    Analytics <i class="fas fa-chevron-down group-chevron ms-2" aria-hidden="true"></i>
                </button>
                <div class="nav-group-items" id="group-analytics-items">
                <a class="nav-link {% if request.endpoint and request.endpoint.startswith('teams') and request.endpoint != 'teams.ranks' %}active{% endif %}" href="{{ url_for('teams.index') }}"><i class="fas fa-users"></i><span>Teams</span></a>
                <a class="nav-link {% if request.endpoint == 'main.analytics_config_averages' %}active{% endif %}" href="{{ url_for('main.analytics_config_averages') }}"><i class="fas fa-calculator"></i><span>Config Averages</span></a>
                <a class="nav-link {% if request.endpoint == 'teams.ranks' %}active{% endif %}" href="{{ url_for('teams.ranks') }}"><i class="fas fa-list-ol"></i><span>Team Rankings</span></a>
                <a class="nav-link {% if request.endpoint == 'matches.index' %}active{% endif %}" href="{{ url_for('matches.index') }}"><i class="fas fa-gamepad"></i><span>Matches</span></a>
                <a class="nav-link {% if request.endpoint and request.endpoint.startswith('alliances') %}active{% endif %}" href="{{ url_for('alliances.index') }}"><i class="fas fa-handshake"></i><span>Alliance Selection</span></a>
                {# Main graphs link: treat as active for graphs pages except the dedicated side-by-side comparison page #}
                <a class="nav-link {% if request.endpoint and request.endpoint.startswith('graphs') and not request.endpoint.startswith('graphs.side_by_side') %}active{% endif %}" href="{{ url_for('graphs.index') }}"><i class="fas fa-chart-line"></i><span>Graphs</span></a>
                {# Comparison (side-by-side) link: match the actual endpoint name using underscore #}
                <a class="nav-link {% if request.endpoint and request.endpoint.startswith('graphs.side_by_side') %}active{% endif %}" href="{{ url_for('graphs.side_by_side') }}"><i class="fas fa-columns"></i><span>Comparison</span></a>
                <a class="nav-link {% if request.endpoint == 'main.analytics_config_averages' %}active{% endif %}" href="{{ url_for('main.analytics_config_averages') }}"><i class="fas fa-calculator"></i><span>Config Averages</span></a>
                <a class="nav-link {% if request.endpoint and request.endpoint.startswith('graphs.pages') %}active{% endif %}" href="{{ url_for('graphs.pages_index') }}"><i class="fas fa-file-alt"></i><span>Custom Pages</span></a>
                <a class="nav-link {% if request.endpoint == 'matches.strategy' %}active{% endif %}" href="{{ url_for('matches.strategy') }}"><i class="fas fa-chess"></i><span>Strategy</span></a>
                <a class="nav-link {% if request.endpoint == 'matches.strategy_all' %}active{% endif %}" href="{{ url_for('matches.strategy_all') }}"><i class="fas fa-th-large"></i><span>Strategy  All Matches</span></a>
                <a class="nav-link {% if request.endpoint == 'matches.strategy_draw' %}active{% endif %}" href="{{ url_for('matches.strategy_draw') }}"><i class="fas fa-pen-ruler"></i><span>Strategy Draw</span></a>
                <a class="nav-link {% if request.endpoint == 'matches.strategy_live' %}active{% endif %}" href="{{ url_for('matches.strategy_live') }}"><i class="fas fa-broadcast-tower"></i><span>Live Strategy</span></a>
                <a class="nav-link {% if request.endpoint == 'graphs.my_shares' %}active{% endif %}" href="{{ url_for('graphs.my_shares') }}"><i class="fas fa-share-alt"></i><span>My Graph Shares</span></a>
                    <a class="nav-link {% if request.endpoint == 'teams.my_ranks_shares' %}active{% endif %}" href="{{ url_for('teams.my_ranks_shares') }}"><i class="fas fa-trophy"></i><span>My Ranking Shares</span></a>
                <a class="nav-link {% if request.endpoint and request.endpoint.startswith('team_trends') %}active{% endif %}" href="{{ url_for('team_trends.index') }}"><i class="fas fa-chart-line"></i><span>Trends</span></a>
                <a class="nav-link {% if request.endpoint and request.endpoint.startswith('data') %}active{% endif %}" href="{{ url_for('data.index') }}"><i class="fas fa-database"></i><span>Data</span></a>
                <a class="nav-link {% if request.endpoint and request.endpoint.startswith('simulations') %}active{% endif %}" href="{{ url_for('simulations.index') }}"><i class="fas fa-dice"></i><span>Simulations</span></a>
                </div>
            </div>
            {% endif %}
            <div class="nav-group" id="group-community">
                <button class="nav-group-title btn btn-toggle" aria-expanded="true" aria-controls="group-community-items" data-group="group-community">
                    Community <i class="fas fa-chevron-down group-chevron ms-2" aria-hidden="true"></i>
                </button>
                <div class="nav-group-items" id="group-community-items">
                <a class="nav-link {% if request.endpoint == 'main.users_page' %}active{% endif %}" href="{{ url_for('main.users_page') }}"><i class="fas fa-users"></i><span>Users</span></a>
                <a class="nav-link {% if request.endpoint == 'main.chat_page' %}active{% endif %}" href="{{ url_for('main.chat_page') }}"><i class="fas fa-comments"></i><span>Chat <span id="chatUnreadBadge" class="badge bg-danger ms-1 initially-hidden badge-small">0</span></span></a>
                <a class="nav-link {% if request.endpoint and request.endpoint.startswith('assistant') %}active{% endif %}" href="{{ url_for('assistant.index') }}"><i class="fas fa-robot"></i><span>Assistant</span></a>
                <a class="nav-link {% if request.endpoint == 'notifications.index' %}active{% endif %}" href="{{ url_for('notifications.index') }}"><i class="fas fa-bell"></i><span>Notifications</span></a>
                <a class="nav-link {% if request.endpoint == 'main.sponsors' %}active{% endif %}" href="{{ url_for('main.sponsors') }}"><i class="fas fa-handshake"></i><span>Sponsors</span></a>
                <a class="nav-link {% if request.endpoint == 'graphs.scout_leaderboard' %}active{% endif %}" href="{{ url_for('graphs.scout_leaderboard') }}"><i class="fas fa-medal"></i><span>Scout Leaderboard</span></a>
                </div>
            </div>
            <div class="nav-group" id="group-help">
                <button class="nav-group-title btn btn-toggle" aria-expanded="true" aria-controls="group-help-items" data-group="group-help">
                    Help <i class="fas fa-chevron-down group-chevron ms-2" aria-hidden="true"></i>
                </button>
                <div class="nav-group-items" id="group-help-items">
                <a class="nav-link {% if request.endpoint == 'main.help_page' %}active{% endif %}" href="{{ url_for('main.help_page') }}"><i class="fas fa-book"></i><span>Documentation</span></a>
                <a class="nav-link {% if request.endpoint and request.endpoint.startswith('setup') %}active{% endif %}" href="{{ url_for('setup.index') }}"><i class="fas fa-graduation-cap"></i><span>Setup & Tutorial</span></a>
                </div>
            </div>
            {% endif %}
        </nav>
        {% if current_user.is_authenticated %}
        <div class="sidebar-footer mt-auto">
            <div class="user-mini d-flex align-items-center mb-2">
                <i class="fas fa-user-circle me-2 fs-4"></i>
                <div class="flex-grow-1">
                    <div class="fw-semibold small">{{ current_user.username }}</div>
                    <div class="text-muted tiny">
                        {% for role in current_user.roles %}
                            <span class="badge bg-secondary text-uppercase me-1 mb-1">{{ role.name }}</span>
                        {% endfor %}
                    </div>
                </div>
            </div>
                <div class="d-flex flex-column gap-2">
                {% if user_has_role('admin') %}
                <a class="btn btn-outline-primary btn-sm w-100 text-start {% if request.endpoint == 'auth.admin_settings' %}active{% endif %}" href="{{ url_for('auth.admin_settings') }}"><i class="fas fa-cog me-2"></i>Admin Settings</a>
                {% endif %}
                {% if user_has_role('admin') or user_has_role('analytics') %}
                <a class="btn btn-outline-primary btn-sm w-100 text-start {% if request.endpoint == 'main.config' %}active{% endif %}" href="{{ url_for('main.config') }}"><i class="fas fa-wrench me-2"></i>Game Config</a>
                {% endif %}
                <!-- Per-user settings (stored locally in the browser) -->
                <a class="btn btn-outline-primary btn-sm w-100 text-start {% if request.endpoint == 'main.settings' %}active{% endif %}" href="{{ url_for('main.settings') }}"><i class="fas fa-cog me-2"></i>Settings</a>
                <!-- Theme Settings removed: theme management is handled client-side -->
                <button id="darkModeButton" class="btn btn-outline-secondary btn-sm rounded-pill-soft w-100 text-start" type="button">
                    <i class="fas fa-moon me-2" id="darkModeIcon"></i><span id="darkModeLabel">Dark Mode</span>
                </button>
                {% if user_has_role('superadmin') %}
                <a class="btn btn-outline-secondary btn-sm w-100 text-start" href="{{ url_for('db_admin.database_status') }}"><i class="fas fa-database me-2"></i>DB Admin</a>
                {% endif %}
                <a class="btn btn-outline-danger btn-sm w-100 text-start" href="{{ url_for('auth.logout') }}"><i class="fas fa-sign-out-alt me-2"></i>Logout</a>
            </div>
        </div>
        {% endif %}
    </aside>

    <script>
    // Sidebar toggle logic (mobile overlay + desktop collapse)
    (function(){
        const sidebar = document.getElementById('appSidebar');
        const toggle = document.getElementById('sidebarToggle');
        const closeBtn = document.getElementById('sidebarClose');
        const body = document.body;
        let _scrollPosition = 0;

        // Use an overlay to absorb touch/scroll events when sidebar is open on mobile.
        // This avoids fixing body position which on some devices can clip fixed children.
            function lockBodyScroll(){
                _scrollPosition = window.scrollY || document.documentElement.scrollTop || 0;

                // Prevent background scrolling while sidebar is open
                document.documentElement.style.overflow = 'hidden';
                document.body.style.overflow = 'hidden';

                // Add a transparent overlay that captures touch and click events outside the sidebar
                let overlay = document.getElementById('sidebarBackdropOverlay');
                if(!overlay){
                    overlay = document.createElement('div');
                    overlay.id = 'sidebarBackdropOverlay';
                    overlay.style.position = 'fixed';
                    overlay.style.inset = '0';
                    overlay.style.zIndex = '1035';
                    overlay.style.background = 'transparent';
                    overlay.style.touchAction = 'none';
                    overlay.addEventListener('touchmove', function(e){ e.preventDefault(); }, { passive: false });
                    overlay.addEventListener('click', function(){ closeSidebar(); });
                    document.body.appendChild(overlay);
                }

                // Ensure sidebar can scroll smoothly on iOS
                if(sidebar) {
                    sidebar.style['-webkit-overflow-scrolling'] = 'touch';
                }
            }
        function unlockBodyScroll(){
                const overlay = document.getElementById('sidebarBackdropOverlay');
                if(overlay && overlay.parentNode) overlay.parentNode.removeChild(overlay);

                document.documentElement.style.overflow = '';
                document.body.style.overflow = '';
                // Restore scroll position (use safe helper to cooperate with stabilizer)
                try {
                    if (typeof window.safeRestoreScroll === 'function') {
                        window.safeRestoreScroll(_scrollPosition || 0, { behavior: 'auto', timeout: 350 });
                    } else {
                        try { if (window.safeRestoreScroll && typeof window.safeRestoreScroll === 'function') { window.safeRestoreScroll(_scrollPosition || 0, { behavior: 'auto', timeout: 300 }); } else { window.scrollTo(0, _scrollPosition || 0); } } catch(e) {}
                    }
                } catch (e) { /* ignore */ }
            }

        // Sidebar open/close with localStorage persistence for desktop
        const SIDEBAR_STORAGE_KEY = 'obsidian_sidebar_collapsed';

        function isDesktop() { return window.innerWidth >= 992; }

        function setSidebarCollapsed(collapsed) {
            if (collapsed) {
                document.body.classList.add('sidebar-collapsed');
            } else {
                document.body.classList.remove('sidebar-collapsed');
            }
            try { localStorage.setItem(SIDEBAR_STORAGE_KEY, collapsed ? '1' : '0'); } catch(e){}

            // Notify other parts of the UI and force layout recalculation.
            try { document.dispatchEvent(new CustomEvent('obsidian:sidebar:toggled')); } catch (e) {}

            // Attempt immediate recalculation (RAF) and trigger a resize event so
            // third-party widgets that listen for resize update their layout.
            try {
                window.requestAnimationFrame(function(){
                    try { if (window.applySidebarMargin) window.applySidebarMargin(); } catch(e){}
                    try { window.dispatchEvent(new Event('resize')); } catch(e){}
                });
                // Fallback after transition end
                window.setTimeout(function(){ try { if (window.applySidebarMargin) window.applySidebarMargin(); window.dispatchEvent(new Event('resize')); } catch(e){} }, 360);
            } catch (e) { /* ignore */ }
        }

        function getStoredSidebarCollapsed() {
            try { return localStorage.getItem(SIDEBAR_STORAGE_KEY) === '1'; } catch(e){ return null; }
        }

        function openSidebar(){
            if(!isDesktop()){
                sidebar.classList.add('open');
                body.classList.add('sidebar-open');
                lockBodyScroll();
                try {
                    document.dispatchEvent(new CustomEvent('obsidian:sidebar:toggled'));
                    window.requestAnimationFrame(function(){ try{ if(window.applySidebarMargin) window.applySidebarMargin(); window.dispatchEvent(new Event('resize')); }catch(e){} });
                    window.setTimeout(function(){ try{ if(window.applySidebarMargin) window.applySidebarMargin(); window.dispatchEvent(new Event('resize')); }catch(e){} }, 360);
                } catch(e) {}
            } else {
                setSidebarCollapsed(false);
            }
            if(toggle) toggle.setAttribute('aria-expanded','true');
        }

        function closeSidebar(){
            if(!isDesktop()){
                sidebar.classList.remove('open');
                body.classList.remove('sidebar-open');
                try { unlockBodyScroll(); } catch(e){}
                try {
                    document.dispatchEvent(new CustomEvent('obsidian:sidebar:toggled'));
                    window.requestAnimationFrame(function(){ try{ if(window.applySidebarMargin) window.applySidebarMargin(); window.dispatchEvent(new Event('resize')); }catch(e){} });
                    window.setTimeout(function(){ try{ if(window.applySidebarMargin) window.applySidebarMargin(); window.dispatchEvent(new Event('resize')); }catch(e){} }, 360);
                } catch(e) {}
            } else {
                setSidebarCollapsed(true);
            }
            if(toggle) toggle.setAttribute('aria-expanded','false');
        }

        function toggleSidebar(){
            if(!isDesktop()){
                if(sidebar.classList.contains('open')){ closeSidebar(); } else { openSidebar(); }
            } else {
                // desktop: toggle collapse state
                const collapsed = document.body.classList.contains('sidebar-collapsed');
                setSidebarCollapsed(!collapsed);
            }
        }

        if(toggle){
            toggle.setAttribute('aria-controls','appSidebar');
            toggle.setAttribute('aria-expanded','true');
            toggle.addEventListener('click', (e)=>{ e.preventDefault(); toggleSidebar(); });
        }

        // Apply stored state on load (desktop only)
        (function applyStoredSidebarState(){
            const stored = getStoredSidebarCollapsed();
            if (stored === null) return; // no preference stored
            if (isDesktop()) {
                setSidebarCollapsed(stored);
            } else {
                // if mobile, ensure collapsed flag is reflected but don't force open/close overlay
                if (stored) document.body.classList.add('sidebar-collapsed');
            }
        })();

        if(closeBtn){ closeBtn.addEventListener('click', (e)=>{ e.preventDefault(); closeSidebar(); }); }

        // Nav link click (mobile)
        if (sidebar) {
            sidebar.querySelectorAll('a.nav-link').forEach(a=>{
                a.addEventListener('click', ()=>{ if(window.innerWidth < 992) closeSidebar(); });
            });
        }

        // Outside click (mobile)
        document.addEventListener('click', (e)=>{
            if(window.innerWidth >= 992) return;
            if(!sidebar.contains(e.target) && !(toggle && toggle.contains(e.target))) closeSidebar();
        });

        // Esc key
        document.addEventListener('keydown', (e)=>{ if(e.key==='Escape'){ if(window.innerWidth < 992 && sidebar.classList.contains('open')) closeSidebar(); }});

        // Initialize desktop state: respect stored preference if present
        if (window.innerWidth >= 992) {
            try {
                const stored = getStoredSidebarCollapsed();
                if (stored === null) {
                    // No preference stored: default to expanded
                    body.classList.remove('sidebar-collapsed');
                } else {
                    // Apply stored preference
                    setSidebarCollapsed(stored);
                }
            } catch (e) {
                // Fallback: ensure sidebar is expanded
                body.classList.remove('sidebar-collapsed');
            }
        }

        window.addEventListener('resize', ()=>{
            if(window.innerWidth >= 992){
                sidebar.classList.remove('open');
                body.classList.remove('sidebar-open');
                try { unlockBodyScroll(); } catch(e){}
            } else {
                body.classList.remove('sidebar-collapsed');
            }
        });

        // Re-apply stored sidebar state when resizing across breakpoint
        let lastWasDesktop = window.innerWidth >= 992;
        window.addEventListener('resize', function() {
            const nowDesktop = window.innerWidth >= 992;
            if (nowDesktop !== lastWasDesktop) {
                // crossed breakpoint
                const stored = getStoredSidebarCollapsed();
                if (stored !== null) {
                    if (nowDesktop) setSidebarCollapsed(stored);
                    else document.body.classList.remove('sidebar-collapsed');
                }
            }
            lastWasDesktop = nowDesktop;
        });

        // Safety: Ensure the sidebar remains scrollable on desktop. In some
        // edge cases (for example after an overlay was added on mobile or if
        // an exception prevented cleanup) the global overflow style can be
        // left set to 'hidden', which hides scrollbars and prevents reaching
        // footer controls. Clear any stale overflow and remove leftover
        // mobile overlay when on desktop viewports.
        (function ensureSidebarScrollOnDesktop(){
            function ensure(){
                try {
                    if (window.innerWidth >= 992) {
                        // Remove any accidental global overflow that prevents page or
                        // sidebar scrolling.
                        if (document.documentElement.style.overflow === 'hidden' || document.body.style.overflow === 'hidden'){
                            document.documentElement.style.overflow = '';
                            document.body.style.overflow = '';
                        }
                        // Remove the mobile backdrop overlay if it was left behind
                        var overlay = document.getElementById('sidebarBackdropOverlay');
                        if (overlay && overlay.parentNode) overlay.parentNode.removeChild(overlay);
                        // Ensure sidebar has native scrolling enabled
                        var sb = document.getElementById('appSidebar');
                        if (sb) sb.style.overflowY = 'auto';
                    }
                } catch(e){ /* non-fatal */ }
            }
            if (document.readyState === 'loading') document.addEventListener('DOMContentLoaded', ensure); else ensure();
            window.addEventListener('resize', function(){ try{ ensure(); } catch(e){} });
        })();

        // Avoid repositioning fixed dropdowns while page scrolls; only reposition if user opens a dropdown or resizes
        let lastScrollY = window.scrollY;
        window.addEventListener('scroll', function() {
            // If any topbar dropdown menu is positioned fixed, don't adjust its position on scroll
            const fixedMenus = document.querySelectorAll('.topbar .dropdown-menu');
            let hasFixed = false;
            fixedMenus.forEach(menu => {
                if (getComputedStyle(menu).position === 'fixed' && menu.classList.contains('show')) hasFixed = true;
            });
            if (hasFixed) {
                // nothing to do while scrolling
                lastScrollY = window.scrollY;
                return;
            }

            // If no fixed menus, allow repositioning logic for dropdowns that rely on normal flow
            // (for example on desktop navbar dropdowns not positioned fixed)
            lastScrollY = window.scrollY;
        });
    })();
    </script>
    <script>
    // Populate data-label attributes on sidebar nav links for collapsed hover tooltips
    (function(){
        const sidebar = document.getElementById('appSidebar');
        function setNavLabels(){
            if(!sidebar) return;
            const links = sidebar.querySelectorAll('a.nav-link');
            links.forEach(a=>{
                const label = a.querySelector('span') ? a.querySelector('span').textContent.trim() : a.textContent.trim();
                if(label) a.setAttribute('data-label', label);
            });
        }
        setNavLabels();
        // Update labels if window resizes or user toggles sidebar
        window.addEventListener('resize', setNavLabels);
        document.addEventListener('obsidian:sidebar:toggled', setNavLabels);
        // Also hook into existing toggle button to dispatch an event for other listeners
        const toggle = document.getElementById('sidebarToggle');
        if(toggle) toggle.addEventListener('click', ()=>{ setTimeout(()=>{ document.dispatchEvent(new CustomEvent('obsidian:sidebar:toggled')); }, 250); });
    })();
    </script>
    <style>
    /* Tooltip-like labels when sidebar is collapsed (lightweight, non-JS fallback via title is also applied) */
    .sidebar-collapsed .sidebar-nav a.nav-link {
        position: relative;
        padding-left: 0.75rem; /* compact spacing when collapsed */
    }
    .sidebar-collapsed .sidebar-nav a.nav-link::after {
        content: attr(data-label);
        position: absolute;
        left: 100%;
        margin-left: 8px;
        top: 50%;
        transform: translateY(-50%);
        background: var(--bs-body-bg);
        border: 1px solid var(--bs-border-color);
        padding: 6px 8px;
        border-radius: 6px;
        white-space: nowrap;
        box-shadow: 0 2px 8px rgba(0,0,0,0.12);
        display: none;
        z-index: 2000;
        font-size: 0.85rem;
    }
    .sidebar-collapsed .sidebar-nav a.nav-link:hover::after,
    .sidebar-collapsed .sidebar-nav a.nav-link:focus::after {
        display: block;
    }
    /* Slightly emphasize active link for better contrast */
    .sidebar .nav-link.active {
        background: linear-gradient(90deg, rgba(var(--bs-primary-rgb),0.06), transparent);
        border-radius: 6px;
    }
    </style>

    <script>
    // Accessibility helpers for sidebar: set aria-current on active links,
    // provide title attributes and keep the toggle button's pressed state in sync.
    document.addEventListener('DOMContentLoaded', function(){
        const sidebar = document.getElementById('appSidebar');
        const toggle = document.getElementById('sidebarToggle');

        function refreshSidebarA11y(){
            if(!sidebar) return;
            const collapsed = document.body.classList.contains('sidebar-collapsed');

            // Update toggle pressed/expanded states
            if(toggle){
                try{ toggle.setAttribute('aria-pressed', collapsed ? 'true' : 'false'); }catch(e){}
                try{ toggle.setAttribute('aria-expanded', (!collapsed && window.innerWidth >= 992) ? 'true' : 'false'); }catch(e){}
            }

            // Update links: aria-current for screen readers and title for hover fallback
            sidebar.querySelectorAll('a.nav-link').forEach(a=>{
                if(a.classList.contains('active')){
                    a.setAttribute('aria-current','page');
                } else {
                    a.removeAttribute('aria-current');
                }
                // Keep a pragmatic title attribute so tooltip works on platforms without CSS support
                const lbl = a.getAttribute('data-label');
                if(lbl) a.setAttribute('title', lbl);
            });
        }

        refreshSidebarA11y();
        document.addEventListener('obsidian:sidebar:toggled', refreshSidebarA11y);
        window.addEventListener('resize', refreshSidebarA11y);
    });
    </script>
    <script>
    // Sidebar nav-group collapse/expand behavior with simple persistence
    (function(){
        const GROUP_KEY = 'obsidian_sidebar_groups';
        function loadState(){ try{ const v = localStorage.getItem(GROUP_KEY); return v ? JSON.parse(v) : {}; }catch(e){ return {}; } }
        function saveState(state){ try{ localStorage.setItem(GROUP_KEY, JSON.stringify(state)); }catch(e){} }

        const state = loadState();
        document.querySelectorAll('.btn-toggle[data-group]').forEach(btn=>{
            const group = btn.getAttribute('data-group');
            const items = document.getElementById(group + '-items');
            if(!items) return;
            // initialize from state
            const open = (state[group] === undefined) ? true : !!state[group];
            btn.setAttribute('aria-expanded', open? 'true' : 'false');
            if(!open) items.classList.add('collapsed');

            btn.addEventListener('click', ()=>{
                const expanded = btn.getAttribute('aria-expanded') === 'true';
                btn.setAttribute('aria-expanded', expanded ? 'false' : 'true');
                items.classList.toggle('collapsed');
                state[group] = !expanded;
                saveState(state);
            });

            // keyboard accessibility: toggle on Enter/Space
            btn.addEventListener('keydown', (e)=>{
                if(e.key === 'Enter' || e.key === ' ') { e.preventDefault(); btn.click(); }
            });
        });
    })();
    </script>
    {# Embedded site-wide notification banner placed directly under the navbar #}
    {% include '_notification_banner.html' %}

    <div class="toast-container position-fixed top-0 end-0 p-3">
        {% with messages = get_flashed_messages(with_categories=true) %}
            {% if messages %}
                {% for category, message in messages %}
                    {# Normalize category values so templates can rely on Bootstrap color classes #}
                    {% set normalized = category %}
                    {# Map common non-Bootstrap category names to Bootstrap classes #}
                    {% if not category or category == 'message' or category == 'info' or category == 'regular' or category == 'normal' %}
                        {% set normalized = 'success' %}
                    {% elif category == 'error' or category == 'err' %}
                        {% set normalized = 'danger' %}
                    {% elif category == 'warn' or category == 'warning' %}
                        {% set normalized = 'warning' %}
                    {% endif %}

                    <div class="toast show" role="alert" aria-live="assertive" aria-atomic="true">
                        <div class="toast-header bg-{{ normalized }}{% if normalized in ['danger', 'success', 'primary'] %} text-white{% endif %}">
                            <i class="fas {% if normalized == 'success' %}fa-check-circle{% elif normalized == 'danger' %}fa-exclamation-triangle{% elif normalized == 'warning' %}fa-exclamation-circle{% else %}fa-info-circle{% endif %} me-2"></i>
                            <strong class="me-auto">Notification</strong>
                            <small>Just now</small>
                            <button type="button" class="btn-close {% if normalized in ['danger', 'success', 'primary'] %}btn-close-white{% endif %}" data-bs-dismiss="toast" aria-label="Close"></button>
                        </div>
                        <div class="toast-body">
                            {{ message }}
                        </div>
                    </div>
                {% endfor %}
            {% endif %}
        {% endwith %}
    </div>

    {% block breadcrumb %}{% endblock %}

    <main class="flex-shrink-0 py-4">
        <div class="container">
            {% block content %}{% endblock %}
        </div>
    </main>

    <footer class="footer mt-auto py-3">
        <div class="container">
            <div class="row align-items-center g-2">
                {# If we're on the login page, center a single-brand label and hide the right column. #}
                <div class="{% if request.endpoint == 'auth.login' %}col-12 text-center{% else %}col-md-6 text-center text-md-start{% endif %}">
                    <div class="d-flex align-items-center justify-content-center {% if request.endpoint != 'auth.login' %}justify-content-md-start{% endif %}">
                        <i class="fas fa-clipboard brand-icon me-2 text-primary"></i>
                        <span class="fw-bold">ObsidianScout</span>
                        {# On normal pages show a subtle secondary label; hide it on the login page to avoid duplication. #}
                        {% if request.endpoint != 'auth.login' %}
                        <span class="text-muted mx-2"></span>
                        <span class="small text-muted">ObsidianScout</span>
                        {% endif %}
                    </div>
                </div>

                {% if request.endpoint != 'auth.login' %}
                <div class="col-md-6 text-center text-md-end">
                    <div class="small text-muted">
                        {% if game_config %}
                        <span>{{ game_config.game_name }} {{ game_config.season }}</span>
                        {% else %}
                        <span>No active configuration</span>
                        {% endif %}
                    </div>
                <!--<div class="mt-2">
                        <a href="https://www.paypal.com" target="_blank" rel="noopener" class="btn btn-sm btn-warning d-inline-flex align-items-center">
                            <i class="fas fa-heart me-1"></i> Donate(Not yet available)
                        </a>
                    </div> -->
                </div>
                {% endif %}
            </div>
        </div>
    </footer>

    <div id="loading-overlay" class="d-none">
        <div class="spinner-container">
            <div class="spinner-border text-primary" role="status">
                <span class="visually-hidden">Loading...</span>
            </div>
            <div class="mt-2">Loading...</div>
        </div>
    </div>

    <script src="{{ url_for('static', filename='js/vendor/jquery-3.7.1.min.js') }}"></script>
    <script>
        // Enhanced jQuery loading check with timeout
        (function() {
            let retryCount = 0;
            const maxRetries = 5;
            const checkInterval = 100; // 100ms
            
            function checkJQuery() {
                if (typeof jQuery !== 'undefined' && typeof $ !== 'undefined') {
                    console.log('jQuery loaded successfully');
                    return true;
                }
                
                retryCount++;
                if (retryCount < maxRetries) {
                    setTimeout(checkJQuery, checkInterval);
                } else {
                    // Final fallback - load jQuery synchronously
                    console.warn('jQuery failed to load from CDNs, loading local fallback');
                    const script = document.createElement('script');
                    // Fallback now points to local vendor file for offline use
                    script.src = '{{ url_for('static', filename='js/vendor/jquery-3.7.1.min.js') }}';
                    script.integrity = 'sha384-1H217gwSVyLSIfaLxHbE7dRb3v4mYCKbpQvzx0cegeju1MVsGrX5xXxAvs/HgeFs';
                    script.crossOrigin = 'anonymous';
                    document.head.appendChild(script);
                    
                    script.onload = function() {
                        console.log('jQuery loaded from fallback CDN');
                    };
                    
                    script.onerror = function() {
                        console.error('All jQuery CDNs failed to load');
                        alert('jQuery failed to load from all sources. Please check your internet connection and refresh the page.');
                    };
                }
                return false;
            }
            
            // Start checking after a short delay
            setTimeout(checkJQuery, 50);
        })();
    </script>
    
    <script src="{{ url_for('static', filename='js/vendor/bootstrap.bundle.min.js') }}"></script>
    
    <script src="{{ url_for('static', filename='js/vendor/select2.min.js') }}"></script>
    
    <script src="{{ url_for('static', filename='js/select2-mobile-fix.js') }}"></script>
    
    <script src="{{ url_for('static', filename='js/vendor/plotly-latest.min.js') }}"></script>
    
    <script src="{{ url_for('static', filename='js/vendor/socket.io.js') }}"></script>
    
    <script src="{{ url_for('static', filename='js/qrcode.min.js') }}"></script>
    
    <!-- Gentle Mobile Scroll Protection -->
    <script>
    (function() {
        'use strict';
        
    // Treat narrow screens and tall portrait screens (height > width and tall) as "mobile-like"
    const isMobile = window.innerWidth <= 768 || /Android|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
    const isPortraitTall = (window.innerHeight > window.innerWidth) && (window.innerHeight >= 900);

    // If not mobile and not a tall portrait device, skip this gentle protection.
    if (!isMobile && !isPortraitTall) return;
        
        console.log('Gentle mobile scroll protection active');
        
        let isInteracting = false;
        let lastScrollY = 0;
        
        // Track scroll position when not interacting
        function updateScrollPosition() {
            if (!isInteracting) {
                lastScrollY = window.pageYOffset || document.documentElement.scrollTop || 0;
            }
        }
        
        // Gentle protection only for obvious scroll-to-top jumps
        function preventScrollToTop() {
            const currentScrollY = window.pageYOffset || document.documentElement.scrollTop || 0;
            
            // Only intervene if scroll jumped to exactly 0 from a significant position
            if (currentScrollY === 0 && lastScrollY > 100) {
                console.log('Preventing scroll-to-top jump');
                // Use smooth scroll to restore position
                window.scrollTo({
                    top: lastScrollY,
                    behavior: 'smooth'
                });
            }
        }
        
        // Very gentle click protection
        function handleInteraction(e) {
            // Only protect problematic elements
            const problematic = e.target.matches('a[href="#"], a[href=""], button[type="button"]:not([data-bs-toggle])');
            
            if (problematic) {
                isInteracting = true;
                
                // Single check after a short delay
                setTimeout(() => {
                    preventScrollToTop();
                    isInteracting = false;
                    updateScrollPosition();
                }, 50);
            }
        }
        
        // Add minimal event listeners
        document.addEventListener('click', handleInteraction, { passive: true });
        window.addEventListener('scroll', updateScrollPosition, { passive: true });
        
        // Initialize
        updateScrollPosition();
        
    })();
    </script>
    
    <script src="{{ url_for('static', filename='js/scripts.js') }}"></script>
    <script src="{{ url_for('static', filename='js/topbar-notifications.js') }}"></script>
    
    <script>
        document.addEventListener('DOMContentLoaded', function() {
            // Global helper: perform a scroll restore while cooperating with the
            // mobile viewport stabilizer. This sets the stabilizer suppression
            // flag briefly so the stabilizer doesn't fight legitimate restores.
            window.safeRestoreScroll = function(y, opts) {
                try { if (!opts) opts = {}; } catch(e) { opts = {}; }
                try { window.__suppressMobileScrollJumps = true; } catch (e) {}
                const behavior = opts.behavior || 'auto';
                // Use requestAnimationFrame so layout has settled before scrolling
                window.requestAnimationFrame(() => {
                    try {
                        window.scrollTo({ top: (y || 0), behavior: behavior });
                    } catch (err) {
                        try { if (window.safeRestoreScroll && typeof window.safeRestoreScroll === 'function') { window.safeRestoreScroll((y || 0), { behavior: 'auto', timeout: 350 }); } else { window.scrollTo(0, (y || 0)); } } catch(e) {}
                    }
                    // Remove suppression after a short timeout; caller may override
                    setTimeout(() => { try { window.__suppressMobileScrollJumps = false; } catch(e) {} }, opts.timeout || 350);
                });
            };
            
            // Initialize mobile protection (guard in case the function isn't present)
            if (typeof initializeMobileScrollProtection === 'function') {
                initializeMobileScrollProtection();
            }
            
            // ===============================
            // GLOBAL SELECT2 MOBILE ENHANCEMENT
            // ===============================
            
            // Apply mobile fixes to any existing Select2 dropdowns
            setTimeout(() => {
                if (typeof window.initSelect2Mobile === 'function') {
                    // Re-initialize any existing Select2 instances with mobile fixes
                    $('.select2-hidden-accessible').each(function() {
                        const $this = $(this);
                        const currentOptions = $this.data('select2') ? $this.data('select2').options.options : {};
                        
                        // Get existing configuration
                        const existingConfig = {
                            placeholder: currentOptions.placeholder || 'Select...',
                            allowClear: currentOptions.allowClear || false,
                            closeOnSelect: currentOptions.closeOnSelect !== false,
                            theme: currentOptions.theme || 'bootstrap-5',
                            width: currentOptions.width || '100%'
                        };
                        
                        // Only re-initialize if on mobile and not already mobile-enhanced
                        if (window.innerWidth <= 900 && !$this.hasClass('mobile-enhanced')) {
                            try {
                                $this.addClass('mobile-enhanced');
                                window.initSelect2Mobile($this, existingConfig);
                                console.log('Enhanced Select2 dropdown for mobile:', $this.attr('id') || $this.attr('name'));
                            } catch (e) {
                                console.warn('Failed to enhance Select2 for mobile:', e);
                            }
                        }
                    });
                }
            }, 200);
            
            // Dark mode button logic
            const darkModeBtn = document.getElementById('darkModeButton');
            const body = document.body;
            const prefersDarkMode = window.matchMedia('(prefers-color-scheme: dark)').matches;
            const storedPreference = localStorage.getItem('darkMode');
            const darkModeIcon = document.getElementById('darkModeIcon');
            const darkModeLabel = document.getElementById('darkModeLabel');
            const isDarkMode = storedPreference !== null ? storedPreference === 'true' : prefersDarkMode;
            function applyState(on){
                try {
                    const htmlEl = document.documentElement;
                    if (on) {
                        body.classList.add('dark-mode');
                        htmlEl.classList.add('dark-mode');
                        if(darkModeIcon){darkModeIcon.classList.remove('fa-moon');darkModeIcon.classList.add('fa-sun');}
                        if(darkModeLabel){darkModeLabel.textContent='Light Mode';}
                    } else {
                        body.classList.remove('dark-mode');
                        htmlEl.classList.remove('dark-mode');
                        if(darkModeIcon){darkModeIcon.classList.remove('fa-sun');darkModeIcon.classList.add('fa-moon');}
                        if(darkModeLabel){darkModeLabel.textContent='Dark Mode';}
                    }
                } catch (e) {
                    // Keep this non-fatal - don't block page if DOM is unusual
                    try { if (on) body.classList.add('dark-mode'); else body.classList.remove('dark-mode'); } catch(e2){}
                }
            }
            applyState(isDarkMode);

            // Apply rounded UI preference
            try {
                const roundedStored = localStorage.getItem('rounded_ui');
                const isRounded = roundedStored !== null ? roundedStored === 'true' : false; // default to disabled
                if (isRounded) { document.body.classList.add('rounded-ui'); document.documentElement.classList.add('rounded-ui'); }
                else { document.body.classList.remove('rounded-ui'); document.documentElement.classList.remove('rounded-ui'); }
            } catch(e) { /* ignore */ }
            // Also apply navbar theme stored preference
            try{
                const navbarStored = localStorage.getItem('navbar_theme');
                const navVal = navbarStored !== null ? navbarStored : 'neutral';
                document.body.classList.remove('nav-theme-primary','nav-theme-neutral','nav-theme-indigo','nav-theme-green');
                document.documentElement.classList.remove('nav-theme-primary','nav-theme-neutral','nav-theme-indigo','nav-theme-green');
                document.body.classList.add('nav-theme-' + navVal);
                document.documentElement.classList.add('nav-theme-' + navVal);
            }catch(e){}
            
            // Server-side theme management was removed; rely on client preference (localStorage) only.
            
            if(darkModeBtn){
                darkModeBtn.addEventListener('click', ()=>{
                    const now = !body.classList.contains('dark-mode');
                    localStorage.setItem('darkMode', now ? 'true':'false');
                    // Keep both html and body in sync so early loaded scripts and observers react
                    try { if (now) { document.documentElement.classList.add('dark-mode'); } else { document.documentElement.classList.remove('dark-mode'); } } catch(e) {}
                    applyState(now);

                    // Persist only locally; no server-side theme endpoints are available.
                });
            }
            // System preference changes only if user hasn't chosen
            window.matchMedia('(prefers-color-scheme: dark)').addEventListener('change', e => {
                if (localStorage.getItem('darkMode') === null) {
                    applyState(e.matches);
                }
            });

            // Keep liquid glass per-user preference in sync across tabs
            window.addEventListener('storage', function(e){
                try {
                    if (e.key !== 'liquid_glass_buttons') return;
                    if (e.newValue === 'true') {
                        document.documentElement.classList.add('liquid-glass-buttons');
                        document.body.classList.add('liquid-glass-buttons');
                        return;
                    }
                    if (e.newValue === 'false') {
                        document.documentElement.classList.remove('liquid-glass-buttons');
                        document.body.classList.remove('liquid-glass-buttons');
                        return;
                    }
                    // e.newValue === null (preference removed): fall back to server default
                    var serverAllowsFallback = (window.__server_liquid_glass_allowed === true || window.__server_liquid_glass_allowed === 'true');
                    if (!serverAllowsFallback) {
                        document.documentElement.classList.remove('liquid-glass-buttons');
                        document.body.classList.remove('liquid-glass-buttons');
                    }
                } catch (err) { /* ignore storage sync errors */ }
            });
            
            // Initialize toasts
            var toastElList = document.querySelectorAll('.toast');
            Array.from(toastElList).map(function (toastEl) {
                return new bootstrap.Toast(toastEl, {
                    autohide: true,
                    delay: 5000
                });
            });
        });
    </script>
    
    <!-- Dark mode handlers -->
    <script src="{{ url_for('static', filename='js/dark-mode-handlers.js') }}"></script>
    
    <!-- Team-number display preference helper (client-side, per-user) -->
    <script>
    (function(){
        // Expose a global helper to apply the user's display preference.
        // Preference key: 'display_offseason_preference' -> '99xx' | 'letter'
        // Enhancements:
        // - Cache remap per-session
        // - Immediately apply numeric->numeric restore without needing fetch
        // - Observe DOM mutations so dynamically inserted elements are handled
        // - Provide a setter helper to change the preference and apply immediately

        window._teamRemapCache = window._teamRemapCache || {};

        async function fetchRemap(eventKey){
            if(!eventKey) return {};
            if(window._teamRemapCache[eventKey]) return window._teamRemapCache[eventKey];
            try{
                // Normalize to a TBA event key (year + code) if caller passed only an event code
                let tbaKey = String(eventKey || '').trim();
                if(!/^\d{4}/.test(tbaKey)){
                    // Try to get year from GAME_CONFIG (season or year), otherwise use current year
                    const year = (window.GAME_CONFIG && (window.GAME_CONFIG.season || window.GAME_CONFIG.year)) ? (window.GAME_CONFIG.season || window.GAME_CONFIG.year) : (new Date()).getFullYear();
                    tbaKey = String(year) + tbaKey.toLowerCase();
                }

                // Try localStorage first (persisted remaps)
                try{
                    const lsKey = 'team_remap_' + tbaKey;
                    const rawLs = localStorage.getItem(lsKey);
                    if(rawLs){
                        try{
                            const parsed = JSON.parse(rawLs);
                            if(parsed && typeof parsed === 'object'){
                                window._teamRemapCache[eventKey] = parsed;
                                if(tbaKey !== eventKey) window._teamRemapCache[tbaKey] = parsed;
                                return parsed;
                            }
                        }catch(e){}
                    }
                }catch(e){}

                const resp = await fetch('/api/event-remap/' + encodeURIComponent(tbaKey), { credentials: 'same-origin' });
                if(!resp.ok) return {};
                const data = await resp.json();
                const raw = (data && data.remap) ? data.remap : {};
                // Server returns mapping letter->numeric (e.g., {'581B': 9989}). Invert to numeric->letter for fast lookup.
                const map = {};
                try{
                    Object.keys(raw).forEach(k => {
                        try{
                            const v = raw[k];
                            if(v !== null && v !== undefined){
                                map[String(v)] = String(k).toUpperCase();
                            }
                        }catch(e){}
                    });
                }catch(e){}

                // Cache in-memory
                window._teamRemapCache[eventKey] = map;
                if(tbaKey !== eventKey) window._teamRemapCache[tbaKey] = map;
                // Persist to localStorage for offline/reload use
                try{
                    const lsKeyOut = 'team_remap_' + tbaKey;
                    localStorage.setItem(lsKeyOut, JSON.stringify(map));
                }catch(e){/* ignore storage errors */}
                return map;
            }catch(e){
                console.warn('fetchRemap failed', e);
                return {};
            }
        }

        async function applyPreferenceToElement(el, map, pref){
            try{
                const num = el.getAttribute('data-team-num') || (el.textContent && el.textContent.trim());
                if(!num) return;

                const key = String(num);
                const letter = (map && map[key]) ? map[key] : null;

                if(pref === 'letter'){
                    // show letter if available, else numeric
                    el.textContent = letter || num;
                    return;
                }

                if(pref === 'both'){
                    // show numeric and parenthesized letter if available
                    if(letter){
                        el.textContent = `${num} (${letter})`;
                    } else {
                        el.textContent = num;
                    }
                    return;
                }

                // default: '99xx' or unknown -> numeric only
                el.textContent = num;
            }catch(e){ /* ignore per-element errors */ }
        }

        async function applyTeamNumberDisplayPreferenceImpl(){
            try{
                let pref = '99xx';
                try{ pref = localStorage.getItem('display_offseason_preference') || '99xx'; }catch(e){ pref = '99xx'; }

                const eventKey = (window.GAME_CONFIG && window.GAME_CONFIG.current_event_code) ? window.GAME_CONFIG.current_event_code : null;
                let map = {};
                // fetch remap when user asked for letter-style or 'both' display
                if((pref === 'letter' || pref === 'both') && eventKey){
                    map = await fetchRemap(eventKey);
                }

                // Always update existing elements immediately
                const els = Array.from(document.querySelectorAll('.team-number'));
                // For each element, determine the eventKey (per-element overrides global)
                await Promise.all(els.map(async (el) => {
                    try{
                        const localEventKey = el.getAttribute('data-event-key') || eventKey || null;
                        let localMap = {};
                        if((pref === 'letter' || pref === 'both') && localEventKey){
                            localMap = await fetchRemap(localEventKey);
                        }
                        await applyPreferenceToElement(el, localMap, pref);
                    }catch(e){ /* ignore per-element errors */ }
                }));

                // Update native <select> option labels for team-selects so pickers show the chosen format
                try{
                    const selects = Array.from(document.querySelectorAll('select'));
                    await Promise.all(selects.map(async (sel) => {
                        try{
                            // Determine if select looks like a team select: option dataset.teamNumber or select name/id
                            let looksLikeTeam = false;
                            for(let i=0;i<sel.options.length;i++){
                                const o = sel.options[i];
                                if(o && o.dataset && o.dataset.teamNumber){ looksLikeTeam = true; break; }
                            }
                            const nm = (sel.name||'').toLowerCase(); const id = (sel.id||'').toLowerCase();
                            if(!looksLikeTeam && !(nm.includes('team') || id.includes('team'))) return;

                            const localEventKey = sel.getAttribute('data-event-key') || eventKey || null;
                            let localMap = {};
                            if((pref === 'letter' || pref === 'both') && localEventKey){
                                localMap = await fetchRemap(localEventKey);
                            }

                            // Update each option's visible text
                            for(let i=0;i<sel.options.length;i++){
                                try{
                                    const opt = sel.options[i];
                                    const num = opt.dataset && opt.dataset.teamNumber ? String(opt.dataset.teamNumber) : (opt.textContent||'').trim().split(' ')[0];
                                    const name = opt.dataset && opt.dataset.teamName ? opt.dataset.teamName : (opt.textContent||'').split('-').slice(1).join('-').trim();
                                    let letter = (localMap && localMap[num]) ? localMap[num] : null;
                                    // If we couldn't fetch a per-event remap (page may not expose eventKey),
                                    // try to find a cached remap in the in-memory cache so previously-fetched
                                    // remaps still allow letter display on other pages.
                                    if(!letter){
                                        try{
                                            const cache = window._teamRemapCache || {};
                                            for(const k in cache){
                                                if(cache[k] && cache[k][num]){ letter = cache[k][num]; break; }
                                            }
                                        }catch(e){}
                                    }
                                    // Last-resort: check persisted localStorage remaps
                                    if(!letter){
                                        try{
                                            for(let i=0;i<localStorage.length;i++){
                                                const key = localStorage.key(i);
                                                if(!key || !key.startsWith('team_remap_')) continue;
                                                try{
                                                    const parsed = JSON.parse(localStorage.getItem(key));
                                                    if(parsed && parsed[num]){ letter = parsed[num]; break; }
                                                }catch(e){}
                                            }
                                        }catch(e){}
                                    }

                                    if(pref === 'letter'){
                                        if(num){ opt.textContent = (letter || num) + (name ? (' - ' + name) : ''); }
                                        else { /* leave */ }
                                    } else if(pref === 'both'){
                                        if(num){ opt.textContent = num + (letter ? (' ('+letter+')') : '') + (name ? (' - ' + name) : ''); }
                                    } else {
                                        if(num){ opt.textContent = num + (name ? (' - ' + name) : ''); }
                                    }
                                }catch(e){}
                            }

                        }catch(e){}
                    }));
                }catch(e){/* ignore select label updates on old browsers */}
            }catch(e){ console.warn('applyTeamNumberDisplayPreference error', e); }
        }

        // Public API
        window.applyTeamNumberDisplayPreference = applyTeamNumberDisplayPreferenceImpl;

        // Setter to update preference and apply immediately without reload or resync
        window.setTeamNumberDisplayPreference = function(pref){
            try{
                // Accept explicit values: '99xx', 'letter', 'both'
                if(!['99xx','letter','both'].includes(pref)) pref = '99xx';
                localStorage.setItem('display_offseason_preference', pref);
                // apply locally immediately
                try{ if (typeof window.applyTeamNumberDisplayPreference === 'function') window.applyTeamNumberDisplayPreference(); } catch(e){}
                // Also broadcast storage event for other tabs
                try{ window.dispatchEvent(new StorageEvent('storage', { key: 'display_offseason_preference', newValue: pref })); } catch(e){ /* some browsers restrict constructing StorageEvent; fallback */
                    try{ localStorage.setItem('display_offseason_preference', pref); }catch(e){}
                }
            }catch(e){ console.warn('setTeamNumberDisplayPreference error', e); }
        };

        // Apply on DOM ready
        if(document.readyState === 'loading') document.addEventListener('DOMContentLoaded', function(){ window.applyTeamNumberDisplayPreference(); }); else window.applyTeamNumberDisplayPreference();

        // React to storage changes (other tabs)
        window.addEventListener('storage', function(e){
            if(e.key === 'display_offseason_preference') window.applyTeamNumberDisplayPreference();
        });

        // Observe DOM for new elements with class .team-number so dynamically added content updates
        const observer = new MutationObserver((mutations) => {
            let found = false;
            mutations.forEach(m => {
                m.addedNodes && m.addedNodes.forEach(node => {
                    if(node.nodeType !== 1) return;
                    if(node.classList && node.classList.contains('team-number')) found = true;
                    else if(node.querySelector && node.querySelector('.team-number')) found = true;
                });
            });
            if(found){
                // Re-apply; small debounce
                if(window._applyTeamNumberDebounce) clearTimeout(window._applyTeamNumberDebounce);
                window._applyTeamNumberDebounce = setTimeout(() => { try{ window.applyTeamNumberDisplayPreference(); }catch(e){} }, 60);
            }
        });
        try{ observer.observe(document.body, { childList: true, subtree: true }); }catch(e){ /* ignore if body not available */ }

    })();
    </script>

        <!-- Select mapping helper: add adjacent mapped display for native <select> elements with team options -->
        <script>
        (function(){
            // Debounce helper
            function debounce(fn, wait){ let t; return function(){ clearTimeout(t); t = setTimeout(() => fn.apply(this, arguments), wait); }; }

            function isTeamSelect(sel){
                try{
                    // Heuristic: any option with data-team-number attribute
                    for(let i=0;i<sel.options.length;i++){
                        if(sel.options[i].dataset && sel.options[i].dataset.teamNumber) return true;
                    }
                    // fallback: name or id contains 'team' or 'team_id'
                    const nm = (sel.name||'').toLowerCase();
                    const id = (sel.id||'').toLowerCase();
                    if(nm.includes('team') || id.includes('team')) return true;
                }catch(e){}
                return false;
            }

            function createOrGetMappedDisplay(sel){
                // Prefer a sibling element with class select-mapped-display
                let container = sel.parentNode;
                if(!container) return null;
                let span = container.querySelector('.select-mapped-display');
                if(span) return span;

                span = document.createElement('div');
                span.className = 'select-mapped-display team-number';
                // Keep it inline and visually adjacent by default; templates may override with CSS
                span.style.display = 'inline-block';
                span.style.marginLeft = '0.5rem';
                // Insert after the select
                if(sel.nextSibling) container.insertBefore(span, sel.nextSibling); else container.appendChild(span);
                return span;
            }

            function updateMappedDisplayForSelect(sel){
                try{
                    const span = createOrGetMappedDisplay(sel);
                    if(!span) return;
                    const opt = sel.options[sel.selectedIndex] || null;
                    let num = '';
                    if(opt){
                        num = opt.dataset && opt.dataset.teamNumber ? opt.dataset.teamNumber : (opt.textContent || '').trim().split(' ')[0];
                    }
                    if(!num) { span.textContent = ''; span.removeAttribute('data-team-num'); return; }
                    span.setAttribute('data-team-num', String(num));
                    // Let the central mapper apply formatting for consistency
                    if(typeof window.applyTeamNumberDisplayPreference === 'function'){
                        // apply to this single element by calling the global re-apply (debounced)
                        window.applyTeamNumberDisplayPreference();
                    }
                }catch(e){ /* ignore */ }
            }

            function attachToSelect(sel){
                try{
                    if(sel.__mappedDisplayAttached) return;
                    sel.addEventListener('change', function(){ updateMappedDisplayForSelect(sel); });
                    // initialize now
                    updateMappedDisplayForSelect(sel);
                    sel.__mappedDisplayAttached = true;
                }catch(e){ /* ignore */ }
            }

            function scanAndAttach(){
                try{
                    document.querySelectorAll('select').forEach(sel => {
                        try{
                            if(isTeamSelect(sel)) attachToSelect(sel);
                        }catch(e){}
                    });
                }catch(e){}
            }

            // Initial scan on DOM ready
            if(document.readyState === 'loading') document.addEventListener('DOMContentLoaded', scanAndAttach); else scanAndAttach();

            // Observe additions to attach to dynamically inserted selects
            const selObserver = new MutationObserver(debounce((mutations) => {
                let found = false;
                mutations.forEach(m => {
                    m.addedNodes && m.addedNodes.forEach(node => {
                        if(node.nodeType !== 1) return;
                        if(node.tagName === 'SELECT') { found = true; attachToSelect(node); }
                        else if(node.querySelector && node.querySelector('select')) { found = true; scanAndAttach(); }
                    });
                });
                if(found){ try{ if(window._applyTeamNumberDebounce) clearTimeout(window._applyTeamNumberDebounce); window._applyTeamNumberDebounce = setTimeout(() => { try{ window.applyTeamNumberDisplayPreference(); }catch(e){} }, 60); }catch(e){}
            }, 60));

            try{ selObserver.observe(document.body, { childList: true, subtree: true }); }catch(e){}

            // Also re-run when preference changes (storage event will trigger global mapper, but ensure our selects have spans)
            window.addEventListener('storage', function(e){ if(e.key === 'display_offseason_preference') scanAndAttach(); });
        })();
        </script>

    
    {% block scripts %}{% endblock %}
    {% block extra_js %}{% endblock %}

    <script>
    // Ensure service worker is registered at root (/sw.js) so PWABuilder and other tools can detect it
    if ('serviceWorker' in navigator) {
    navigator.serviceWorker.register('/sw.js', { scope: '/' })
            .then(reg => {
                console.log('SW root registered:', reg.scope);
                // Force update check
                reg.update();
            })
            .catch(err => console.warn('SW root registration failed:', err));
    }

    // Reposition any portalled dropdowns on scroll/resize/mousewheel to prevent visual drift
    (function addPortalledRepositionHandler(){
        let pending = false;
        function repositionPortalled() {
            pending = false;
            // Find any portalled menus
            document.querySelectorAll('.dropdown-menu.navbar-glass').forEach(menu => {
                try {
                    if (!menu.__isPortalled || !menu.__portalToggle) return;
                    positionFixedDropdown(menu.__portalToggle, menu);
                } catch(e) { /* ignore */ }
            });
        }

        function scheduleReposition() {
            if (pending) return;
            pending = true;
            window.requestAnimationFrame(repositionPortalled);
        }

        // Listen to scroll, wheel and touchmove for robust repositioning
        window.addEventListener('scroll', scheduleReposition, { passive: true });
        window.addEventListener('wheel', scheduleReposition, { passive: true });
        window.addEventListener('touchmove', scheduleReposition, { passive: true });
        window.addEventListener('resize', scheduleReposition);
    })();
    </script>

    <!-- Temporary debug shim: intercept scrollTo to capture unexpected jumps to top on tall portrait screens -->
    <script>
    (function(){
        try {
            const isPortraitTall = (window.innerHeight > window.innerWidth) && (window.innerHeight >= 900);
            if (!isPortraitTall) return; // only active for the environment where you reported the bug

            window.__scrollJumpLogs = window.__scrollJumpLogs || [];

            const origScrollTo = window.scrollTo.bind(window);
            let lastUserClickY = null;

            // Track recent clicks
            document.addEventListener('click', function(e){
                try { lastUserClickY = window.pageYOffset || document.documentElement.scrollTop || 0; } catch(e) { lastUserClickY = null; }
                // expire after short time
                setTimeout(function(){ lastUserClickY = null; }, 700);
            }, true);

            window.scrollTo = function(){
                try {
                    // Normalize arguments
                    let targetY = null;
                    if (arguments.length === 1 && typeof arguments[0] === 'object' && arguments[0] !== null) {
                        targetY = arguments[0].top != null ? arguments[0].top : (arguments[0].left != null ? arguments[0].left : null);
                    } else if (arguments.length >= 2) {
                        // scrollTo(x, y)
                        targetY = arguments[1];
                    }

                    // If a call is trying to jump to the very top (0) shortly after a user click
                    if (targetY === 0 && lastUserClickY && lastUserClickY > 50) {
                        const entry = {
                            time: Date.now(),
                            beforeY: lastUserClickY,
                            stack: (new Error('scrollTo captured')).stack,
                            args: Array.prototype.slice.call(arguments)
                        };
                        window.__scrollJumpLogs.push(entry);
                        // Print brief warning so you can observe in console if present
                        console.warn('Captured scrollTo(0) after user click  recorded to window.__scrollJumpLogs (first 3 chars of stack):', (entry.stack||'').slice(0,120));
                        // Still perform the original call so behavior is unchanged while debugging
                        return origScrollTo.apply(window, arguments);
                    }
                } catch (err) {
                    // ignore errors in debug shim
                }
                return origScrollTo.apply(window, arguments);
            };
            console.log('Scroll debug shim active for tall-portrait screens  logs available at window.__scrollJumpLogs');
        } catch(e) { /* ignore */ }
    })();
    </script>

    <!-- Extra debug instrumentation: focus, history, and hashchange logging (temporary) -->
    <script>
    (function(){
        try {
            const isPortraitTall = (window.innerHeight > window.innerWidth) && (window.innerHeight >= 900);
            if (!isPortraitTall) return;

            window.__scrollActionLogs = window.__scrollActionLogs || [];

            // Wrap the current focus implementation (don't clobber earlier production wrapper)
            const currentFocus = HTMLElement.prototype.focus;
            HTMLElement.prototype.focus = function(options){
                let beforeY = window.pageYOffset || document.documentElement.scrollTop || 0;
                try {
                    // Call whatever focus implementation is present (production wrapper or native)
                    return currentFocus.call(this, options);
                } finally {
                    // Check shortly after focus whether the page was moved to top
                    setTimeout(() => {
                        try {
                            const afterY = window.pageYOffset || document.documentElement.scrollTop || 0;
                            if (afterY === 0 && beforeY > 50) {
                                const entry = { type: 'focus', tag: this && this.tagName, beforeY, time: Date.now(), stack: (new Error('focus captured')).stack };
                                window.__scrollActionLogs.push(entry);
                                console.warn('Debug: focus caused scroll-to-top; entry recorded in window.__scrollActionLogs (focus)');
                            }
                        } catch(e) {}
                    }, 40);
                }
            };

            // Wrap history methods to detect scroll changes after push/replace
            ['pushState','replaceState'].forEach(function(name){
                try {
                    const orig = history[name];
                    history[name] = function(){
                        const beforeY = window.pageYOffset || document.documentElement.scrollTop || 0;
                        const res = orig.apply(history, arguments);
                        setTimeout(() => {
                            try {
                                const afterY = window.pageYOffset || document.documentElement.scrollTop || 0;
                                if (afterY === 0 && beforeY > 50) {
                                    const entry = { type: name, args: Array.prototype.slice.call(arguments), beforeY, time: Date.now(), stack: (new Error(name+' captured')).stack };
                                    window.__scrollActionLogs.push(entry);
                                    console.warn('Debug: history.'+name+' caused scroll-to-top; entry recorded in window.__scrollActionLogs');
                                }
                            } catch(e) {}
                        }, 30);
                        return res;
                    };
                } catch(e) { /* ignore */ }
            });

            // Hashchange listener
            window.addEventListener('hashchange', function(e){
                try {
                    const beforeY = window.__lastUserScrollBeforeHash || 0;
                    const afterY = window.pageYOffset || document.documentElement.scrollTop || 0;
                    if (afterY === 0 && beforeY > 50) {
                        const entry = { type: 'hashchange', beforeY, time: Date.now(), stack: (new Error('hashchange captured')).stack };
                        window.__scrollActionLogs.push(entry);
                        console.warn('Debug: hashchange caused scroll-to-top; entry recorded in window.__scrollActionLogs');
                    }
                } catch(e) {}
            }, true);

            // Track last scroll position before clicks (helps hashchange detection)
            document.addEventListener('click', function(){
                try { window.__lastUserScrollBeforeHash = window.pageYOffset || document.documentElement.scrollTop || 0; } catch(e) { window.__lastUserScrollBeforeHash = 0; }
                setTimeout(function(){ window.__lastUserScrollBeforeHash = 0; }, 700);
            }, true);

            console.log('Extra scroll/focus/history debug instrumentation active  logs available at window.__scrollActionLogs');
        } catch(e) { /* ignore */ }
    })();
    </script>

    <!-- Aggressive click watcher: detect sudden jump-to-top after clicks and restore previous scroll Y -->
    <script>
    (function(){
        try {
            const isPortraitTall = (window.innerHeight > window.innerWidth) && (window.innerHeight >= 900);
            if (!isPortraitTall) return;

            // Keep a short history of recent restores so we don't loop
            window.__recentAutoRestores = window.__recentAutoRestores || [];

            document.addEventListener('click', function(ev){
                try {
                    const beforeY = window.pageYOffset || document.documentElement.scrollTop || 0;
                    // Only watch if user was scrolled down a bit
                    if (!beforeY || beforeY <= 30) return;

                    let rafCount = 0;
                    const maxRafs = 20; // watch for a short period (~20 frames)

                    function checkFrame(){
                        rafCount++;
                        const nowY = window.pageYOffset || document.documentElement.scrollTop || 0;
                        // If it jumped to top (or nearly top) restore immediately
                        if ((nowY === 0 || Math.abs(nowY) <= 2) && beforeY > 30) {
                            // Avoid rapidly re-restoring the same Y repeatedly
                            const last = window.__recentAutoRestores[window.__recentAutoRestores.length - 1] || {};
                            if (last.y === beforeY && (Date.now() - (last.t || 0) < 1000)) {
                                return; // recently restored same position
                            }

                            // Log with stacktrace
                            const trace = (new Error('auto-restore')).stack;
                            window.__scrollJumpLogs = window.__scrollJumpLogs || [];
                            window.__scrollJumpLogs.push({ time: Date.now(), beforeY, afterY: nowY, stack: trace, cause: 'auto-restore-after-click' });
                            window.__recentAutoRestores.push({ t: Date.now(), y: beforeY });
                            if (window.__recentAutoRestores.length > 10) window.__recentAutoRestores.shift();

                            // Use safeRestoreScroll if present to cooperate with stabilizer
                            if (window.safeRestoreScroll && typeof window.safeRestoreScroll === 'function') {
                                try { window.safeRestoreScroll(beforeY, { behavior: 'auto', timeout: 300 }); } catch(e) { try { window.scrollTo(0, beforeY); } catch(e2) {} }
                            } else {
                                try { window.scrollTo(0, beforeY); } catch(e) { /* ignore */ }
                            }

                            console.warn('Auto-restored scroll position after unexpected jump-to-top (debug): restored to', beforeY);
                            return;
                        }

                        if (rafCount < maxRafs) {
                            window.requestAnimationFrame(checkFrame);
                        }
                    }

                    window.requestAnimationFrame(checkFrame);
                } catch(e) { /* ignore */ }
            }, true);

            console.log('Aggressive click watcher active on tall-portrait screens');
        } catch(e) { /* ignore */ }
    })();
    </script>

    <!-- Very aggressive polling detector: sample scrollTop rapidly after clicks and restore if it jumps to top -->
    <script>
    (function(){
        try {
            const isPortraitTall = (window.innerHeight > window.innerWidth) && (window.innerHeight >= 900);
            if (!isPortraitTall) return;

            window.__scrollJumpLogs = window.__scrollJumpLogs || [];

            document.addEventListener('click', function(){
                try {
                    const beforeY = window.pageYOffset || document.documentElement.scrollTop || 0;
                    if (!beforeY || beforeY <= 30) return;

                    let elapsed = 0;
                    const intervalMs = 12; // rapid sampling
                    const maxDuration = 700; // watch for 700ms

                    const id = setInterval(() => {
                        try {
                            elapsed += intervalMs;
                            const nowY = window.pageYOffset || document.documentElement.scrollTop || 0;
                            if ((nowY === 0 || Math.abs(nowY) <= 2) && beforeY > 30) {
                                // Capture stack
                                let stack = null;
                                try { stack = (new Error('poll-capture')).stack; } catch(e) { stack = 'no-stack'; }

                                const entry = { t: Date.now(), beforeY, afterY: nowY, stack, note: 'poll-detected' };
                                window.__scrollJumpLogs.push(entry);

                                // Avoid loops: if last restore same y recently, skip
                                const recent = window.__recentAutoRestores || [];
                                const last = recent[recent.length-1] || {};
                                if (!(last.y === beforeY && (Date.now() - (last.t||0) < 1000))) {
                                    // restore using safeRestoreScroll when available
                                    try {
                                        if (window.safeRestoreScroll && typeof window.safeRestoreScroll === 'function') {
                                            window.safeRestoreScroll(beforeY, { behavior: 'auto', timeout: 300 });
                                        } else {
                                            window.scrollTo(0, beforeY);
                                        }
                                        window.__recentAutoRestores = window.__recentAutoRestores || [];
                                        window.__recentAutoRestores.push({ t: Date.now(), y: beforeY });
                                        if (window.__recentAutoRestores.length > 10) window.__recentAutoRestores.shift();
                                    } catch(e) { /* ignore */ }
                                }

                                clearInterval(id);
                                return;
                            }
                            if (elapsed >= maxDuration) {
                                clearInterval(id);
                                return;
                            }
                        } catch(e) { clearInterval(id); }
                    }, intervalMs);
                } catch(e) { /* ignore */ }
            }, true);

            console.log('Polling scroll detector active on tall-portrait screens');
        } catch(e) { /* ignore */ }
    })();
    </script>

    <!-- Strong capture-phase anchor guard: prevents href="#" and empty/invalid anchors from jumping to top -->
    <script>
    (function(){
        'use strict';
        // This runs on all viewports (conservative safety) to block anchors that would change the hash
        // and cause browsers to scroll to top. We whitelist elements that explicitly opt-in or are
        // known interactive controls (Bootstrap toggles, ARIA buttons, data attributes).

        function isWhitelistedAnchor(anchor) {
            if (!anchor) return false;
            if (anchor.hasAttribute('data-allow-navigation') || anchor.hasAttribute('data-allow-top')) return true;
            if (anchor.hasAttribute('data-bs-toggle') || anchor.hasAttribute('data-toggle') || anchor.hasAttribute('data-bs-target') || anchor.getAttribute('role') === 'button') return true;
            // If anchor has a real href to an external location or a valid same-page target, allow
            return false;
        }

        document.body.addEventListener('click', function(e){
            try {
                const anchor = e.target && e.target.closest ? e.target.closest('a') : null;
                if (!anchor) return;

                const href = (anchor.getAttribute('href') || '').trim();

                // Allow whitelisted anchors
                if (isWhitelistedAnchor(anchor)) return;

                // Block empty, hash-only, or javascript:void anchors which often cause jumps
                if (href === '' || href === '#' || href.toLowerCase().startsWith('javascript:') || href === '#!') {
                    if (e.cancelable) e.preventDefault();
                    // Stop other handlers from acting on this anchor which might trigger navigation
                    e.stopImmediatePropagation();

                    // If anchor wraps a real control, forward the click to it
                    const inner = anchor.querySelector('button, [role="button"], input[type="button"], input[type="submit"]');
                    if (inner) {
                        try { inner.click(); } catch(err) { /* ignore */ }
                    }
                    return;
                }

                // If it's a hash targeting an element that doesn't exist, prevent the jump
                if (href.startsWith('#') && href.length > 1) {
                    const id = href.slice(1);
                    if (!document.getElementById(id)) {
                        if (e.cancelable) e.preventDefault();
                        e.stopImmediatePropagation();
                        return;
                    }
                }
            } catch(err) { /* swallow errors to avoid breaking page */ }
        }, true); // capture phase ensures we intercept before other handlers
    })();
    </script>

    <!-- Unconditional conservative click+scroll guard (production-safe):
         - Records last user click scroll position/time
         - Microtask restores scroll if it immediately jumps to top after a click
         - Overrides window.scrollTo to block programmatic scroll-to-top right after interaction
         - Whitelist by setting `window.allowScrollToTop = true` when needed
    -->
    <script>
    (function(){
        'use strict';
        try {
            window.__lastUserInteraction = window.__lastUserInteraction || { time: 0, y: 0 };

            // Capture-phase listener records last Y and timestamp for user interactions
            document.addEventListener('click', function(e){
                try {
                    var y = window.pageYOffset || document.documentElement.scrollTop || 0;
                    window.__lastUserInteraction.time = Date.now();
                    window.__lastUserInteraction.y = y;

                    // schedule a microtask to detect immediate jump-to-top caused by this click
                    Promise.resolve().then(function(){
                        try {
                            var afterY = window.pageYOffset || document.documentElement.scrollTop || 0;
                            if ((afterY === 0 || Math.abs(afterY) <= 2) && window.__lastUserInteraction.y > 30 && !window.allowScrollToTop) {
                                // restore using safeRestoreScroll if available
                                try {
                                    if (window.safeRestoreScroll && typeof window.safeRestoreScroll === 'function') {
                                        window.safeRestoreScroll(window.__lastUserInteraction.y, { behavior: 'auto', timeout: 300 });
                                    } else {
                                        window.scrollTo(0, window.__lastUserInteraction.y);
                                    }
                                } catch (err) {
                                    try { window.scrollTo(0, window.__lastUserInteraction.y); } catch(e){}
                                }
                            }
                        } catch(e) {}
                    });
                } catch(e) { /* ignore */ }
            }, true);

            // Override window.scrollTo conservatively: if a script tries to programmatically set top=0
            // shortly after a user interaction, prevent it unless explicitly allowed.
            (function(){
                var origScrollTo = window.scrollTo.bind(window);
                window.scrollTo = function(x, y){
                    try {
                        var targetY = null;
                        if (arguments.length === 1 && typeof x === 'object' && x !== null) {
                            if (x.top !== undefined) targetY = x.top;
                        } else if (arguments.length >= 2) {
                            targetY = y;
                        }

                        var now = Date.now();
                        if (targetY === 0 || targetY === 0) {
                            var last = window.__lastUserInteraction || { time: 0, y: 0 };
                            if (!window.allowScrollToTop && last && (now - last.time) < 700 && last.y > 30) {
                                // Block the jump-to-top; instead restore to last y.
                                try {
                                    if (window.safeRestoreScroll && typeof window.safeRestoreScroll === 'function') {
                                        window.safeRestoreScroll(last.y, { behavior: 'auto', timeout: 300 });
                                    } else {
                                        origScrollTo(0, last.y);
                                    }
                                } catch (e) {
                                    try { origScrollTo(0, last.y); } catch(_) {}
                                }
                                return;
                            }
                        }
                    } catch (e) { /* ignore */ }
                    return origScrollTo.apply(window, arguments);
                };
            })();

            console.log('Conservative click+scroll guard initialized');
        } catch(e) { console.warn('click+scroll guard init failed', e); }
    })();
    </script>

    {# Add a floating button for the assistant modal #}
    {# Remove the floating assistant button:
    <button id="openAssistantModalBtn" class="btn btn-primary rounded-circle shadow position-fixed assistant-fab">
        <i class="fas fa-robot fa-lg"></i>
    </button>
    #}

    {# Assistant Chat Modal #}
    {# Remove the Assistant Chat Modal HTML and its script block. #}

    {# Add a Chat tab to the navbar #}
    {# This <li> is now inside the navbar <ul> #}

    {# Add the Chat Modal with tabs for DMs, Assistant, and Groups #}
    <div class="modal fade" id="chatModal" tabindex="-1" aria-labelledby="chatModalLabel" aria-hidden="true">
      <div class="modal-dialog modal-lg modal-dialog-centered">
        <div class="modal-content">
          <div class="modal-header">
            <h5 class="modal-title" id="chatModalLabel">Chat</h5>
            <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
          </div>
          <div class="modal-body">
            <ul class="nav nav-tabs mb-3" id="chatTab" role="tablist">
              <li class="nav-item" role="presentation">
                <button class="nav-link active" id="dm-tab" data-bs-toggle="tab" data-bs-target="#dmTabPane" type="button" role="tab">DMs</button>
              </li>
                            <li class="nav-item" role="presentation">
                                <button class="nav-link" id="assistant-tab" data-bs-toggle="tab" data-bs-target="#assistantTabPane" type="button" role="tab">Support</button>
                            </li>
              <li class="nav-item" role="presentation">
                <button class="nav-link" id="group-tab" data-bs-toggle="tab" data-bs-target="#groupTabPane" type="button" role="tab">Groups</button>
              </li>
            </ul>
            <div class="tab-content" id="chatTabContent">
              <div class="tab-pane fade show active" id="dmTabPane" role="tabpanel">
                <div id="dmChatContainer" class="chat-container"></div>
                <div class="input-group mt-3">
                  <input type="text" class="form-control" id="dmChatInput" placeholder="Type a message...">
                  <button class="btn btn-primary" id="dmSendBtn">Send</button>
                </div>
              </div>
              <div class="tab-pane fade" id="assistantTabPane" role="tabpanel">
                                <div id="assistantChatContainer" class="chat-container"></div>
                                <div class="input-group mt-3">
                                    <input type="text" class="form-control" id="assistantChatInput" placeholder="Ask for help...">
                                    <button class="btn btn-primary" id="assistantSendBtn">Send</button>
                                </div>
              </div>
              <div class="tab-pane fade" id="groupTabPane" role="tabpanel">
                <div class="mb-2">
                  <input type="text" id="groupNameInput" class="form-control form-control-sm d-inline-block w-200" placeholder="Group name">
                  <button class="btn btn-outline-primary btn-sm" id="joinGroupBtn">Join/Create Group</button>
                  <select id="currentGroupSelect" class="form-select form-select-sm d-inline-block w-200"></select>
                  <button class="btn btn-outline-danger btn-sm" id="leaveGroupBtn">Leave Group</button>
                </div>
                <div id="groupChatContainer" class="chat-container"></div>
                <div class="input-group mt-3">
                  <input type="text" class="form-control" id="groupChatInput" placeholder="Type a group message...">
                  <button class="btn btn-primary" id="groupSendBtn">Send</button>
                </div>
              </div>
            </div>
          </div>
        </div>
      </div>
    </div>

    <script>
    document.addEventListener('DOMContentLoaded', function() {
            // Global safeguard: prevent anchors with href="#" from changing the hash/scroll
            // Many templates use href="#" for buttons; on some mobile browsers tapping these
            // will jump the page to the top. Intercept and prevent default for those anchors.
            document.body.addEventListener('click', function(e) {
                try {
                    // Find nearest anchor element
                    const anchor = e.target.closest && e.target.closest('a');
                    if (!anchor) return;

                    const href = (anchor.getAttribute('href') || '').trim();

                    // Allow anchors used by Bootstrap or ARIA controls to function
                    const isToggle = anchor.hasAttribute('data-bs-toggle') || anchor.hasAttribute('data-toggle') || anchor.getAttribute('role') === 'button' || anchor.hasAttribute('data-bs-target') || anchor.hasAttribute('aria-controls');

                    // If href is empty, just '#', javascript:void, or '#' plus whitespace, prevent navigation
                    const isHarmlessHash = href === '#' || href === '' || href.toLowerCase().startsWith('javascript:') || href === '#!';

                    if (isHarmlessHash && !isToggle) {
                        // Prevent default navigation which can jump to top on mobile browsers
                        e.preventDefault();

                        // If the anchor is being used purely as a wrapper for a control element,
                        // forward the click to the first interactive child so existing handlers run.
                        const innerBtn = anchor.querySelector('button, [role="button"], input[type="button"], input[type="submit"]');
                        if (innerBtn) {
                            // Dispatch a click event on the inner control in a safe way
                            try { innerBtn.click(); } catch (err) { /* ignore */ }
                        }
                        return;
                    }

                    // If this is an href to an internal hash targeting an element on the page,
                    // allow default behavior only if the element exists; otherwise prevent jump
                    if (href.startsWith('#') && href.length > 1 && !isToggle) {
                        const targetEl = document.getElementById(href.slice(1));
                        if (!targetEl) {
                            e.preventDefault();
                            return;
                        }
                    }
                } catch (err) {
                    // swallow errors to avoid breaking pages
                    console.warn('anchor click safeguard error', err);
                }
            }, { passive: false });

            // Additional narrow-screen capture-phase guard: record scrollY before clicks
            // and prevent stray href="#" clicks from jumping the page on small viewports.
            document.addEventListener('click', function(e) {
                try {
                                // Only active for narrow screens or tall portrait devices where this is a frequent problem
                                const isPortraitTallNow = (window.innerHeight > window.innerWidth) && (window.innerHeight >= 900);
                                if (window.innerWidth > 900 && !isPortraitTallNow) return;

                    // Snapshot before click
                    const beforeY = window.pageYOffset || document.documentElement.scrollTop || 0;

                    const anchor = e.target.closest && e.target.closest('a');
                    if (!anchor) return;

                    const href = (anchor.getAttribute('href') || '').trim();
                    if (!href || href === '#' || href.toLowerCase().startsWith('javascript:')) {
                        // Prevent default navigation
                        if (e.cancelable) e.preventDefault();
                        // After a microtask, if scroll moved to top, restore it
                        Promise.resolve().then(() => {
                            const afterY = window.pageYOffset || document.documentElement.scrollTop || 0;
                            if (afterY === 0 && beforeY > 50) {
                                // Use safeRestoreScroll if available to cooperate with stabilizer
                                if (window.safeRestoreScroll && typeof window.safeRestoreScroll === 'function') {
                                    window.safeRestoreScroll(beforeY, { behavior: 'auto', timeout: 300 });
                                } else {
                                    try { window.scrollTo(0, beforeY); } catch(e){}
                                }
                            }
                        });
                        return;
                    }
                } catch (err) {
                    console.warn('narrow-screen click guard error', err);
                }
            }, { passive: false, capture: true });

            // Prevent focus() calls from scrolling the page in browsers that don't support
            // the preventScroll option reliably. We wrap focus to provide preventScroll when possible.
            (function(){
                try {
                    const origFocus = HTMLElement.prototype.focus;
                    HTMLElement.prototype.focus = function(options){
                        if (typeof options === 'object' && options && options.preventScroll) {
                            // browser supports options, call through
                            return origFocus.call(this, options);
                        }
                        // Try to call with preventScroll option first
                        try {
                            return origFocus.call(this, { preventScroll: true });
                        } catch(e) {
                            // Fallback to original focus without scrolling
                            try { return origFocus.call(this); } catch(e2) { /* ignore */ }
                        }
                    };
                } catch (e) { /* ignore if prototype can't be modified */ }
            })();

            // Page-scoped defensive guard: prevent immediate scroll-to-top calls
            // caused by third-party code right after a user click inside the scouting form.
            // We now implement this by listening for clicks inside the form and, when
            // necessary, using the global safeRestoreScroll helper to perform intended
            // restores. The stabilizer suppression flag is handled by safeRestoreScroll.
            try {
                if (window.location.pathname && window.location.pathname.includes('/scouting/form')) {
                    // When user clicks in the form content, mark the element so any
                    // legitimate restore code can route through safeRestoreScroll.
                    document.body.addEventListener('click', function(ev) {
                        try {
                            const inForm = ev.target && ev.target.closest && (ev.target.closest('#form-content') || ev.target.closest('#scouting-form'));
                            if (inForm) {
                                // Attach a short-lived marker to the document that other code
                                // can check before calling window.scrollTo directly. Prefer
                                // to call safeRestoreScroll instead of calling window.scrollTo.
                                window.__recentlyClickedInScoutingForm = Date.now();
                                window.setTimeout(function(){ try { delete window.__recentlyClickedInScoutingForm; } catch(e){} }, 350);
                            }
                        } catch (e) { /* ignore */ }
                    }, true);
                }
            } catch (e) { /* ignore overall errors */ }
        // Open modal on button click


        // Socket.IO setup
        // Attempt to use WebSocket transport first; if handshake fails (400) or
        // websockets are not supported by the hosting environment (for example
        // when behind a proxy that doesn't forward upgrades or when using a
        // WSGI server without websocket support), fall back to long-polling.
        if (!window.socket) {
            try {
                // Try websocket + polling (prefer websocket)
                window.socket = io({ transports: ['websocket', 'polling'] });
            } catch (e) {
                // Fallback to polling-only if the above throws synchronously
                window.socket = io({ transports: ['polling'] });
            }

            // If connect errors occur (for example a 400 during websocket
            // handshake), attempt a reconnect using polling-only transport.
            window.socket.on && window.socket.on('connect_error', function(err) {
                try {
                    // If the current transport attempted websocket and failed,
                    // force polling-only reconnect.
                    if (window.socket && window.socket.io && window.socket.io.opts && Array.isArray(window.socket.io.opts.transports)) {
                        const cur = window.socket.io.opts.transports;
                        if (cur.includes('websocket') && !cur.includes('polling')) {
                            // Switch to polling-only and reconnect
                            window.socket.io.opts.transports = ['polling'];
                            try { window.socket.disconnect(); } catch(e) {}
                            try { window.socket.connect(); } catch(e) {}
                        } else if (cur.includes('websocket') && cur.includes('polling')) {
                            // If both were permitted but connection error still occurred,
                            // prefer polling-only retry to avoid repeated 400s.
                            window.socket.io.opts.transports = ['polling'];
                            try { window.socket.disconnect(); } catch(e) {}
                            try { window.socket.connect(); } catch(e) {}
                        }
                    }
                } catch (e) { /* swallow */ }
            });
        }
        const socket = window.socket;
    const recipientSelect = document.getElementById('assistantChatRecipient');
    const chatContainer = document.getElementById('assistantChatContainer');
    const chatInput = document.getElementById('assistantChatInput');
    const sendBtn = document.getElementById('assistantSendBtn');
    const deleteBtn = document.getElementById('assistantDeleteHistoryBtn');
        let allMessages = [];
        let currentRecipient = 'assistant';
        let usernameLoaded = false;

        // Fetch user list for chat (including 'assistant')
        function fetchRecipients() {
            // If the recipient select isn't present on this page, no-op
            if (!recipientSelect) return Promise.resolve();
            return fetch('/assistant/chat-users')
                .then(r => r.json())
                .then(data => {
                    recipientSelect.innerHTML = '';
                    // Always add assistant as an option
                    const optAssistant = document.createElement('option');
                    optAssistant.value = 'assistant';
                    optAssistant.textContent = 'Assistant';
                    recipientSelect.appendChild(optAssistant);
                    // Add users
                    data.users.forEach(u => {
                        const opt = document.createElement('option');
                        opt.value = u;
                        opt.textContent = u + (u === data.current_user ? ' (You)' : '');
                        recipientSelect.appendChild(opt);
                    });
                });
        }

        if (recipientSelect) {
            recipientSelect.addEventListener('change', function() {
                currentRecipient = this.value;
                renderHistory(allMessages);
            });
        }

        function renderMessage(msg) {
            // Only show messages for the selected recipient
            if ((currentRecipient === 'assistant' && msg.recipient === 'assistant') ||
                (msg.sender === currentRecipient && msg.recipient === window.currentUsername) ||
                (msg.sender === window.currentUsername && msg.recipient === currentRecipient)) {
                const div = document.createElement('div');
                div.className = 'mb-2';
                div.innerHTML = `<strong>${msg.sender}:</strong> <span>${msg.text}</span> <span class="text-muted time-text">${new Date(msg.timestamp).toLocaleTimeString()}</span>`;
                chatContainer.appendChild(div);
                chatContainer.scrollTop = chatContainer.scrollHeight;
            }
        }

        function renderHistory(history) {
            chatContainer.innerHTML = '';
            allMessages = history;
            history.forEach(renderMessage);
        }

        socket.on('assistant_chat_message', function(msg) {
            allMessages.push(msg);
            renderMessage(msg);
        });
        socket.on('assistant_chat_history', renderHistory);

        if (sendBtn) {
            sendBtn.disabled = true;

            sendBtn.addEventListener('click', function() {
                const text = (chatInput && chatInput.value || '').trim();
                if (text && window.currentUsername) {
                    console.log('Sending:', { text, recipient: currentRecipient, sender: window.currentUsername });
                    socket.emit('assistant_chat_message', { text, recipient: currentRecipient, sender: window.currentUsername });
                    if (chatInput) chatInput.value = '';
                } else {
                    alert('Username not loaded yet. Please wait.');
                }
            });
            if (chatInput) {
                chatInput.addEventListener('keypress', function(e) {
                    if (e.key === 'Enter') sendBtn.click();
                });
            }
        }

        if (deleteBtn) {
            deleteBtn.addEventListener('click', function() {
                fetch('/assistant/delete-chat-history', { method: 'POST' })
                    .then(r => r.json())
                    .then(data => {
                        if (data.success) {
                            if (chatContainer) chatContainer.innerHTML = '';
                        } else {
                            alert(data.message || 'Failed to delete chat history');
                        }
                    });
            });
        }

        // On modal open, fetch recipients and chat history
        const openBtn = document.getElementById('openAssistantModalBtn');
        if (openBtn) {
            openBtn.addEventListener('click', function() {
                const modal = new bootstrap.Modal(document.getElementById('assistantModal'));
                modal.show();
                fetchRecipients();
                if (window.socket) {
                    window.socket.emit('assistant_chat_history_request');
                }
            });
        }

        // Get current username for filtering
        fetch('/assistant/chat-users').then(r => r.json()).then(data => {
            window.currentUsername = data.current_user;
            sendBtn.disabled = false;
            usernameLoaded = true;
            console.log('Current username loaded:', window.currentUsername);
        });

        // Open chat modal from navbar
        const openChatModalNav = document.getElementById('openChatModalNav');
        if (openChatModalNav) {
            openChatModalNav.addEventListener('click', function(e) {
                e.preventDefault();
                const modal = new bootstrap.Modal(document.getElementById('chatModal'));
                modal.show();
            });
        }
        // Assistant tab logic: send message to /assistant/ask and display response
        const assistantSendBtn = document.getElementById('assistantSendBtn');
        const assistantChatInput = document.getElementById('assistantChatInput');
        const assistantChatContainer = document.getElementById('assistantChatContainer');
        assistantSendBtn.addEventListener('click', async function() {
            const question = assistantChatInput.value.trim();
            if (!question) return;
            // Show user message
            const userDiv = document.createElement('div');
            userDiv.className = 'mb-2';
            userDiv.innerHTML = `<strong>You:</strong> <span>${question}</span>`;
            assistantChatContainer.appendChild(userDiv);
            assistantChatInput.value = '';
            assistantChatContainer.scrollTop = assistantChatContainer.scrollHeight;
            // Send to backend
            const response = await fetch('/assistant/ask', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ question })
            });
            const data = await response.json();
            const botDiv = document.createElement('div');
            botDiv.className = 'mb-2';
            botDiv.innerHTML = `<strong>Assistant:</strong> <span>${data.text || data.message || 'No response.'}</span>`;
            assistantChatContainer.appendChild(botDiv);
            assistantChatContainer.scrollTop = assistantChatContainer.scrollHeight;
        });
        assistantChatInput.addEventListener('keypress', function(e) {
            if (e.key === 'Enter') assistantSendBtn.click();
        });
        // ... (existing DM and group chat logic would go here) ...
    });
    </script>
    <script>
    // Robust sidebar layout adjustment helper. This actively measures the
    // sidebar and applies inline margins to `main`/`footer`/`.topbar` so the
    // page content is pushed over reliably on desktop breakpoints.
    (function(){
        'use strict';

        function applySidebarMargin() {
            try {
                var sb = document.getElementById('appSidebar');
                var mainEl = document.querySelector('main');
                var footerEl = document.querySelector('footer.footer');
                var topbar = document.querySelector('.topbar');
                if (!sb || !mainEl) return;

                var rect = sb.getBoundingClientRect();
                var sbWidth = Math.round(rect.width || 0);
                var isDesktop = window.innerWidth >= 992;

                if (isDesktop && sbWidth > 8) {
                    // Ensure the body has the desktop layout classes
                    if (!document.body.classList.contains('with-sidebar')) document.body.classList.add('with-sidebar');
                    if (!document.body.classList.contains('topbar-fixed')) document.body.classList.add('topbar-fixed');

                    // Remove mobile overlay state if present
                    if (document.body.classList.contains('sidebar-open')) document.body.classList.remove('sidebar-open');

                    // Update the CSS variable so stylesheet rules that use
                    // var(--sidebar-width) (including !important rules) update.
                    try { document.body.style.setProperty('--sidebar-width', sbWidth + 'px'); } catch (e) {}

                    // Apply inline margins (use !important priority as a fallback
                    // for any stubborn stylesheet rules). Prefer calling the CSS
                    // variable above so the majority of rules update automatically.
                    try { mainEl.style.setProperty('margin-left', sbWidth + 'px', 'important'); } catch(e){ mainEl.style.marginLeft = sbWidth + 'px'; }
                    if (footerEl) {
                        try { footerEl.style.setProperty('margin-left', sbWidth + 'px', 'important'); } catch(e){ footerEl.style.marginLeft = sbWidth + 'px'; }
                    }
                    if (topbar) {
                        try { topbar.style.setProperty('margin-left', sbWidth + 'px', 'important'); } catch(e){ topbar.style.marginLeft = sbWidth + 'px'; }
                        try { topbar.style.setProperty('width', 'calc(100% - ' + sbWidth + 'px)', 'important'); } catch(e){ topbar.style.width = 'calc(100% - ' + sbWidth + 'px)'; }
                    }
                } else {
                    // Clear inline margins on small screens
                    try { document.body.style.removeProperty('--sidebar-width'); } catch(e) {}
                    try { mainEl.style.removeProperty('margin-left'); } catch(e){ mainEl.style.marginLeft = ''; }
                    if (footerEl) { try { footerEl.style.removeProperty('margin-left'); } catch(e){ footerEl.style.marginLeft = ''; } }
                    if (topbar) {
                        try { topbar.style.removeProperty('margin-left'); } catch(e){ topbar.style.marginLeft = ''; }
                        try { topbar.style.removeProperty('width'); } catch(e){ topbar.style.width = ''; }
                    }
                }
            } catch (e) {
                // swallow
            }
        }

        // Debounce helper
        var resizeTimer = null;
        function onResizeDebounced() {
            if (resizeTimer) clearTimeout(resizeTimer);
            resizeTimer = setTimeout(function(){ applySidebarMargin(); }, 120);
        }

        // Expose the helper globally so other scripts (and toggle handlers)
        // can force a layout recalculation immediately when needed.
        try { window.applySidebarMargin = applySidebarMargin; } catch (e) { /* ignore */ }

        // Adjust on key events
        document.addEventListener('DOMContentLoaded', function(){
            // dispatch sidebar toggle so other listeners update
            try { document.dispatchEvent(new CustomEvent('obsidian:sidebar:toggled')); } catch(e){}
            applySidebarMargin();
        });
        window.addEventListener('load', applySidebarMargin);
        window.addEventListener('resize', onResizeDebounced);

        // When sidebar is toggled by our UI, adjust layout
        document.addEventListener('obsidian:sidebar:toggled', applySidebarMargin);

        // Ensure we react to sidebar transition end (open/close animations)
        try {
            var sbEl = document.getElementById('appSidebar');
            if (sbEl) sbEl.addEventListener('transitionend', function(ev){
                // Only respond to transform/width transitions
                if (!ev || !ev.propertyName) { applySidebarMargin(); return; }
                if (['transform','width','left','margin-left'].indexOf(ev.propertyName) !== -1) applySidebarMargin();
            });
        } catch (e) { /* ignore */ }

        // Also periodically attempt to fix layout for pages that modify classes
        // after load (guarded to avoid perf issues).
        var tries = 0;
        var maxTries = 8;
        var poll = setInterval(function(){
            try { applySidebarMargin(); } catch(e){}
            tries += 1;
            if (tries >= maxTries) clearInterval(poll);
        }, 250);
    })();
    </script>
    <script>
    document.addEventListener('DOMContentLoaded', function() {
        // Expose current user's username to client-side scripts for local checks
        try {
            window.CURRENT_USERNAME = {% if current_user.is_authenticated and current_user.username %}{{ current_user.username|tojson }}{% else %}null{% endif %};
        } catch (e) { window.CURRENT_USERNAME = null; }

        async function updateChatUnreadBadge() {
            try {
                const resp = await fetch('/chat/state');
                const data = await resp.json();
                const badge = document.getElementById('chatUnreadBadge');
                const userDot = document.getElementById('userChatDot');
                const userUnreadItem = document.getElementById('userDropdownUnreadItem');
                const openUnreadChatLink = document.getElementById('openUnreadChatLink');
                const notifBellBadge = document.getElementById('notificationsBadge');
                const notifList = document.getElementById('notificationsList');

                // Update chat badge in nav/user menu
                if (badge) {
                    if (data.unreadCount && data.unreadCount > 0) {
                        badge.textContent = data.unreadCount;
                        badge.style.display = '';
                        if (userDot) userDot.style.display = '';
                        if (userUnreadItem) userUnreadItem.style.display = '';
                        if (openUnreadChatLink && data.lastSource) {
                            try {
                                const s = encodeURIComponent(JSON.stringify(data.lastSource));
                                openUnreadChatLink.href = `{{ url_for('main.chat_page') }}?focus=${s}`;
                            } catch(e) {}
                        } else if (openUnreadChatLink) {
                            openUnreadChatLink.href = `{{ url_for('main.chat_page') }}`;
                        }
                    } else {
                        badge.style.display = 'none';
                        if (userDot) userDot.style.display = 'none';
                        if (userUnreadItem) userUnreadItem.style.display = 'none';
                    }
                }

                // Update topbar notifications bell and list
                if (notifBellBadge) {
                    if (data.unreadCount && data.unreadCount > 0) {
                        notifBellBadge.textContent = data.unreadCount;
                        notifBellBadge.style.display = '';
                    } else {
                        notifBellBadge.style.display = 'none';
                        notifBellBadge.textContent = '';
                    }
                }

                if (notifList) {
                    // Remove any existing chat-unread marker item
                    const existing = document.getElementById('notif-chat-unread-item');
                    if (existing) existing.remove();

                    if (data.unreadCount && data.unreadCount > 0) {
                        // Build a top entry for unread chat messages
                        let title = '';
                        let detail = '';
                        let focusParam = '';
                        if (data.lastSource && data.lastSource.type === 'dm' && data.lastSource.id) {
                            title = `${data.unreadCount} unread chat message(s)`;
                            detail = `Most recent: ${data.lastSource.id}`;
                            try {
                                focusParam = `?focus=${encodeURIComponent(JSON.stringify(data.lastSource))}`;
                            } catch(e) { focusParam = ''; }
                        } else {
                            title = `${data.unreadCount} unread chat message(s)`;
                            detail = 'Open chat to view messages';
                        }

                        const chatItemHtml = `
                            <a id="notif-chat-unread-item" href="{{ url_for('main.chat_page') }}${focusParam}" class="list-group-item list-group-item-action d-flex align-items-start">
                                <div class="me-2">
                                    <i class="fas fa-comment-alt fa-lg text-primary"></i>
                                </div>
                                <div class="flex-fill">
                                    <div class="fw-bold">${escapeHtml(title)}</div>
                                    <div class="small text-muted">${escapeHtml(detail)}</div>
                                </div>
                                <div class="ms-2 text-end">
                                    <small class="text-muted">Open</small>
                                </div>
                            </a>
                        `;

                        // Prepend so chat notifications appear at top
                        notifList.insertAdjacentHTML('afterbegin', chatItemHtml);
                    }
                }
            } catch (e) {
                // Ignore fetch errors silently
            }
        }

        // small helper to escape text for inserted HTML
        function escapeHtml(text) {
            const div = document.createElement('div');
            div.textContent = text;
            return div.innerHTML;
        }
        // Update on page load
        updateChatUnreadBadge();
        // Poll every 5 seconds so notifications stay timely across all pages
        setInterval(updateChatUnreadBadge, 5000);
        // Listen for real-time DM and group chat events if socket.io is available
        if (window.socket) {
            window.socket.on('dm_message', function(msg) {
                try {
                    // Ignore messages authored by the current client (prevents sender receiving their own mobile send as unread)
                    if (window.CURRENT_USERNAME && msg && msg.sender && String(msg.sender).toLowerCase() === String(window.CURRENT_USERNAME).toLowerCase()) {
                        return;
                    }
                } catch (e) {
                    // If any error, fall through and handle as before
                }
                if (!window.location.pathname.startsWith('/chat')) {
                    // include source info so dropdown can open focused DM
                    fetch('/chat/increment-unread', {method: 'POST', headers: {'Content-Type':'application/json'}, body: JSON.stringify({lastSource: {type: 'dm', id: msg.sender}})}).then(updateChatUnreadBadge);
                }
            });
            // Group chat messages are disabled in this build; no-op.
        }
        // When chat page/modal is opened, reset unread count
        const chatNavItem = document.getElementById('chatNavItem');
        if (chatNavItem) {
            chatNavItem.addEventListener('click', function() {
                // When user opens chat, clear unread and any source pointer
                fetch('/chat/reset-unread', {method: 'POST'}).then(updateChatUnreadBadge);
            });
        }
        
        // ======== REAL-TIME CONFIG SYNC ========
        
        // Store current config data globally
        window.currentConfig = {
            game_config: null,
            pit_config: null,
            alliance_status: null
        };
        
        // Track if this is the initial config load
        window.configInitialized = false;
        
        // Function to fetch current configuration
        function fetchCurrentConfig() {
            return fetch('/alliances/scouting/config/current')
                .then(response => response.json())
                .then(data => {
                    window.currentConfig = data;
                    return data;
                })
                .catch(error => {
                    console.warn('Could not fetch current config:', error);
                    return null;
                });
        }
        
        // Function to update alliance status in navigation
        function updateAllianceStatusNav(allianceStatus, allianceInfo) {
            const allianceStatusElement = document.querySelector('[data-alliance-status]');
            if (allianceStatusElement) {
                if (allianceStatus) {
                    allianceStatusElement.innerHTML = `
                        <div class="d-flex align-items-center">
                            <i class="fas fa-users me-1"></i>Alliance Mode Active
                            <small class="text-muted ms-1">
                                ${allianceInfo ? allianceInfo.alliance_name : ''}
                            </small>
                        </div>
                    `;
                    allianceStatusElement.style.display = 'block';
                } else {
                    allianceStatusElement.style.display = 'none';
                }
            }
        }
        
        // Function to show auto-sync notifications
        function showAutoSyncNotification(message, type = 'info') {
            // Normalize type values to Bootstrap alert classes
            let normalizedType = type;
            if (!type || type === 'info' || type === 'message' || type === 'default') {
                normalizedType = 'success';
            } else if (type === 'error' || type === 'err') {
                normalizedType = 'danger';
            } else if (type === 'warn') {
                normalizedType = 'warning';
            }

            // Create a notification banner
            const notification = document.createElement('div');
            notification.className = `alert alert-${normalizedType} alert-dismissible fade show position-fixed`;
            notification.style.cssText = 'top: 80px; right: 20px; z-index: 9999; max-width: 400px; box-shadow: 0 4px 8px rgba(0,0,0,0.2);';
            
            const iconMap = {
                'info': 'fas fa-sync-alt',
                'success': 'fas fa-check-circle',
                'warning': 'fas fa-exclamation-triangle',
                'danger': 'fas fa-times-circle'
            };

            const icon = iconMap[normalizedType] || iconMap['info'];
            
            notification.innerHTML = `
                <div class="d-flex align-items-center">
                    <i class="${icon} me-2"></i>
                    <div>
                        <strong>Alliance Auto-Sync</strong><br>
                        <small>${message}</small>
                    </div>
                </div>
                <button type="button" class="btn-close" data-bs-dismiss="alert"></button>
            `;
            
            document.body.appendChild(notification);
            
            // Auto-remove after 8 seconds
            setTimeout(() => {
                if (notification.parentNode) {
                    const bsAlert = new bootstrap.Alert(notification);
                    bsAlert.close();
                }
            }, 8000);
        }
        
        // Function to trigger config refresh events for other scripts
        function triggerConfigUpdate(configData, isInitialLoad = false) {
            // Only dispatch update events if this is not the initial load
            if (!isInitialLoad && window.configInitialized) {
                // Dispatch custom events that other pages can listen to
                window.dispatchEvent(new CustomEvent('configUpdated', {
                    detail: configData
                }));
                
                window.dispatchEvent(new CustomEvent('gameConfigUpdated', {
                    detail: configData.game_config
                }));
                
                window.dispatchEvent(new CustomEvent('pitConfigUpdated', {
                    detail: configData.pit_config
                }));
                
                window.dispatchEvent(new CustomEvent('allianceStatusUpdated', {
                    detail: configData.alliance_status
                }));
                
                console.log('Config update events dispatched for real change');
            } else {
                console.log('Skipping config update events for initial load');
            }
        }
        
        // Socket.IO listeners for real-time updates
        if (window.socket) {
            // Auto-join team room when connected
            window.socket.on('connect', function() {
                console.log('Socket.IO connected, joining team room...');
                {% if current_user.is_authenticated and current_user.scouting_team_number %}
                    window.socket.emit('join_team_room');
                    console.log('Joined team room for team {{ current_user.scouting_team_number }}');
                {% endif %}
            });
            
            // Handle team room join confirmation
            window.socket.on('joined_team_room', function(data) {
                console.log('Successfully joined team room:', data.team_number);
            });
            
            // Listen for alliance mode toggles
            window.socket.on('alliance_mode_toggled', function(data) {
                console.log('Alliance mode toggled:', data);
                window.currentConfig.game_config = data.effective_game_config;
                window.currentConfig.pit_config = data.effective_pit_config;
                window.currentConfig.alliance_status = {
                    is_active: data.alliance_status,
                    alliance_info: data.alliance_info,
                    team_number: data.team_number
                };
                
                triggerConfigUpdate(window.currentConfig, false); // This is a real update
                updateAllianceStatusNav(data.alliance_status, data.alliance_info);
            });
            
            // Listen for general config updates
            window.socket.on('config_updated', function(data) {
                console.log('Config updated:', data);
                window.currentConfig.game_config = data.effective_game_config;
                window.currentConfig.pit_config = data.effective_pit_config;
                window.currentConfig.alliance_status = {
                    is_active: data.alliance_status,
                    alliance_info: data.alliance_info,
                    team_number: data.team_number
                };
                
                triggerConfigUpdate(window.currentConfig, false); // This is a real update
            });
            
            // Listen for alliance status changes (for nav bar updates)
            window.socket.on('alliance_status_changed', function(data) {
                console.log('Alliance status changed:', data);
                updateAllianceStatusNav(data.alliance_status, data.alliance_info);
            });
            
            // ======== ALLIANCE AUTO-SYNC HANDLERS ========
            // Listen for automatic alliance data sync
            window.socket.on('alliance_data_sync_auto', function(data) {
                console.log('Received auto-sync data from Team', data.from_team);
                
                // Automatically send acknowledgment that we received the data
                window.socket.emit('alliance_auto_sync_received', data);
                
                // Show notification about incoming data (less verbose for periodic syncs)
                if (data.type === 'periodic_sync') {
                    // Only show periodic sync notifications if there's substantial data
                    const totalEntries = data.scouting_data.length + data.pit_data.length;
                    if (totalEntries > 0) {
                        console.log(`Periodic sync: Received ${totalEntries} entries from Team ${data.from_team}`);
                        // Show subtle notification only for large periodic syncs
                        if (totalEntries >= 5) {
                            showAutoSyncNotification(`Periodic sync: ${totalEntries} entries from Team ${data.from_team}`, 'info');
                        }
                    }
                } else {
                    // Show full notifications for manual/immediate syncs
                    if (data.scouting_data.length > 0) {
                        showAutoSyncNotification(`Received ${data.scouting_data.length} scouting entries from Team ${data.from_team} (${data.alliance_name})`);
                    }
                    if (data.pit_data.length > 0) {
                        showAutoSyncNotification(`Received ${data.pit_data.length} pit scouting entries from Team ${data.from_team} (${data.alliance_name})`);
                    }
                }
            });
            
            // Listen for auto-sync completion confirmations
            window.socket.on('alliance_auto_sync_complete', function(data) {
                console.log('Auto-sync completed:', data);
                if (data.imported_count > 0) {
                    if (data.type === 'periodic_sync') {
                        // Less verbose for periodic syncs
                        console.log(`Periodic sync completed: imported ${data.imported_count} entries from Team ${data.from_team}`);
                        // Only show notification for substantial periodic imports
                        if (data.imported_count >= 3) {
                            showAutoSyncNotification(`Periodic sync: imported ${data.imported_count} entries from Team ${data.from_team}`, 'success');
                        }
                    } else {
                        // Full notification for manual syncs
                        showAutoSyncNotification(`Successfully imported ${data.imported_count} entries from Team ${data.from_team} (${data.alliance_name})`, 'success');
                    }
                    
                    // Refresh current page if it's data-related
                    if (window.location.pathname.includes('/scouting') || 
                        window.location.pathname.includes('/analysis') || 
                        window.location.pathname.includes('/pit-scouting')) {
                        setTimeout(() => {
                            window.location.reload();
                        }, 2000);
                    }
                }
            });
            
            // ======== GLOBAL CONFIG CHANGE HANDLER ========
            // Listen for global config changes that affect ALL pages
            window.socket.on('global_config_changed', function(data) {
                console.log('Global config changed:', data);
                
                // Update local config cache
                window.currentConfig.game_config = data.effective_game_config;
                window.currentConfig.pit_config = data.effective_pit_config;
                window.currentConfig.alliance_status = {
                    is_active: data.alliance_status,
                    alliance_info: data.alliance_info,
                    team_number: data.team_number
                };
                
                // Trigger all config update events
                triggerConfigUpdate(window.currentConfig, false);
                updateAllianceStatusNav(data.alliance_status, data.alliance_info);
                
                // Dispatch global reload events for pages to refresh their content
                window.dispatchEvent(new CustomEvent('globalConfigReload', {
                    detail: {
                        type: data.type,
                        message: data.message,
                        game_config: data.effective_game_config,
                        pit_config: data.effective_pit_config,
                        alliance_status: data.alliance_status,
                        alliance_info: data.alliance_info,
                        timestamp: data.timestamp
                    }
                }));
                
                // Show user notification
                if (data.message) {
                    showGlobalConfigNotification(data.message, data.type);
                }
                
                // Reload page content that depends on config
                reloadConfigDependentContent();
            });
        }
        
        // ======== GLOBAL CONFIG MANAGEMENT FUNCTIONS ========
        
        // Function to show global config notifications
        function showGlobalConfigNotification(message, type) {
            // Create or update notification element
            let notificationId = 'global-config-notification';
            let existingNotification = document.getElementById(notificationId);
            
            if (existingNotification) {
                existingNotification.remove();
            }
            
            const notificationHtml = `
                <div id="${notificationId}" class="alert alert-info alert-dismissible fade show global-config-notification">
                    <div class="d-flex align-items-center">
                        <i class="fas fa-sync-alt me-2"></i>
                        <div>
                            <strong>Configuration Updated</strong><br>
                            <small>${message}</small>
                        </div>
                    </div>
                    <button type="button" class="btn-close" data-bs-dismiss="alert"></button>
                </div>
            `;
            
            document.body.insertAdjacentHTML('beforeend', notificationHtml);
            
            // Auto-remove after 5 seconds
            setTimeout(() => {
                const notification = document.getElementById(notificationId);
                if (notification) {
                    notification.remove();
                }
            }, 5000);
        }
        
        // Function to reload config-dependent content on the current page
        function reloadConfigDependentContent() {
            const currentPath = window.location.pathname;
            
            // Page-specific content reloading
            if (currentPath.includes('/scouting/form')) {
                reloadScoutingFormContent();
            } else if (currentPath.includes('/graphs') || currentPath.includes('/analytics')) {
                reloadAnalyticsContent();
            } else if (currentPath.includes('/pit_scouting')) {
                reloadPitScoutingContent();
            } else if (currentPath.includes('/matches')) {
                reloadMatchesContent();
            } else if (currentPath.includes('/alliances')) {
                reloadAlliancesContent();
            }
            
            // Reload any generic config-dependent elements
            reloadGenericConfigElements();
        }
        
        // Page-specific reload functions
        function reloadScoutingFormContent() {
            // Trigger form reload if function exists
            if (typeof window.reloadFormWithNewConfig === 'function') {
                window.reloadFormWithNewConfig();
            }
        }
        
        function reloadAnalyticsContent() {
            // Trigger analytics reload if function exists
            if (typeof window.reloadAnalyticsWithNewConfig === 'function') {
                window.reloadAnalyticsWithNewConfig();
            }
        }
        
        function reloadPitScoutingContent() {
            // Trigger pit scouting reload if function exists
            if (typeof window.reloadPitScoutingWithNewConfig === 'function') {
                window.reloadPitScoutingWithNewConfig();
            }
        }
        
        function reloadMatchesContent() {
            // Trigger matches reload if function exists
            if (typeof window.reloadMatchesWithNewConfig === 'function') {
                window.reloadMatchesWithNewConfig();
            }
        }
        
        function reloadAlliancesContent() {
            // Trigger alliances reload if function exists
            if (typeof window.reloadAlliancesWithNewConfig === 'function') {
                window.reloadAlliancesWithNewConfig();
            }
        }
        
        function reloadGenericConfigElements() {
            // Reload any elements with data-config-dependent attribute
            const configElements = document.querySelectorAll('[data-config-dependent]');
            configElements.forEach(element => {
                const reloadType = element.getAttribute('data-config-dependent');
                if (reloadType === 'game' && window.currentConfig.game_config) {
                    // Trigger custom event for this element
                    element.dispatchEvent(new CustomEvent('configReload', {
                        detail: { config: window.currentConfig.game_config, type: 'game' }
                    }));
                } else if (reloadType === 'pit' && window.currentConfig.pit_config) {
                    element.dispatchEvent(new CustomEvent('configReload', {
                        detail: { config: window.currentConfig.pit_config, type: 'pit' }
                    }));
                }
            });
        }
        
        // Initial config fetch on page load
        fetchCurrentConfig().then(configData => {
            if (configData) {
                triggerConfigUpdate(configData, true); // Mark as initial load
                updateAllianceStatusNav(
                    configData.alliance_status.is_active, 
                    configData.alliance_status.alliance_info
                );
                window.configInitialized = true; // Mark config as initialized
            }
        });
        
        // Navbar improvements
        function initNavbarImprovements() {
            // Sync chat badges between desktop and mobile
            function syncChatBadges() {
                const desktopBadge = document.getElementById('chatUnreadBadge');
                const mobileBadge = document.getElementById('chatUnreadBadgeMobile');
                
                if (desktopBadge && mobileBadge) {
                    // Sync visibility
                    if (desktopBadge.style.display !== 'none') {
                        mobileBadge.style.display = 'inline';
                        mobileBadge.textContent = desktopBadge.textContent;
                    } else {
                        mobileBadge.style.display = 'none';
                    }
                }
            }
            
            // Observe changes to desktop badge
            const desktopBadge = document.getElementById('chatUnreadBadge');
            if (desktopBadge) {
                const observer = new MutationObserver(syncChatBadges);
                observer.observe(desktopBadge, {
                    attributes: true,
                    childList: true,
                    subtree: true
                });
                syncChatBadges(); // Initial sync
            }
            
            // Enhanced dropdown animations
            const dropdowns = document.querySelectorAll('.dropdown-menu-animated');
            dropdowns.forEach(dropdown => {
                const parent = dropdown.closest('.dropdown');
                if (parent) {
                    parent.addEventListener('show.bs.dropdown', function() {
                        dropdown.classList.add('show');
                    });
                    
                    parent.addEventListener('hide.bs.dropdown', function() {
                        dropdown.classList.remove('show');
                    });
                }
            });
            
            // Close mobile menu when clicking outside
            document.addEventListener('click', function(e) {
                const navbarCollapse = document.getElementById('navbarMain');
                const navbarToggler = document.querySelector('.navbar-toggler');
                
                if (navbarCollapse && navbarCollapse.classList.contains('show')) {
                    if (!navbarCollapse.contains(e.target) && !navbarToggler.contains(e.target)) {
                        const collapse = new bootstrap.Collapse(navbarCollapse, {
                            toggle: false
                        });
                        collapse.hide();
                    }
                }
            });
            
            // Smooth scroll for navbar brand
            const navbarBrand = document.querySelector('.navbar-brand');
            if (navbarBrand) {
                navbarBrand.addEventListener('click', function(e) {
                    // Only smooth scroll if we're on the same page
                    const href = this.getAttribute('href');
                    if (href && window.location.pathname === href) {
                        e.preventDefault();
                        try {
                            if (window.safeRestoreScroll && typeof window.safeRestoreScroll === 'function') {
                                // Route through global helper so it coordinates with mobile stabilizer
                                window.safeRestoreScroll(0, { behavior: 'smooth', timeout: 200 });
                            } else {
                                // Fallback for older pages/environments
                                window.scrollTo({ top: 0, behavior: 'smooth' });
                            }
                        } catch (err) {
                            try { window.scrollTo({ top: 0, behavior: 'smooth' }); } catch(e) {}
                        }
                    }
                });
            }
            
            // Active state management for single-page navigation
            function updateActiveNavItem() {
                const currentPath = window.location.pathname;
                const navLinks = document.querySelectorAll('.nav-link, .dropdown-item');
                
                navLinks.forEach(link => {
                    const href = link.getAttribute('href');
                    if (href === currentPath) {
                        link.classList.add('active');
                        
                        // Also activate parent dropdown if this is a dropdown item
                        const parentDropdown = link.closest('.dropdown');
                        if (parentDropdown) {
                            const parentToggle = parentDropdown.querySelector('.dropdown-toggle');
                            if (parentToggle) {
                                parentToggle.classList.add('active');
                            }
                        }
                    }
                });
            }
            
            // Call on initial load
            updateActiveNavItem();
        }
        
        // Initialize navbar improvements
        initNavbarImprovements();

            // Clear unread button (x) handler
            const clearUnreadBtn = document.getElementById('clearUnreadBtn');
            if (clearUnreadBtn) {
                clearUnreadBtn.addEventListener('click', function() {
                    fetch('/chat/reset-unread', { method: 'POST' })
                        .then(r => {
                            if (r.ok) {
                                // hide dot and this button
                                const dot = document.getElementById('userChatDot');
                                if (dot) dot.style.display = 'none';
                                clearUnreadBtn.style.display = 'none';
                                const unreadItem = document.getElementById('userDropdownUnreadItem');
                                if (unreadItem) unreadItem.style.display = 'none';
                                const chatBadge = document.getElementById('chatUnreadBadge');
                                if (chatBadge) { chatBadge.style.display = 'none'; chatBadge.textContent = '' }
                            }
                        }).catch(e => console.warn('Failed to clear unread', e));
                });
            }
        
        // Initialize search functionality
        initSearchFunctionality();
        
        // Reinitialize on window resize (when responsive classes change)
        window.addEventListener('resize', function() {
            clearTimeout(window.searchResizeTimeout);
            window.searchResizeTimeout = setTimeout(initSearchFunctionality, 250);
        });
        
        // Initialize dropdown positioning fix
        initDropdownPositioning();

        // Mobile: ensure touch devices reliably open dropdown toggles
        (function ensureTouchDropdowns(){
            if (!('ontouchstart' in window)) return; // only for touch devices
            document.querySelectorAll('.dropdown-toggle').forEach(btn => {
                // Avoid attaching multiple times
                if (btn.__touchHandlerAttached) return;
                btn.__touchHandlerAttached = true;

                btn.addEventListener('touchend', function(e){
                    // If bootstrap dropdown exists, toggle explicitly  this avoids issues when clicks are swallowed by overlays
                    try {
                        if (window.bootstrap && window.bootstrap.Dropdown) {
                            const inst = window.bootstrap.Dropdown.getOrCreateInstance(btn);
                            // If menu not shown, show it; otherwise let Bootstrap handle hide on outside tap
                            const menu = btn.closest('.dropdown')?.querySelector('.dropdown-menu');
                            if (menu && !menu.classList.contains('show')) {
                                inst.show();
                                e.preventDefault();
                            }
                        }
                    } catch (err) {
                        // Fallback to click to let browser/Bootstrap handle it
                        try { btn.click(); } catch(e){}
                    }
                }, { passive: false });
            });
        })();
        
        // Global fallback for any dropdown that opens in the navbar/topbar
        document.addEventListener('show.bs.dropdown', function(event) {
            const dropdown = event.target.closest('.navbar .dropdown, .topbar .dropdown');
            if (dropdown && window.innerWidth >= 992) {
                const toggle = dropdown.querySelector('.dropdown-toggle');
                const menu = dropdown.querySelector('.dropdown-menu');
                if (toggle && menu) {
                    setTimeout(() => {
                        positionFixedDropdown(toggle, menu);
                    }, 1);
                }
            }
        });

        // Also catch the shown event as a final fallback
        document.addEventListener('shown.bs.dropdown', function(event) {
            const dropdown = event.target.closest('.navbar .dropdown, .topbar .dropdown');
            if (dropdown && window.innerWidth >= 992) {
                const toggle = dropdown.querySelector('.dropdown-toggle');
                const menu = dropdown.querySelector('.dropdown-menu');
                if (toggle && menu) {
                    positionFixedDropdown(toggle, menu);
                }
            }
        });

        // Mobile fallback: ensure dropdowns stay within the viewport and don't drop off screen
        document.addEventListener('shown.bs.dropdown', function(event) {
            try {
                const dropdown = event.target.closest('.navbar .dropdown, .topbar .dropdown');
                if (!dropdown) return;
                if (window.innerWidth >= 992) return; // desktop handled elsewhere
                const menu = dropdown.querySelector('.dropdown-menu');
                if (!menu) return;

                // Allow time for Popper or bootstrap to set dimensions/transform, then clamp
                setTimeout(() => {
                    try {
                        const rect = menu.getBoundingClientRect();
                        const gap = 8; // px from screen edge
                        // If menu extends beyond right edge, anchor it to the right with a small gap
                        if (rect.right > (window.innerWidth - gap)) {
                            menu.style.left = 'auto';
                            menu.style.right = gap + 'px';
                            menu.style.transform = 'none';
                        }
                        // If menu extends beyond left edge, anchor to left with small gap
                        if (rect.left < gap) {
                            menu.style.left = gap + 'px';
                            menu.style.right = 'auto';
                            menu.style.transform = 'none';
                        }
                        // Force a reasonable max width so it doesn't exceed viewport
                        menu.style.maxWidth = 'calc(100vw - ' + (gap * 2) + 'px)';
                        // Ensure it's visible and accessible
                        menu.style.overflow = 'auto';
                        menu.style.overflowY = 'auto';
                        menu.style.position = 'absolute';
                    } catch (e) { /* ignore */ }
                }, 8);
            } catch(e) { /* ignore */ }
        });

        // Portal navbar/topbar dropdowns to body so they stay fixed during page scroll (desktop only)
        document.addEventListener('shown.bs.dropdown', function(event) {
            try {
                const dropdown = event.target.closest('.navbar .dropdown, .topbar .dropdown');
                if (!dropdown) return;
                // Only portal dropdowns on desktop where we handle fixed positioning.
                if (window.innerWidth < 992) return;
                const menu = dropdown.querySelector('.dropdown-menu');
                const toggle = dropdown.querySelector('.dropdown-toggle');
                if (!menu || !toggle) return;

                // If already portalled, just reposition
                if (menu.__portalPlaceholder) {
                    positionFixedDropdown(toggle, menu);
                    return;
                }

                // Create placeholder in original location
                const placeholder = document.createComment('dropdown-portal-placeholder');
                menu.parentNode.insertBefore(placeholder, menu);
                // Move menu to body and mark as navbar-glass so it matches topbar surface
                menu.classList.add('navbar-glass');
                document.body.appendChild(menu);
                // Mark placeholder and toggle for restoration/repositioning
                menu.__portalPlaceholder = placeholder;
                // Keep a reference to the toggle so we can reposition on scroll/resize
                menu.__portalToggle = toggle;
                menu.__isPortalled = true;

                // Make it fixed and position it
                menu.style.position = 'fixed';
                menu.style.zIndex = '1060';
                menu.style.willChange = 'transform, top, left';
                positionFixedDropdown(toggle, menu);

                // Destroy Popper instance if Bootstrap created one so it won't overwrite our fixed positioning on scroll
                try {
                    if (window.bootstrap && window.bootstrap.Dropdown) {
                        const bsInstance = window.bootstrap.Dropdown.getInstance(toggle);
                        if (bsInstance && bsInstance._popper) {
                            try { bsInstance._popper.destroy(); } catch(e){}
                            try { bsInstance._popper = null; } catch(e){}
                        }
                    }
                } catch (e) { /* ignore */ }

                // Remove any Popper-applied transform/inset so the menu remains where we placed it
                try {
                    menu.style.removeProperty('transform');
                    menu.style.removeProperty('inset');
                    menu.style.removeProperty('right');
                } catch (e) {}
            } catch (e) {
                // ignore portal errors
                console.warn('Dropdown portal error', e);
            }
        });

        // Restore portalled dropdowns when they hide
        document.addEventListener('hide.bs.dropdown', function(event) {
            try {
                const dropdown = event.target.closest('.navbar .dropdown, .topbar .dropdown');
                if (!dropdown) return;
                // The menu might already be in the dropdown or on body. Prefer any portalled menu (navbar-glass) first.
                const menu = document.querySelector('.dropdown-menu.navbar-glass') || dropdown.querySelector('.dropdown-menu') || document.querySelector('.dropdown-menu[aria-expanded="true"]');
                if (!menu) return;
                const placeholder = menu.__portalPlaceholder;
                if (!placeholder) return;

                // Grab the toggle so we can re-create Popper/Dropdown instances later
                const toggle = dropdown.querySelector('.dropdown-toggle');

                // Restore into original parent before the placeholder
                if (placeholder.parentNode) {
                    placeholder.parentNode.insertBefore(menu, placeholder);
                    placeholder.parentNode.removeChild(placeholder);
                } else {
                    // Fallback: append back to dropdown
                    dropdown.appendChild(menu);
                }

                // Remove glass class when restoring
                menu.classList.remove('navbar-glass');

                // Clean up styles
                menu.style.position = '';
                menu.style.left = '';
                menu.style.top = '';
                menu.style.right = '';
                menu.style.bottom = '';
                menu.style.zIndex = '';
                menu.style.willChange = '';
                // Reinitialize Popper/Dropdown for normal future behavior (if toggle exists)
                try {
                    if (toggle && window.bootstrap && window.bootstrap.Dropdown) {
                        // If there's an existing instance, dispose then re-create
                        const existing = window.bootstrap.Dropdown.getInstance(toggle);
                        if (existing && typeof existing.dispose === 'function') existing.dispose();
                        window.bootstrap.Dropdown.getOrCreateInstance(toggle);
                    }
                } catch (e) { /* ignore */ }

                // Normalize ARIA and classes so toggle and menu remain in a consistent hidden state
                try {
                    if (toggle) {
                        toggle.setAttribute('aria-expanded', 'false');
                        toggle.classList.remove('show');
                    }
                    if (menu) {
                        // Remove visibility classes and any Popper styles that might keep it visible
                        menu.classList.remove('show');
                        menu.style.removeProperty('transform');
                        menu.style.removeProperty('inset');
                        menu.removeAttribute('data-popper-placement');

                        // Clear any sizing/overflow we may have set while positioning
                        menu.style.removeProperty('max-height');
                        menu.style.removeProperty('maxWidth');
                        menu.style.removeProperty('overflow');
                        menu.style.removeProperty('overflow-y');

                        // Ensure it's not forcing display or opacity
                        menu.style.display = '';
                        try { menu.style.opacity = ''; } catch(e){}

                        // mark as just hidden to avoid immediate re-open from stray click events
                        try { menu.__justHidden = Date.now(); } catch(e){}
                    }
                } catch (e) { /* ignore */ }

                // Clean up portalling metadata
                try { delete menu.__portalPlaceholder; } catch(e) {}
                try { delete menu.__portalToggle; } catch(e) {}
                try { delete menu.__isPortalled; } catch(e) {}
            } catch (e) {
                console.warn('Dropdown portal restore error', e);
            }
        });
    });
    
    // Fix dropdown positioning for navbar dropdowns
    function initDropdownPositioning() {
        // Only apply to desktop navbar dropdowns
        function handleDropdownPositioning() {
        if (window.innerWidth >= 992) {
            // Include both .navbar and topbar dropdowns so topbar menus are positioned fixed
            const navbarDropdowns = document.querySelectorAll('.navbar .dropdown, .topbar .dropdown');

            navbarDropdowns.forEach(dropdown => {
                const toggle = dropdown.querySelector('.dropdown-toggle');
                const menu = dropdown.querySelector('.dropdown-menu');
                    
                    if (toggle && menu) {
                        // Remove any existing event listeners to prevent duplicates
                        toggle.removeEventListener('click', handleDropdownClick);
                        dropdown.removeEventListener('show.bs.dropdown', handleDropdownShow);
                        dropdown.removeEventListener('shown.bs.dropdown', handleDropdownShown);
                        
                        // Add event listeners
                        toggle.addEventListener('click', handleDropdownClick);
                        dropdown.addEventListener('show.bs.dropdown', handleDropdownShow);
                        dropdown.addEventListener('shown.bs.dropdown', handleDropdownShown);
                        
                        function handleDropdownClick(e) {
                            // If the menu was just hidden (restored) very recently, ignore this click to
                            // avoid a double-toggle situation caused by reparenting and Popper timing.
                            try {
                                const now = Date.now();
                                if (menu && menu.__justHidden && (now - menu.__justHidden) < 400) {
                                    // Clear the flag and bail
                                    delete menu.__justHidden;
                                    return;
                                }
                            } catch (e) {}

                            setTimeout(() => {
                                if (menu.classList.contains('show')) {
                                    positionFixedDropdown(toggle, menu);
                                }
                            }, 5);
                        }
                        
                        function handleDropdownShow() {
                            setTimeout(() => {
                                if (menu.classList.contains('show')) {
                                    positionFixedDropdown(toggle, menu);
                                }
                            }, 5);
                        }
                        
                        function handleDropdownShown() {
                            positionFixedDropdown(toggle, menu);
                        }
                    }
                });
            } else {
                // Reset any fixed positioning for mobile
                const navbarDropdowns = document.querySelectorAll('.navbar .dropdown-menu, .topbar .dropdown-menu');
                navbarDropdowns.forEach(menu => {
                    menu.style.position = '';
                    menu.style.left = '';
                    menu.style.top = '';
                    menu.style.right = '';
                    menu.style.bottom = '';
                });
            }
        }
        
        handleDropdownPositioning();
        
        // Reposition on window resize
        window.addEventListener('resize', function() {
            handleDropdownPositioning();
            
            if (window.innerWidth >= 992) {
                const visibleDropdowns = document.querySelectorAll('.navbar .dropdown-menu.show');
                visibleDropdowns.forEach(menu => {
                    const toggle = menu.closest('.dropdown').querySelector('.dropdown-toggle');
                    if (toggle) {
                        positionFixedDropdown(toggle, menu);
                    }
                });
            }
        });
    }
    
    function positionFixedDropdown(toggle, menu) {
        if (window.innerWidth < 992) return; // Don't apply to mobile
        
        // Skip positioning for user dropdown on iOS - let CSS handle it
        const isIOS = /iPad|iPhone|iPod/.test(navigator.userAgent) || 
                      (navigator.platform === 'MacIntel' && navigator.maxTouchPoints > 1);
        const isUserDropdown = menu.id === 'userMenu';
        if (isIOS && isUserDropdown) {
            // On iOS, use absolute positioning for user dropdown (handled by CSS)
            menu.style.position = 'absolute';
            menu.style.zIndex = '1060';
            return;
        }
        
        // Force the menu to be visible but transparent to measure it
        menu.style.opacity = '0';
        menu.style.display = 'block';
        menu.style.position = 'fixed';
        menu.style.zIndex = '1060';
        
        const toggleRect = toggle.getBoundingClientRect();
        const menuRect = menu.getBoundingClientRect();
        const viewportWidth = window.innerWidth;
        const viewportHeight = window.innerHeight;
        
        // More generous edge buffers
        const edgeBuffer = 15;
        const bottomBuffer = 20;
        
        // Calculate initial position
        let left = toggleRect.left;
        let top = toggleRect.bottom + 8; // 8px margin-top
        
        // Check if this is a right-aligned dropdown (like user menu)
        const isRightAligned = menu.classList.contains('dropdown-menu-end');
        
        if (isRightAligned) {
            // For right-aligned dropdowns, align to the right edge of the button
            left = toggleRect.right - menuRect.width;
            
            // Enhanced right edge detection - check if dropdown would go off screen
            if (left + menuRect.width > viewportWidth - edgeBuffer) {
                // Move dropdown further left to stay on screen
                left = viewportWidth - menuRect.width - edgeBuffer;
            }
            
            // Enhanced left edge detection - ensure dropdown doesn't go off left edge
            if (left < edgeBuffer) {
                left = edgeBuffer;
                // If dropdown is still too wide for screen, reduce its width
                if (menuRect.width > viewportWidth - (2 * edgeBuffer)) {
                    menu.style.maxWidth = (viewportWidth - (2 * edgeBuffer)) + 'px';
                    menu.style.overflowY = 'auto';
                }
            }
        } else {
            // For left-aligned dropdowns, check if they extend beyond right edge
            if (left + menuRect.width > viewportWidth - edgeBuffer) {
                // Try aligning to right edge of toggle button first
                let rightAlignedLeft = toggleRect.right - menuRect.width;
                if (rightAlignedLeft >= edgeBuffer) {
                    left = rightAlignedLeft;
                    menu.classList.add('dropdown-menu-end');
                } else {
                    // If that still doesn't work, force it to fit within viewport
                    left = viewportWidth - menuRect.width - edgeBuffer;
                    if (left < edgeBuffer) {
                        left = edgeBuffer;
                        menu.style.maxWidth = (viewportWidth - (2 * edgeBuffer)) + 'px';
                        menu.style.overflowY = 'auto';
                    }
                }
            } else {
                menu.classList.remove('dropdown-menu-end');
            }
            // Ensure left-aligned dropdowns don't go off the left edge
            left = Math.max(edgeBuffer, left);
        }
        
        // Enhanced bottom edge detection
        if (top + menuRect.height > viewportHeight - bottomBuffer) {
            // Try showing above the toggle button
            let newTop = toggleRect.top - menuRect.height - 8;
            if (newTop >= 0) {
                top = newTop;
            } else {
                // If it doesn't fit above either, constrain height and add scroll
                top = edgeBuffer;
                menu.style.maxHeight = (viewportHeight - (2 * edgeBuffer)) + 'px';
                menu.style.overflowY = 'auto';
            }
        }
        
        // Apply positioning with !important to override any conflicting CSS
        menu.style.setProperty('left', left + 'px', 'important');
        menu.style.setProperty('top', top + 'px', 'important');
        menu.style.setProperty('right', 'auto', 'important');
        menu.style.setProperty('bottom', 'auto', 'important');
        menu.style.setProperty('position', 'fixed', 'important');
        menu.style.opacity = '1'; // Make visible again
        
        // Debug logging (can be removed in production)
        if (window.location.hostname === 'localhost' || window.location.hostname === '127.0.0.1') {
            console.log('Dropdown positioned:', {
                toggleRect: toggleRect,
                menuRect: menuRect,
                finalLeft: left,
                finalTop: top,
                viewportWidth: viewportWidth,
                isRightAligned: isRightAligned
            });
        }
    }
    
    // Enhanced Search functionality
    // Global function for hiding suggestions
    window.hideSuggestions = function() {
    // Support multiple suggestion containers: topbar (searchSuggestionsTop), navbar (searchSuggestions),
    // and main search page (suggestions)
    const searchSuggestions = document.getElementById('searchSuggestionsTop') || document.getElementById('searchSuggestions') || document.getElementById('suggestions');
    const searchInput = document.getElementById('quickSearchInputTop') || document.getElementById('quickSearchInput');
        
        if (searchSuggestions) {
            searchSuggestions.classList.remove('show');
            searchSuggestions.style.display = 'none';
            selectedIndex = -1;
            if (searchInput) {
                searchInput.setAttribute('aria-expanded', 'false');
            }
            console.log('Suggestions hidden');
        }
    };

    // Global variables for search functionality
    let searchTimeout;
    let selectedIndex = -1;
    let currentSuggestions = [];
    
    // Global function for selecting suggestions
    window.selectSuggestion = function(text, type, searchQuery) {
        const searchInput = document.getElementById('quickSearchInput');
        const searchSuggestions = document.getElementById('searchSuggestions');
        
        if (searchInput) {
            // Use the provided searchQuery if available, otherwise fall back to extraction logic
            let finalSearchQuery = searchQuery;
            
            if (!finalSearchQuery) {
                // Extract meaningful search terms based on type (fallback)
                if (type === 'team') {
                    // For team suggestions like "Team 5454 - Obsidian", extract the team number
                    const teamNumberMatch = text.match(/Team (\d+)/);
                    if (teamNumberMatch) {
                        finalSearchQuery = teamNumberMatch[1]; // Just the team number (e.g., "5454")
                    } else {
                        // If no team number found, use the full text
                        finalSearchQuery = text;
                    }
                } else if (type === 'user') {
                    // For users, use the username as-is
                    finalSearchQuery = text;
                } else {
                    // For other types, use the full text
                    finalSearchQuery = text;
                }
            }
            
            console.log('Selected suggestion:', text, 'Searching for:', finalSearchQuery);
            
            searchInput.value = finalSearchQuery;
            window.hideSuggestions();
            
            // Navigate to search page with the optimized query
            window.location.href = `/search?q=${encodeURIComponent(finalSearchQuery)}`;
        }
    };

    function initSearchFunctionality() {
        // Check if screen is large enough for desktop search
        if (window.innerWidth < 992) {
            console.log('Screen too small for desktop search, skipping initialization');
            return;
        }
        
    const searchInput = document.getElementById('quickSearchInputTop') || document.getElementById('quickSearchInput');
    const searchSuggestions = document.getElementById('searchSuggestionsTop') || document.getElementById('searchSuggestions');
    const searchClearBtn = document.getElementById('searchClearBtnTop') || document.getElementById('searchClearBtn');
        
        console.log('Search elements found:', {
            searchInput: !!searchInput,
            searchSuggestions: !!searchSuggestions,
            searchClearBtn: !!searchClearBtn
        });
        
        if (!searchInput) {
            console.warn('No search input element found');
            return;
        }
        
        if (!searchSuggestions) {
            console.warn('searchSuggestions element not found');
            return;
        }
        
        // Position search suggestions using absolute positioning
        function positionSearchSuggestions() {
            if (searchSuggestions && searchInput) {
                console.log('Positioning search suggestions');
                
                // Get the search input wrapper position
                const inputWrapper = searchInput.closest('.search-input-wrapper');
                const inputRect = inputWrapper.getBoundingClientRect();
                
                // Position dropdown directly below the search bar
                searchSuggestions.style.cssText = `
                    position: fixed !important;
                    top: ${inputRect.bottom + 8}px !important;
                    left: ${inputRect.left}px !important;
                    width: ${Math.max(inputRect.width, 300)}px !important;
                    z-index: 2147483647 !important;
                    background: var(--bs-body-bg) !important;
                    border: 1px solid var(--bs-border-color) !important;
                    border-radius: 12px !important;
                    box-shadow: 0 8px 32px rgba(0, 0, 0, 0.15) !important;
                    display: block !important;
                    opacity: 1 !important;
                    visibility: visible !important;
                    pointer-events: auto !important;
                    overflow-y: auto !important;
                    max-height: 400px !important;
                    backdrop-filter: blur(10px) !important;
                    -webkit-backdrop-filter: blur(10px) !important;
                `;
                
                console.log('Modern dropdown positioning applied');
            }
        }
        
        // Show loading state
        function showLoading() {
            if (!searchSuggestions) return;
            console.log('Showing loading state');
            searchSuggestions.innerHTML = `
                <div class="search-loading" style="padding: 16px; text-align: center; color: var(--bs-secondary);">
                    <div class="spinner-border spinner-border-sm me-2" role="status" aria-hidden="true"></div>
                    Searching...
                </div>
            `;
            searchSuggestions.classList.add('show');
            positionSearchSuggestions();
        }
        
        // Handle search input with debouncing
        searchInput.addEventListener('input', function(e) {
            clearTimeout(searchTimeout);
            const query = this.value.trim();
            
            console.log('Input event (top/global):', query, 'length:', query.length);
            
            // Show/hide clear button
            if (searchClearBtn) {
                searchClearBtn.style.display = query ? 'flex' : 'none';
            }
            
            // Update ARIA attributes
            searchInput.setAttribute('aria-expanded', query.length >= 2 ? 'true' : 'false');
            
            // Hide suggestions immediately if search is empty
            if (query.length === 0) {
                window.hideSuggestions();
                return;
            }
            
            if (query.length < 2) {
                window.hideSuggestions();
                return;
            }
            
            // Show loading immediately for better UX
            showLoading();
            
            searchTimeout = setTimeout(() => {
                console.log('Fetching suggestions for:', query);
                fetchSuggestions(query);
            }, 300); // Increased delay to reduce API calls
        });
        
        // Clear button functionality
        if (searchClearBtn) {
            searchClearBtn.addEventListener('click', function() {
                searchInput.value = '';
                searchInput.focus();
                window.hideSuggestions();
                this.style.display = 'none';
                searchInput.setAttribute('aria-expanded', 'false');
            });
        }
        
        // Hide suggestions when search input loses focus (with delay for clicks)
        searchInput.addEventListener('blur', function() {
            // Small delay to allow for clicking on suggestions
            setTimeout(() => {
                window.hideSuggestions();
            }, 150);
        });
        
        // Show suggestions when search input gains focus (if there's content)
        searchInput.addEventListener('focus', function() {
            if (this.value.trim().length >= 2 && currentSuggestions.length > 0) {
                searchSuggestions.classList.add('show');
                positionSearchSuggestions();
            }
        });
        
        // Add click event delegation for suggestion items
        if (searchSuggestions) {
            searchSuggestions.addEventListener('click', function(e) {
                const suggestionItem = e.target.closest('.suggestion-item');
                if (suggestionItem) {
                    const url = suggestionItem.getAttribute('data-url');
                    if (url) {
                        window.location.href = url;
                        return;
                    }

                    const text = suggestionItem.getAttribute('data-value');
                    const type = suggestionItem.getAttribute('data-type');
                    const searchQuery = suggestionItem.getAttribute('data-search-query');
                    if (text && type) {
                        window.selectSuggestion(text, type, searchQuery);
                    }
                }
            });
        } else {
            console.warn('searchSuggestions element not found for event delegation');
        }
        
        // Reposition dropdown on window resize
        window.addEventListener('resize', function() {
            if (searchSuggestions && searchSuggestions.classList.contains('show')) {
                positionSearchSuggestions();
            }
        });
        
        // Reposition dropdown on scroll
        window.addEventListener('scroll', function() {
            if (searchSuggestions && searchSuggestions.classList.contains('show')) {
                positionSearchSuggestions();
            }
        });
        
        window.addEventListener('resize', positionSearchSuggestions);
        
        // Enhanced keyboard navigation
        searchInput.addEventListener('keydown', function(e) {
            const suggestions = searchSuggestions?.querySelectorAll('.suggestion-item');
            
            if (!suggestions || suggestions.length === 0) {
                if (e.key === 'Enter') {
                    e.preventDefault();
                    performQuickSearch();
                }
                return;
            }
            
            switch (e.key) {
                case 'ArrowDown':
                    e.preventDefault();
                    selectedIndex = Math.min(selectedIndex + 1, suggestions.length - 1);
                    updateSelectedSuggestion(suggestions);
                    scrollToActiveSuggestion();
                    break;
                case 'ArrowUp':
                    e.preventDefault();
                    selectedIndex = Math.max(selectedIndex - 1, -1);
                    updateSelectedSuggestion(suggestions);
                    scrollToActiveSuggestion();
                    break;
                case 'Enter':
                    e.preventDefault();
                    if (selectedIndex >= 0 && suggestions[selectedIndex]) {
                        const text = suggestions[selectedIndex].getAttribute('data-value');
                        const type = suggestions[selectedIndex].getAttribute('data-type');
                        const searchQuery = suggestions[selectedIndex].getAttribute('data-search-query');
                        if (text && type) {
                            window.selectSuggestion(text, type, searchQuery);
                        }
                    } else {
                        performQuickSearch();
                    }
                    break;
                case 'Escape':
                    window.hideSuggestions();
                    searchInput.blur();
                    break;
                case 'Tab':
                    // Allow tabbing through suggestions
                    if (selectedIndex >= 0 && suggestions[selectedIndex]) {
                        e.preventDefault();
                        const text = suggestions[selectedIndex].getAttribute('data-value');
                        const type = suggestions[selectedIndex].getAttribute('data-type');
                        const searchQuery = suggestions[selectedIndex].getAttribute('data-search-query');
                        if (text && type) {
                            window.selectSuggestion(text, type, searchQuery);
                        }
                    }
                    break;
            }
        });
        
        // Scroll active suggestion into view
        function scrollToActiveSuggestion() {
            const activeSuggestion = searchSuggestions?.querySelector('.suggestion-item.active');
            if (activeSuggestion && searchSuggestions) {
                const containerRect = searchSuggestions.getBoundingClientRect();
                const itemRect = activeSuggestion.getBoundingClientRect();
                
                if (itemRect.bottom > containerRect.bottom) {
                    activeSuggestion.scrollIntoView({ block: 'end', behavior: 'smooth' });
                } else if (itemRect.top < containerRect.top) {
                    activeSuggestion.scrollIntoView({ block: 'start', behavior: 'smooth' });
                }
            }
        }
        
        // Hide suggestions when clicking outside
        document.addEventListener('click', function(e) {
            // Don't hide if clicking on the search input, suggestions dropdown, or clear button
            if (!e.target.closest('.enhanced-search-container') && 
                !e.target.closest('#searchSuggestions') &&
                !e.target.closest('#searchClearBtn')) {
                window.hideSuggestions();
            }
        });
        
        // Prevent suggestions from hiding when clicking inside the dropdown
        if (searchSuggestions) {
            searchSuggestions.addEventListener('mousedown', function(e) {
                // Prevent the blur event from firing when clicking on suggestions
                e.preventDefault();
            });
        }
        
        // Enhanced fetch suggestions with categorization
        function fetchSuggestions(query) {
            console.log('Fetching suggestions for:', query); // Debug log

            // Request all suggestion types including pages and help for broad coverage
            const typesParam = 'team,user,match,scouting,page,help';

            fetch(`/search/api/suggestions?q=${encodeURIComponent(query)}&types=${encodeURIComponent(typesParam)}`)
                .then(response => {
                    console.log('Response received:', response.status); // Debug log
                    return response.json();
                })
                .then(data => {
                    console.log('Data received:', data); // Debug log
                    displaySuggestions(data.suggestions || []);
                })
                .catch(error => {
                    console.error('Error fetching suggestions:', error);
                    showNoResults();
                });
        }
        
        // Enhanced display suggestions with categories and icons
        function displaySuggestions(suggestions) {
            console.log('Displaying suggestions:', suggestions); // Debug log
            
            if (!searchSuggestions) {
                console.log('No searchSuggestions element found'); // Debug log
                return;
            }
            
            if (suggestions.length === 0) {
                console.log('No suggestions to display'); // Debug log
                showNoResults();
                return;
            }
            
            currentSuggestions = suggestions;
            console.log('Building HTML for', suggestions.length, 'suggestions'); // Debug log
            
            // Group suggestions by type
            const grouped = suggestions.reduce((acc, suggestion) => {
                const type = suggestion.type || 'other';
                if (!acc[type]) acc[type] = [];
                acc[type].push(suggestion);
                return acc;
            }, {});
            
            let html = '';
            
            // Define category order and labels
            const categoryOrder = ['team', 'user', 'match', 'scouting', 'page', 'help'];
            const categoryLabels = {
                'team': 'Teams',
                'user': 'Users',
                'match': 'Matches',
                'scouting': 'Scouting'
                , 'page': 'Pages',
                'help': 'Help & Docs'
            };
            
            // Build HTML with categories
            categoryOrder.forEach(type => {
                if (grouped[type] && grouped[type].length > 0) {
                    if (html) html += ''; // Separator between categories
                    html += `<div class="suggestion-category">${categoryLabels[type]}</div>`;
                    
                    grouped[type].forEach((suggestion, index) => {
                        const iconClass = getIconForType(suggestion.type);
                        const globalIndex = suggestions.indexOf(suggestion);
                        
                        html += `
                            <div class="suggestion-item" 
                                 data-index="${globalIndex}" 
                                 data-type="${suggestion.type}" 
                                 data-value="${escapeHtml(suggestion.text)}"
                                 data-search-query="${escapeHtml(suggestion.search_query || suggestion.text)}"
                                 data-url="${escapeHtml(suggestion.url || '')}"
                                 role="option">
                                <div class="suggestion-icon">
                                    <i class="${iconClass}"></i>
                                </div>
                                <div class="suggestion-content">
                                    <div class="suggestion-title">
                                        ${escapeHtml(suggestion.text)}
                                        ${suggestion.event_name || suggestion.event_code ? `<small class="text-muted ms-2">${escapeHtml((suggestion.event_name && suggestion.event_code) ? `${suggestion.event_name} (${suggestion.event_code})` : (suggestion.event_name || suggestion.event_code))}</small>` : ''}
                                    </div>
                                    <div class="suggestion-type">${suggestion.type}</div>
                                </div>
                            </div>
                        `;
                    });
                }
            });
            
            console.log('Generated HTML:', html.substring(0, 100) + '...'); // Debug log
            
            searchSuggestions.innerHTML = html;
            console.log('HTML set, adding show class');
            searchSuggestions.classList.add('show');
            console.log('Show class added, checking visibility:', getComputedStyle(searchSuggestions).display);
            positionSearchSuggestions();
            selectedIndex = -1;
            // If dark mode is active, enforce dark colors on the suggestion container
            try {
                if (document.documentElement.classList.contains('dark-mode')) {
                    searchSuggestions.style.setProperty('background', '#0b0b0d', 'important');
                    searchSuggestions.style.setProperty('color', '#ffffff', 'important');
                    searchSuggestions.style.setProperty('border-color', 'rgba(255,255,255,0.04)', 'important');
                    // Ensure individual suggestion items inherit readable colors
                    const items = searchSuggestions.querySelectorAll('.suggestion-item');
                    items.forEach(it => {
                        it.style.setProperty('background', 'transparent', 'important');
                        it.style.setProperty('color', '#ffffff', 'important');
                        const title = it.querySelector('.suggestion-title'); if (title) title.style.setProperty('color', '#ffffff', 'important');
                        const st = it.querySelector('.suggestion-type'); if (st) st.style.setProperty('color', '#bfbfbf', 'important');
                    });
                }
            } catch (e) { console && console.debug && console.debug('apply dark suggestion styles error', e); }
            
            // Debug: Check element dimensions and position
            const rect = searchSuggestions.getBoundingClientRect();
            console.log('Dropdown dimensions:', {
                width: rect.width,
                height: rect.height,
                top: rect.top,
                left: rect.left,
                visible: rect.width > 0 && rect.height > 0,
                hasContent: searchSuggestions.innerHTML.length > 0
            });
            
            console.log('Suggestions should now be visible'); // Debug log
            
            // Update ARIA attributes
            searchInput.setAttribute('aria-expanded', 'true');
            searchSuggestions.setAttribute('aria-activedescendant', '');
        }
        
        // Show no results message
        function showNoResults() {
            if (!searchSuggestions) return;
            console.log('Showing no results message'); // Debug log
            searchSuggestions.innerHTML = `
                <div class="no-suggestions">
                    <i class="fas fa-search-minus mb-2"></i><br>
                    No suggestions found
                </div>
            `;
            searchSuggestions.classList.add('show');
            positionSearchSuggestions();
        }
        
        // Update selected suggestion styling
        function updateSelectedSuggestion(suggestions) {
            suggestions.forEach((item, index) => {
                item.classList.toggle('active', index === selectedIndex);
            });
            
            // Update ARIA attributes
            if (selectedIndex >= 0 && suggestions[selectedIndex]) {
                const activeId = `suggestion-${selectedIndex}`;
                suggestions[selectedIndex].id = activeId;
                searchInput.setAttribute('aria-activedescendant', activeId);
            } else {
                searchInput.setAttribute('aria-activedescendant', '');
            }
        }
        
        // Enhanced icon mapping
        function getIconForType(type) {
            const icons = {
                'team': 'fas fa-users',
                'user': 'fas fa-user',
                'event': 'fas fa-calendar',
                'match': 'fas fa-gamepad',
                'scouting': 'fas fa-clipboard-list',
                'scouting_data': 'fas fa-clipboard-list'
                , 'page': 'fas fa-file-alt',
                'help': 'fas fa-book'
            };
            return icons[type] || 'fas fa-search';
        }
        
        // Escape HTML to prevent XSS
        function escapeHtml(text) {
            const div = document.createElement('div');
            div.textContent = text;
            return div.innerHTML;
        }
        
        // Perform quick search
        function performQuickSearch() {
            const query = searchInput.value.trim();
            if (query) {
                // Add a subtle animation before navigation
                searchInput.style.transform = 'scale(0.98)';
                setTimeout(() => {
                    window.location.href = `/search?q=${encodeURIComponent(query)}`;
                }, 100);
            }
        }
    }
    
    // Helper function for performQuickSearch (moved outside initSearchFunctionality)
    function performQuickSearch() {
        const searchInput = document.getElementById('quickSearchInput');
        if (searchInput) {
            const query = searchInput.value.trim();
            if (query) {
                window.location.href = `/search?q=${encodeURIComponent(query)}`;
            }
        }
    }
    </script>
    <script src="{{ url_for('static', filename='js/countup-site.js') }}"></script>
        <script>
        // Mobile viewport-height helper: write a --vh CSS variable that equals 1% of
        // the current window.innerHeight. This avoids layout clipping caused by
        // mobile browsers' dynamic UI (address bars/navigation bars). We call this
        // on load and resize/orientation changes so 100 * var(--vh) matches the
        // visible viewport.
        (function(){
            function setVh(){
                try{
                    var vh = (window.innerHeight || document.documentElement.clientHeight) * 0.01;
                    document.documentElement.style.setProperty('--vh', vh + 'px');
                }catch(e){}
            }
            setVh();
            window.addEventListener('resize', setVh, { passive: true });
            window.addEventListener('orientationchange', setVh, { passive: true });
            document.addEventListener('visibilitychange', function(){ if(!document.hidden) setVh(); });
        })();
        </script>
</body>
</html>