<!DOCTYPE html>
<html lang="en" class="h-100">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover, shrink-to-fit=no">
    <title>{% block title %}ObsidianScout{% endblock %}</title>
    
    {% if game_config %}
    <meta name="auto_duration" content="{{ game_config.get('auto_period', {}).get('duration_seconds', 15) }}">
    <meta name="teleop_duration" content="{{ game_config.get('teleop_period', {}).get('duration_seconds', 120) }}">
    <meta name="endgame_duration" content="{{ game_config.get('endgame_period', {}).get('duration_seconds', 30) }}">
    <script>
        // Pass game configuration as a JavaScript variable to avoid HTML escaping issues
        window.GAME_CONFIG = JSON.parse('{{ game_config|tojson|safe }}');
    </script>
    {% endif %}
    
    <link href="{{ url_for('static', filename='css/vendor/bootstrap.min.css') }}" rel="stylesheet">
    
    <link href="{{ url_for('static', filename='css/vendor/fontawesome-all.min.css') }}" rel="stylesheet">
    
    {# Google Fonts are internet-hosted; fallback to system fonts for offline use #}
    <style>body{font-family: Roboto, Montserrat, system-ui, -apple-system, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif;}</style>
    
    <link href="{{ url_for('static', filename='css/vendor/select2.min.css') }}" rel="stylesheet">
    <link href="{{ url_for('static', filename='css/vendor/select2-bootstrap-5-theme.min.css') }}" rel="stylesheet">
    
    <link rel="stylesheet" href="{{ url_for('static', filename='css/styles.css') }}">
    <link rel="stylesheet" href="{{ url_for('static', filename='css/theme-overrides.css') }}">
    <link rel="stylesheet" href="{{ url_for('static', filename='css/modal-fix.css') }}">
    <link rel="stylesheet" href="{{ url_for('static', filename='css/navbar-improvements.css') }}">
    <link rel="stylesheet" href="{{ url_for('static', filename='css/search-enhancements.css') }}">
    <link rel="stylesheet" href="{{ url_for('static', filename='css/sidebar.css') }}">
    <link rel="stylesheet" href="{{ url_for('static', filename='css/modern-ui.css') }}">
    <link rel="stylesheet" href="{{ url_for('static', filename='css/mobile-fixes.css') }}">
    <script src="{{ url_for('static', filename='js/vendor/chart.min.js') }}"></script>
    
    <!-- Dynamic Theme CSS Variables -->
    {% if theme_css_variables and theme_css_variables.strip() %}
    <style id="theme-variables">
        :root { {{ theme_css_variables | safe }} }
    </style>
    {% endif %}
    
    <link rel="manifest" href="{{ url_for('static', filename='manifest.json') }}">
    <link rel="icon" type="image/png" sizes="192x192" href="/static/obsidian-192.png">
    <link rel="apple-touch-icon" href="/static/obsidian-192.png">
    <meta name="theme-color" content="#1976d2">
    
    <style>
        .form-switch .form-check-input {
            height: 1.2rem;
            width: 2.2rem;
            cursor: pointer;
        }
        .form-check-label {
            cursor: pointer;
        }
        .dark-mode #darkModeIcon {
            color: #ffc107 !important;
        }
        .dark-mode #darkModeLabel {
            color: #e6e6e6;
        }
        .obsidian-gradient {
            background: linear-gradient(90deg, #7065a2 0%, #625591 100%);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            text-fill-color: transparent;
        }
        /* Small red dot used on user dropdown to indicate unread chat */
        .user-chat-dot {
            display: inline-block;
            width: 10px;
            height: 10px;
            border-radius: 50%;
            background: #dc3545; /* bootstrap danger */
            margin-left: 6px;
            vertical-align: middle;
        }
        
        /* Enhanced Search Component Styles */
        .search-wrapper {
            position: relative;
            flex: 1;
            max-width: 320px;
            min-width: 200px;
        }
        
        .enhanced-search-container {
            position: relative;
            width: 100%;
        }
        
        .search-input-wrapper {
            position: relative;
            display: flex;
            align-items: center;
            background: var(--bs-body-bg);
            border: 2px solid var(--bs-border-color);
            border-radius: 25px;
            transition: all 0.3s ease;
            overflow: hidden;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.08);
        }
        
        .search-input-wrapper:hover {
            border-color: var(--bs-primary);
            box-shadow: 0 4px 12px rgba(var(--bs-primary-rgb), 0.15);
        }
        
        .search-input-wrapper:focus-within {
            border-color: var(--bs-primary);
            box-shadow: 0 0 0 0.2rem rgba(var(--bs-primary-rgb), 0.25);
        }
        
        .search-icon {
            position: absolute;
            left: 14px;
            color: var(--bs-secondary);
            font-size: 0.9rem;
            z-index: 2;
            transition: color 0.3s ease;
        }
        
        .search-input-wrapper:focus-within .search-icon {
            color: var(--bs-primary);
        }
        
        .enhanced-search-input {
            flex: 1;
            border: none !important;
            outline: none !important;
            background: transparent !important;
            padding: 10px 45px 10px 40px !important;
            font-size: 0.9rem;
            color: var(--bs-body-color);
            box-shadow: none !important;
            border-radius: 0;
        }
        
        .enhanced-search-input::placeholder {
            color: var(--bs-secondary);
            font-style: italic;
        }
        
        .search-clear-btn {
            position: absolute;
            right: 45px;
            background: none;
            border: none;
            color: var(--bs-secondary);
            padding: 4px;
            border-radius: 50%;
            width: 20px;
            height: 20px;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            transition: all 0.2s ease;
            z-index: 2;
        }
        
        .search-clear-btn:hover {
            background: var(--bs-secondary-bg);
            color: var(--bs-danger);
        }
        
        .search-submit-btn {
            position: absolute;
            right: 4px;
            background: var(--bs-primary);
            border: none;
            color: white;
            padding: 8px;
            border-radius: 50%;
            width: 34px;
            height: 34px;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            transition: all 0.2s ease;
            z-index: 2;
        }
        
        .search-submit-btn:hover {
            background: var(--bs-primary);
            filter: brightness(110%);
            transform: scale(1.05);
        }
        
        .search-submit-btn:active {
            transform: scale(0.95);
        }
        
        /* Enhanced Search Suggestions */
        .enhanced-search-suggestions {
            display: none !important;
        }
        
        .enhanced-search-suggestions.show {
            display: block !important;
            z-index: 9999 !important;
        }
        
        @keyframes searchFadeIn {
            from {
                opacity: 0;
                transform: translateY(-10px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }
        
        .suggestion-item {
            display: flex;
            align-items: center;
            padding: 12px 16px;
            cursor: pointer;
            border-bottom: 1px solid var(--bs-border-color);
            transition: all 0.2s ease;
            position: relative;
        }
        
        .suggestion-item:last-child {
            border-bottom: none;
        }
        
        .suggestion-item:hover,
        .suggestion-item.active {
            background: linear-gradient(135deg, rgba(var(--bs-primary-rgb), 0.1), rgba(var(--bs-primary-rgb), 0.05));
            transform: translateX(4px);
        }
        
        .suggestion-item.active::before {
            content: '';
            position: absolute;
            left: 0;
            top: 0;
            bottom: 0;
            width: 3px;
            background: var(--bs-primary);
            border-radius: 0 2px 2px 0;
        }
        
        .suggestion-icon {
            width: 20px;
            height: 20px;
            display: flex;
            align-items: center;
            justify-content: center;
            margin-right: 12px;
            background: rgba(var(--bs-primary-rgb), 0.1);
            border-radius: 6px;
            color: var(--bs-primary);
            font-size: 0.8rem;
            flex-shrink: 0;
        }
        
        .suggestion-content {
            flex: 1;
            min-width: 0;
        }
        
        .suggestion-title {
            font-weight: 600;
            color: var(--bs-body-color);
            margin-bottom: 2px;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
        }
        
        .suggestion-type {
            font-size: 0.75rem;
            color: var(--bs-secondary);
            text-transform: uppercase;
            letter-spacing: 0.5px;
            font-weight: 500;
        }
        
        .suggestion-category {
            padding: 8px 16px;
            background: var(--bs-secondary-bg);
            color: var(--bs-secondary);
            font-size: 0.75rem;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            border-bottom: 1px solid var(--bs-border-color);
            position: sticky;
            top: 0;
            z-index: 1;
        }
        
        .search-loading {
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 20px;
            color: var(--bs-secondary);
        }
        
        .search-loading-spinner {
            width: 16px;
            height: 16px;
            border: 2px solid var(--bs-secondary-bg);
            border-top: 2px solid var(--bs-primary);
            border-radius: 50%;
            animation: spin 1s linear infinite;
            margin-right: 8px;
        }
        
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
        
        .no-suggestions {
            padding: 20px;
            text-align: center;
            color: var(--bs-secondary);
            font-style: italic;
        }
        
        /* Mobile Search Button Enhancement */
        .modern-search-mobile {
            border-radius: 12px !important;
            background: var(--bs-primary) !important;
            border-color: var(--bs-primary) !important;
            color: white !important;
            transition: all 0.2s ease;
        }
        
        .modern-search-mobile:hover {
            background: var(--bs-primary) !important;
            border-color: var(--bs-primary) !important;
            color: white !important;
            transform: scale(1.05);
            filter: brightness(110%);
        }
        
        /* Responsive Design */
        @media (max-width: 1400px) {
            .search-wrapper {
                max-width: 280px;
                min-width: 180px;
            }
        }
        
        @media (max-width: 1200px) {
            .search-wrapper {
                max-width: 240px;
                min-width: 160px;
            }
            
            .enhanced-search-input {
                font-size: 0.85rem;
                padding: 9px 42px 9px 38px !important;
            }
            
            .search-icon {
                left: 12px;
                font-size: 0.85rem;
            }
            
            .search-submit-btn {
                width: 30px;
                height: 30px;
                right: 3px;
            }
        }
        
        @media (max-width: 992px) {
            .search-wrapper {
                max-width: 200px;
                min-width: 140px;
            }
        }
        
        @media (max-width: 768px) {
            .search-wrapper {
                max-width: auto;
                min-width: auto;
                flex: 0 0 auto;
            }
        }
        
        /* Dark Mode Support */
        .dark-mode .search-input-wrapper {
            background: var(--card-bg);
            border-color: rgba(255, 255, 255, 0.2);
        }
        
        .dark-mode .search-input-wrapper:hover {
            border-color: var(--bs-primary);
        }
        
        .dark-mode .enhanced-search-suggestions {
            background: var(--card-bg);
            border-color: rgba(255, 255, 255, 0.1);
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3);
        }
        
        .dark-mode .suggestion-item {
            border-bottom-color: rgba(255, 255, 255, 0.1);
        }
        
        .dark-mode .suggestion-item:hover,
        .dark-mode .suggestion-item.active {
            background: linear-gradient(135deg, rgba(var(--bs-primary-rgb), 0.2), rgba(var(--bs-primary-rgb), 0.1));
        }
        
        .dark-mode .suggestion-category {
            background: rgba(255, 255, 255, 0.05);
            border-bottom-color: rgba(255, 255, 255, 0.1);
        }
        
        /* Search functionality styles */
        .search-wrapper {
            position: relative;
            flex: 1;
            max-width: 280px;
            min-width: 160px;
        }
        
        /* Mobile Touch and Input Stability Fixes */
        @media (max-width: 768px) {
            /* Prevent iOS zoom on input focus */
            input, textarea, select, .form-control, .form-select {
                font-size: 16px !important;
                transform: translateZ(0);
                -webkit-transform: translateZ(0);
                -webkit-appearance: none;
                border-radius: 4px;
            }
            
            /* Prevent focus outline from causing scroll */
            input:focus, textarea:focus, select:focus, .form-control:focus, .form-select:focus {
                scroll-margin: 0 !important;
                scroll-behavior: auto !important;
                outline: 2px solid var(--bs-primary);
                outline-offset: -2px;
            }
            
            /* Stabilize form containers */
            .form-group, .input-group, .form-floating, .tab-content {
                contain: layout;
                transform: translateZ(0);
                -webkit-transform: translateZ(0);
            }
            
            /* Force hardware acceleration on interactive elements */
            button, .btn, [role="button"], .dropdown-toggle, .nav-link {
                transform: translateZ(0);
                -webkit-transform: translateZ(0);
                -webkit-tap-highlight-color: transparent;
            }
            
            /* Prevent dropdown and modal scroll issues */
            .dropdown-menu, .modal-dialog {
                transform: translateZ(0);
                -webkit-transform: translateZ(0);
            }
            
            /* Prevent body overflow during modal/dropdown interactions */
            body.modal-open, body.dropdown-open {
                overflow: hidden;
                position: fixed;
                width: 100%;
            }
        }
        
        /* Enhanced Mobile Click Protection */
        @media (max-width: 900px) {
            /* Prevent unwanted scroll during interactions */
            * {
                -webkit-overflow-scrolling: touch;
                touch-action: manipulation;
            }
            
            /* Specific protection for common culprits */
            a[href="#"], a[href=""], a[href="javascript:void(0)"] {
                touch-action: none !important;
            }
            
            /* Stable positioning for fixed elements */
            .topbar, .sidebar, .navbar-fixed-top {
                transform: translateZ(0);
                -webkit-transform: translateZ(0);
            }
        }
        
        @media (max-width: 1400px) {
            .search-wrapper {
                max-width: 220px;
                min-width: 140px;
            }
        }
        
        @media (max-width: 1200px) {
            .search-wrapper {
                max-width: 180px;
                min-width: 120px;
            }
        }
        
        @media (max-width: 992px) {
            .search-wrapper {
                max-width: 140px;
                min-width: 100px;
            }
        }
        
        @media (max-width: 768px) {
            .search-wrapper {
                max-width: auto;
                min-width: auto;
                flex: 0 0 auto;
            }
        }
        
        /* Make the navbar more responsive */
        .navbar-actions {
            flex-wrap: nowrap;
            align-items: center;
        }
        
        .navbar-actions > * {
            flex-shrink: 0;
        }
        
        /* Adjust button sizes for mobile */
        @media (max-width: 768px) {
            .btn-sm {
                padding: 0.25rem 0.5rem;
                font-size: 0.775rem;
            }
            
            .dropdown-toggle::after {
                margin-left: 0.255rem;
            }
        }
        
        .search-wrapper .form-control {
            transition: width 0.3s ease;
        }
        
        .search-wrapper .form-control:focus {
            width: 100%;
        }
        
        #searchSuggestions {
            position: absolute;
            top: 100%;
            left: 0;
            right: 0;
            background: var(--bs-body-bg);
            border: 1px solid var(--bs-border-color);
            border-radius: 0.375rem;
            box-shadow: 0 0.5rem 1rem rgba(0, 0, 0, 0.15);
            z-index: 1060; /* Higher than navbar dropdowns */
            max-height: 300px;
            overflow-y: auto;
            display: none;
        }
        
        .suggestion-item {
            cursor: pointer;
            border-bottom: 1px solid var(--bs-border-color);
            transition: background-color 0.15s ease-in-out;
        }
        
        .suggestion-item:last-child {
            border-bottom: none;
        }
        
        .suggestion-item:hover,
        .suggestion-item.active {
            background-color: var(--bs-secondary-bg);
        }
        
        .search-mobile-btn {
            border: none;
            background: none;
            color: var(--bs-nav-link-color);
            padding: 0.5rem;
            border-radius: 0.375rem;
            transition: background-color 0.15s ease-in-out;
        }
        
        .search-mobile-btn:hover {
            background-color: var(--bs-secondary-bg);
            color: var(--bs-nav-link-hover-color);
        }
    </style>
    
    {% block head %}{% endblock %}
</head>
<body class="d-flex flex-column h-100 with-sidebar topbar-fixed">
    <!-- Global Top Bar (search + user) -->
    <div class="topbar d-flex align-items-center gap-2 px-3 py-2 shadow-sm" role="banner">
        <div class="d-flex align-items-center gap-2 flex-shrink-0">
            <button id="sidebarToggle" class="btn btn-outline-primary btn-sm" aria-label="Toggle navigation"><i class="fas fa-bars"></i></button>
        </div>
        {% if current_user.is_authenticated %}
        <div class="top-search d-none d-sm-block">
            <form method="GET" action="{{ url_for('search.search_page') }}" class="position-relative" role="search" aria-label="Global search">
                <div class="enhanced-search-container w-100">
                    <div class="search-input-wrapper">
                        <i class="fas fa-search search-icon"></i>
                        <input type="text" class="form-control enhanced-search-input" name="q" placeholder="Search" id="quickSearchInputTop" autocomplete="off" aria-label="Search teams and users" aria-expanded="false" role="combobox">
                        <button type="button" class="search-clear-btn" id="searchClearBtnTop" aria-label="Clear search" style="display:none;">
                            <i class="fas fa-times"></i>
                        </button>
                        <button class="search-submit-btn" type="submit" title="Search" aria-label="Submit search">
                            <i class="fas fa-arrow-right"></i>
                        </button>
                    </div>
                    <div id="searchSuggestionsTop" class="enhanced-search-suggestions" role="listbox" aria-label="Search suggestions"></div>
                </div>
            </form>
        </div>
        <a href="{{ url_for('search.search_page') }}" class="btn btn-outline-secondary btn-sm d-sm-none" aria-label="Search"><i class="fas fa-search"></i></a>
        {% endif %}
        <!-- User dropdown -->
        <div class="ms-auto d-flex align-items-center flex-shrink-0">
            {% if current_user.is_authenticated %}
                <div class="d-flex align-items-center">
                    <button class="btn btn-outline-primary btn-sm d-flex align-items-center dropdown-toggle" type="button" data-bs-toggle="dropdown" aria-expanded="false">
                        <i class="fas fa-user-circle me-1"></i>
                        <span class="d-none d-md-inline">{{ current_user.username }}</span>
                        <span id="userChatDot" class="user-chat-dot" style="display:none;" title="You have unread chat messages"></span>
                    </button>
                    <ul class="dropdown-menu dropdown-menu-end shadow">
                        <li id="userDropdownUnreadItem" style="display:none;"><a id="openUnreadChatLink" class="dropdown-item py-2" href="{{ url_for('main.chat_page') }}"><i class="fas fa-comments me-2 text-danger"></i>Open unread chat</a></li>
                        <li><hr class="dropdown-divider my-1"></li>
                        <li>
                            <div class="dropdown-user-header d-flex align-items-center px-3 py-2">
                                <div class="me-2">
                                    <i class="fas fa-user-circle fa-2x"></i>
                                </div>
                                <div class="flex-grow-1">
                                    <div class="user-name fw-semibold">{{ current_user.username or 'User' }}</div>
                                    <div class="user-roles text-muted small">
                                        {% for role in current_user.roles %}
                                            <span class="badge bg-secondary text-uppercase me-1">{{ role.name }}</span>
                                        {% else %}
                                            <span class="text-muted">No roles</span>
                                        {% endfor %}
                                    </div>
                                </div>
                            </div>
                        </li>
                        <li><hr class="dropdown-divider my-1"></li>
                        <li><a class="dropdown-item py-2" href="{{ url_for('auth.profile') }}"><i class="fas fa-user-edit me-2 text-primary"></i>Profile</a></li>
                        {% if user_has_role('admin') or user_has_role('analytics') %}
                        <li><a class="dropdown-item py-2 {% if request.endpoint == 'main.config' %}active{% endif %}" href="{{ url_for('main.config') }}"><i class="fas fa-wrench me-2 text-primary"></i>Game Configuration</a></li>
                        {% endif %}
                        {% if user_has_role('superadmin') %}
                        <li><a class="dropdown-item py-2" href="{{ url_for('db_admin.database_status') }}"><i class="fas fa-database me-2 text-success"></i>Database Admin</a></li>
                        {% endif %}
                        <li><hr class="dropdown-divider my-1"></li>
                        <li><a class="dropdown-item py-2 text-danger" href="{{ url_for('auth.logout') }}"><i class="fas fa-sign-out-alt me-2"></i>Logout</a></li>
                    </ul>
                </div>
            {% else %}
            <a href="{{ url_for('auth.login') }}" class="btn btn-primary btn-sm">Login</a>
            {% endif %}
        </div>
    </div>

    <!-- Sidebar -->
    <aside id="appSidebar" class="sidebar">
        <div class="sidebar-header d-flex align-items-center justify-content-between">
            <a class="brand d-flex align-items-center text-decoration-none" href="{% if user_has_role('scout') and not user_has_role('admin') and not user_has_role('analytics') %}{{ url_for('scouting.index') }}{% else %}{{ url_for('main.index') }}{% endif %}">
                <i class="fas fa-robot brand-icon me-2"></i>
                <span class="brand-text fw-bold"><span class="obsidian-gradient">Obsidian</span>Scout</span>
            </a>
            <button id="sidebarClose" class="btn btn-link text-muted d-lg-none" aria-label="Close sidebar"><i class="fas fa-times"></i></button>
        </div>
    {# Removed quick search from sidebar (now in top bar) #}
        <nav class="sidebar-nav flex-grow-1" aria-label="Main navigation">
            {% if current_user.is_authenticated %}
            {% if user_has_role('superadmin') %}
            <div class="nav-group">
                <div class="nav-group-title">Super Admin</div>
                <a class="nav-link {% if request.endpoint == 'auth.manage_users' %}active{% endif %}" href="{{ url_for('auth.manage_users') }}"><i class="fas fa-user-shield"></i><span>Manage Users</span></a>
                <a class="nav-link {% if request.endpoint == 'auth.add_user' %}active{% endif %}" href="{{ url_for('auth.add_user') }}"><i class="fas fa-user-plus"></i><span>Add User</span></a>
            </div>
            {% endif %}
            {% if user_has_role('admin') %}
            <div class="nav-group">
                <div class="nav-group-title">Administration</div>
            </div>
            {% endif %}
            <div class="nav-group">
                <div class="nav-group-title">Core</div>
                {% if not (user_has_role('scout') and not user_has_role('admin') and not user_has_role('analytics')) %}
                <a class="nav-link {% if request.endpoint == 'main.index' %}active{% endif %}" href="{{ url_for('main.index') }}"><i class="fas fa-home"></i><span>Dashboard</span></a>
                {% endif %}
                <a class="nav-link {% if request.endpoint == 'scouting.index' %}active{% endif %}" href="{{ url_for('scouting.index') }}"><i class="fas fa-clipboard"></i><span>Scouting Dashboard</span></a>
                <a class="nav-link {% if request.endpoint == 'scouting.scouting_form' %}active{% endif %}" href="{{ url_for('scouting.scouting_form') }}"><i class="fas fa-rocket"></i><span>Start Scouting</span></a>
                <a class="nav-link {% if request.endpoint == 'pit_scouting.index' %}active{% endif %}" href="{{ url_for('pit_scouting.index') }}"><i class="fas fa-wrench"></i><span>Pit Scouting</span></a>
                <a class="nav-link {% if request.endpoint and request.endpoint.startswith('scouting_alliances') %}active{% endif %}" href="{{ url_for('scouting_alliances.dashboard') }}"><i class="fas fa-users"></i><span>Scouting Alliances</span></a>
                <a class="nav-link {% if request.endpoint == 'scouting.list_data' %}active{% endif %}" href="{{ url_for('scouting.list_data') }}"><i class="fas fa-list"></i><span>All Data</span></a>
                <a class="nav-link {% if request.endpoint == 'scouting.view_text_elements' %}active{% endif %}" href="{{ url_for('scouting.view_text_elements') }}"><i class="fas fa-comment-alt"></i><span>Text Elements</span></a>
            </div>
            {% if user_has_role('admin') or user_has_role('analytics') %}
            <div class="nav-group">
                <div class="nav-group-title">Analytics</div>
                <a class="nav-link {% if request.endpoint and request.endpoint.startswith('teams') and request.endpoint != 'teams.ranks' %}active{% endif %}" href="{{ url_for('teams.index') }}"><i class="fas fa-users"></i><span>Teams</span></a>
                <a class="nav-link {% if request.endpoint == 'teams.ranks' %}active{% endif %}" href="{{ url_for('teams.ranks') }}"><i class="fas fa-list-ol"></i><span>Team Rankings</span></a>
                <a class="nav-link {% if request.endpoint and request.endpoint.startswith('matches') %}active{% endif %}" href="{{ url_for('matches.index') }}"><i class="fas fa-gamepad"></i><span>Matches</span></a>
                <a class="nav-link {% if request.endpoint and request.endpoint.startswith('alliances') %}active{% endif %}" href="{{ url_for('alliances.index') }}"><i class="fas fa-handshake"></i><span>Alliance Selection</span></a>
                <a class="nav-link {% if request.endpoint and request.endpoint.startswith('graphs') %}active{% endif %}" href="{{ url_for('graphs.index') }}"><i class="fas fa-chart-line"></i><span>Performance</span></a>
                <a class="nav-link {% if request.endpoint and request.endpoint.startswith('graphs') and 'side-by-side' in request.endpoint %}active{% endif %}" href="{{ url_for('graphs.side_by_side') }}"><i class="fas fa-columns"></i><span>Comparison</span></a>
                <a class="nav-link {% if request.endpoint == 'matches.predict' %}active{% endif %}" href="{{ url_for('matches.predict') }}"><i class="fas fa-chart-area"></i><span>Predictions</span></a>
                <a class="nav-link {% if request.endpoint == 'matches.predict_all' %}active{% endif %}" href="{{ url_for('matches.predict_all') }}"><i class="fas fa-list"></i><span>All Predictions</span></a>
                <a class="nav-link {% if request.endpoint == 'matches.strategy' %}active{% endif %}" href="{{ url_for('matches.strategy') }}"><i class="fas fa-chess"></i><span>Strategy</span></a>
                <a class="nav-link {% if request.endpoint == 'matches.strategy_draw' %}active{% endif %}" href="{{ url_for('matches.strategy_draw') }}"><i class="fas fa-pen-ruler"></i><span>Strategy Draw</span></a>
                <a class="nav-link {% if request.endpoint == 'graphs.my_shares' %}active{% endif %}" href="{{ url_for('graphs.my_shares') }}"><i class="fas fa-share-alt"></i><span>My Graph Shares</span></a>
                <a class="nav-link {% if request.endpoint == 'teams.my_ranks_shares' %}active{% endif %}" href="{{ url_for('teams.my_ranks_shares') }}"><i class="fas fa-trophy"></i><span>My Ranking Shares</span></a>
                <a class="nav-link {% if request.endpoint and request.endpoint.startswith('data') %}active{% endif %}" href="{{ url_for('data.index') }}"><i class="fas fa-database"></i><span>Data</span></a>
            </div>
            {% endif %}
            <div class="nav-group">
                <div class="nav-group-title">Community</div>
                <a class="nav-link {% if request.endpoint == 'main.users_page' %}active{% endif %}" href="{{ url_for('main.users_page') }}"><i class="fas fa-users"></i><span>Users</span></a>
                <a class="nav-link {% if request.endpoint == 'main.chat_page' %}active{% endif %}" href="{{ url_for('main.chat_page') }}"><i class="fas fa-comments"></i><span>Chat <span id="chatUnreadBadge" class="badge bg-danger ms-1" style="display:none;">0</span></span></a>
                <a class="nav-link {% if request.endpoint == 'main.sponsors' %}active{% endif %}" href="{{ url_for('main.sponsors') }}"><i class="fas fa-handshake"></i><span>Sponsors</span></a>
            </div>
            <div class="nav-group">
                <div class="nav-group-title">Help</div>
                <a class="nav-link {% if request.endpoint == 'main.help_page' %}active{% endif %}" href="{{ url_for('main.help_page') }}"><i class="fas fa-book"></i><span>Documentation</span></a>
                <a class="nav-link {% if request.endpoint and request.endpoint.startswith('setup') %}active{% endif %}" href="{{ url_for('setup.index') }}"><i class="fas fa-graduation-cap"></i><span>Setup & Tutorial</span></a>
            </div>
            {% endif %}
        </nav>
        {% if current_user.is_authenticated %}
        <div class="sidebar-footer mt-auto">
            <div class="user-mini d-flex align-items-center mb-2">
                <i class="fas fa-user-circle me-2 fs-4"></i>
                <div class="flex-grow-1">
                    <div class="fw-semibold small">{{ current_user.username }}</div>
                    <div class="text-muted tiny">
                        {% for role in current_user.roles %}
                            <span class="badge bg-secondary text-uppercase me-1 mb-1">{{ role.name }}</span>
                        {% endfor %}
                    </div>
                </div>
            </div>
            <div class="d-flex flex-column gap-2">
                {% if user_has_role('admin') %}
                <a class="btn btn-outline-primary btn-sm w-100 text-start {% if request.endpoint == 'auth.admin_settings' %}active{% endif %}" href="{{ url_for('auth.admin_settings') }}"><i class="fas fa-cog me-2"></i>Admin Settings</a>
                {% endif %}
                {% if user_has_role('admin') or user_has_role('analytics') %}
                <a class="btn btn-outline-primary btn-sm w-100 text-start {% if request.endpoint == 'main.config' %}active{% endif %}" href="{{ url_for('main.config') }}"><i class="fas fa-wrench me-2"></i>Game Config</a>
                {% endif %}
                <button id="darkModeButton" class="btn btn-outline-secondary btn-sm w-100 text-start" type="button">
                    <i class="fas fa-moon me-2" id="darkModeIcon"></i><span id="darkModeLabel">Dark Mode</span>
                </button>
                {% if user_has_role('superadmin') %}
                <a class="btn btn-outline-secondary btn-sm w-100 text-start" href="{{ url_for('db_admin.database_status') }}"><i class="fas fa-database me-2"></i>DB Admin</a>
                {% endif %}
                <a class="btn btn-outline-danger btn-sm w-100 text-start" href="{{ url_for('auth.logout') }}"><i class="fas fa-sign-out-alt me-2"></i>Logout</a>
            </div>
        </div>
        {% endif %}
    </aside>

    <script>
    // Sidebar toggle logic (mobile overlay + desktop collapse)
    (function(){
        const sidebar = document.getElementById('appSidebar');
        const toggle = document.getElementById('sidebarToggle');
        const closeBtn = document.getElementById('sidebarClose');
        const body = document.body;
        let _scrollPosition = 0;

        // Use an overlay to absorb touch/scroll events when sidebar is open on mobile.
        // This avoids fixing body position which on some devices can clip fixed children.
            function lockBodyScroll(){
                _scrollPosition = window.scrollY || document.documentElement.scrollTop || 0;

                // Prevent background scrolling while sidebar is open
                document.documentElement.style.overflow = 'hidden';
                document.body.style.overflow = 'hidden';

                // Add a transparent overlay that captures touch and click events outside the sidebar
                let overlay = document.getElementById('sidebarBackdropOverlay');
                if(!overlay){
                    overlay = document.createElement('div');
                    overlay.id = 'sidebarBackdropOverlay';
                    overlay.style.position = 'fixed';
                    overlay.style.inset = '0';
                    overlay.style.zIndex = '1035';
                    overlay.style.background = 'transparent';
                    overlay.style.touchAction = 'none';
                    overlay.addEventListener('touchmove', function(e){ e.preventDefault(); }, { passive: false });
                    overlay.addEventListener('click', function(){ closeSidebar(); });
                    document.body.appendChild(overlay);
                }

                // Ensure sidebar can scroll smoothly on iOS
                if(sidebar) {
                    sidebar.style['-webkit-overflow-scrolling'] = 'touch';
                }
            }
        function unlockBodyScroll(){
                const overlay = document.getElementById('sidebarBackdropOverlay');
                if(overlay && overlay.parentNode) overlay.parentNode.removeChild(overlay);

                document.documentElement.style.overflow = '';
                document.body.style.overflow = '';
                // Restore scroll position (use safe helper to cooperate with stabilizer)
                try {
                    if (typeof window.safeRestoreScroll === 'function') {
                        window.safeRestoreScroll(_scrollPosition || 0, { behavior: 'auto', timeout: 350 });
                    } else {
                        try { if (window.safeRestoreScroll && typeof window.safeRestoreScroll === 'function') { window.safeRestoreScroll(_scrollPosition || 0, { behavior: 'auto', timeout: 300 }); } else { window.scrollTo(0, _scrollPosition || 0); } } catch(e) {}
                    }
                } catch (e) { /* ignore */ }
            }

        // Sidebar open/close with localStorage persistence for desktop
        const SIDEBAR_STORAGE_KEY = 'obsidian_sidebar_collapsed';

        function isDesktop() { return window.innerWidth >= 992; }

        function setSidebarCollapsed(collapsed) {
            if (collapsed) {
                document.body.classList.add('sidebar-collapsed');
            } else {
                document.body.classList.remove('sidebar-collapsed');
            }
            try { localStorage.setItem(SIDEBAR_STORAGE_KEY, collapsed ? '1' : '0'); } catch(e){}
        }

        function getStoredSidebarCollapsed() {
            try { return localStorage.getItem(SIDEBAR_STORAGE_KEY) === '1'; } catch(e){ return null; }
        }

        function openSidebar(){
            if(!isDesktop()){
                sidebar.classList.add('open');
                body.classList.add('sidebar-open');
                lockBodyScroll();
            } else {
                setSidebarCollapsed(false);
            }
            if(toggle) toggle.setAttribute('aria-expanded','true');
        }

        function closeSidebar(){
            if(!isDesktop()){
                sidebar.classList.remove('open');
                body.classList.remove('sidebar-open');
                try { unlockBodyScroll(); } catch(e){}
            } else {
                setSidebarCollapsed(true);
            }
            if(toggle) toggle.setAttribute('aria-expanded','false');
        }

        function toggleSidebar(){
            if(!isDesktop()){
                if(sidebar.classList.contains('open')){ closeSidebar(); } else { openSidebar(); }
            } else {
                // desktop: toggle collapse state
                const collapsed = document.body.classList.contains('sidebar-collapsed');
                setSidebarCollapsed(!collapsed);
            }
        }

        if(toggle){
            toggle.setAttribute('aria-controls','appSidebar');
            toggle.setAttribute('aria-expanded','true');
            toggle.addEventListener('click', (e)=>{ e.preventDefault(); toggleSidebar(); });
        }

        // Apply stored state on load (desktop only)
        (function applyStoredSidebarState(){
            const stored = getStoredSidebarCollapsed();
            if (stored === null) return; // no preference stored
            if (isDesktop()) {
                setSidebarCollapsed(stored);
            } else {
                // if mobile, ensure collapsed flag is reflected but don't force open/close overlay
                if (stored) document.body.classList.add('sidebar-collapsed');
            }
        })();

        if(closeBtn){ closeBtn.addEventListener('click', (e)=>{ e.preventDefault(); closeSidebar(); }); }

        // Nav link click (mobile)
        if (sidebar) {
            sidebar.querySelectorAll('a.nav-link').forEach(a=>{
                a.addEventListener('click', ()=>{ if(window.innerWidth < 992) closeSidebar(); });
            });
        }

        // Outside click (mobile)
        document.addEventListener('click', (e)=>{
            if(window.innerWidth >= 992) return;
            if(!sidebar.contains(e.target) && !(toggle && toggle.contains(e.target))) closeSidebar();
        });

        // Esc key
        document.addEventListener('keydown', (e)=>{ if(e.key==='Escape'){ if(window.innerWidth < 992 && sidebar.classList.contains('open')) closeSidebar(); }});

        // Initialize desktop state: respect stored preference if present
        if (window.innerWidth >= 992) {
            try {
                const stored = getStoredSidebarCollapsed();
                if (stored === null) {
                    // No preference stored: default to expanded
                    body.classList.remove('sidebar-collapsed');
                } else {
                    // Apply stored preference
                    setSidebarCollapsed(stored);
                }
            } catch (e) {
                // Fallback: ensure sidebar is expanded
                body.classList.remove('sidebar-collapsed');
            }
        }

        window.addEventListener('resize', ()=>{
            if(window.innerWidth >= 992){
                sidebar.classList.remove('open');
                body.classList.remove('sidebar-open');
                try { unlockBodyScroll(); } catch(e){}
            } else {
                body.classList.remove('sidebar-collapsed');
            }
        });

        // Re-apply stored sidebar state when resizing across breakpoint
        let lastWasDesktop = window.innerWidth >= 992;
        window.addEventListener('resize', function() {
            const nowDesktop = window.innerWidth >= 992;
            if (nowDesktop !== lastWasDesktop) {
                // crossed breakpoint
                const stored = getStoredSidebarCollapsed();
                if (stored !== null) {
                    if (nowDesktop) setSidebarCollapsed(stored);
                    else document.body.classList.remove('sidebar-collapsed');
                }
            }
            lastWasDesktop = nowDesktop;
        });

        // Avoid repositioning fixed dropdowns while page scrolls; only reposition if user opens a dropdown or resizes
        let lastScrollY = window.scrollY;
        window.addEventListener('scroll', function() {
            // If any topbar dropdown menu is positioned fixed, don't adjust its position on scroll
            const fixedMenus = document.querySelectorAll('.topbar .dropdown-menu');
            let hasFixed = false;
            fixedMenus.forEach(menu => {
                if (getComputedStyle(menu).position === 'fixed' && menu.classList.contains('show')) hasFixed = true;
            });
            if (hasFixed) {
                // nothing to do while scrolling
                lastScrollY = window.scrollY;
                return;
            }

            // If no fixed menus, allow repositioning logic for dropdowns that rely on normal flow
            // (for example on desktop navbar dropdowns not positioned fixed)
            lastScrollY = window.scrollY;
        });
    })();
    </script>
    {# Embedded site-wide notification banner placed directly under the navbar #}
    {% include '_notification_banner.html' %}

    <div class="toast-container position-fixed top-0 end-0 p-3">
        {% with messages = get_flashed_messages(with_categories=true) %}
            {% if messages %}
                {% for category, message in messages %}
                    <div class="toast show" role="alert" aria-live="assertive" aria-atomic="true">
                        <div class="toast-header bg-{{ category }}{% if category in ['danger', 'success', 'primary'] %} text-white{% endif %}">
                            <i class="fas {% if category == 'success' %}fa-check-circle{% elif category == 'danger' %}fa-exclamation-triangle{% elif category == 'warning' %}fa-exclamation-circle{% else %}fa-info-circle{% endif %} me-2"></i>
                            <strong class="me-auto">Notification</strong>
                            <small>Just now</small>
                            <button type="button" class="btn-close {% if category in ['danger', 'success', 'primary'] %}btn-close-white{% endif %}" data-bs-dismiss="toast" aria-label="Close"></button>
                        </div>
                        <div class="toast-body">
                            {{ message }}
                        </div>
                    </div>
                {% endfor %}
            {% endif %}
        {% endwith %}
    </div>

    {% block breadcrumb %}{% endblock %}

    <main class="flex-shrink-0 py-4">
        <div class="container">
            <div class="row mb-4">
                <div class="col-12">
                    <h1 class="page-title">{% block heading %}ObsidianScout{% endblock %}</h1>
                    {% block subheading %}{% endblock %}
                </div>
            </div>
            
            {% block content %}{% endblock %}
        </div>
    </main>

    <footer class="footer mt-auto py-3">
        <div class="container">
            <div class="row align-items-center g-2">
                <div class="col-md-6 text-center text-md-start">
                    <div class="d-flex align-items-center justify-content-center justify-content-md-start">
                        <i class="fas fa-robot brand-icon me-2 text-primary"></i>
                        <span class="fw-bold">ObsidianScout</span>
                        <span class="text-muted mx-2">â€¢</span>
                        <span class="small text-muted">ObsidianScout</span>
                    </div>
                </div>
                <div class="col-md-6 text-center text-md-end">
                    <div class="small text-muted">
                        {% if game_config %}
                        <span>{{ game_config.game_name }} {{ game_config.season }}</span>
                        {% else %}
                        <span>No active configuration</span>
                        {% endif %}
                    </div>
                <!--<div class="mt-2">
                        <a href="https://www.paypal.com" target="_blank" rel="noopener" class="btn btn-sm btn-warning d-inline-flex align-items-center">
                            <i class="fas fa-heart me-1"></i> Donate(Not yet available)
                        </a>
                    </div> -->
                </div>
            </div>
        </div>
    </footer>

    <div id="loading-overlay" class="d-none">
        <div class="spinner-container">
            <div class="spinner-border text-primary" role="status">
                <span class="visually-hidden">Loading...</span>
            </div>
            <div class="mt-2">Loading...</div>
        </div>
    </div>

    <script src="{{ url_for('static', filename='js/vendor/jquery-3.7.1.min.js') }}"></script>
    <script>
        // Enhanced jQuery loading check with timeout
        (function() {
            let retryCount = 0;
            const maxRetries = 5;
            const checkInterval = 100; // 100ms
            
            function checkJQuery() {
                if (typeof jQuery !== 'undefined' && typeof $ !== 'undefined') {
                    console.log('jQuery loaded successfully');
                    return true;
                }
                
                retryCount++;
                if (retryCount < maxRetries) {
                    setTimeout(checkJQuery, checkInterval);
                } else {
                    // Final fallback - load jQuery synchronously
                    console.warn('jQuery failed to load from CDNs, loading local fallback');
                    const script = document.createElement('script');
                    // Fallback now points to local vendor file for offline use
                    script.src = '{{ url_for('static', filename='js/vendor/jquery-3.7.1.min.js') }}';
                    script.integrity = 'sha384-1H217gwSVyLSIfaLxHbE7dRb3v4mYCKbpQvzx0cegeju1MVsGrX5xXxAvs/HgeFs';
                    script.crossOrigin = 'anonymous';
                    document.head.appendChild(script);
                    
                    script.onload = function() {
                        console.log('jQuery loaded from fallback CDN');
                    };
                    
                    script.onerror = function() {
                        console.error('All jQuery CDNs failed to load');
                        alert('jQuery failed to load from all sources. Please check your internet connection and refresh the page.');
                    };
                }
                return false;
            }
            
            // Start checking after a short delay
            setTimeout(checkJQuery, 50);
        })();
    </script>
    
    <script src="{{ url_for('static', filename='js/vendor/bootstrap.bundle.min.js') }}"></script>
    
    <script src="{{ url_for('static', filename='js/vendor/select2.min.js') }}"></script>
    
    <script src="{{ url_for('static', filename='js/select2-mobile-fix.js') }}"></script>
    
    <script src="{{ url_for('static', filename='js/vendor/plotly-latest.min.js') }}"></script>
    
    <script src="{{ url_for('static', filename='js/vendor/socket.io.js') }}"></script>
    
    <script src="{{ url_for('static', filename='js/qrcode.min.js') }}"></script>
    
    <!-- Gentle Mobile Scroll Protection -->
    <script>
    (function() {
        'use strict';
        
        const isMobile = window.innerWidth <= 768 || /Android|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
        
        if (!isMobile) return;
        
        console.log('Gentle mobile scroll protection active');
        
        let isInteracting = false;
        let lastScrollY = 0;
        
        // Track scroll position when not interacting
        function updateScrollPosition() {
            if (!isInteracting) {
                lastScrollY = window.pageYOffset || document.documentElement.scrollTop || 0;
            }
        }
        
        // Gentle protection only for obvious scroll-to-top jumps
        function preventScrollToTop() {
            const currentScrollY = window.pageYOffset || document.documentElement.scrollTop || 0;
            
            // Only intervene if scroll jumped to exactly 0 from a significant position
            if (currentScrollY === 0 && lastScrollY > 100) {
                console.log('Preventing scroll-to-top jump');
                // Use smooth scroll to restore position
                window.scrollTo({
                    top: lastScrollY,
                    behavior: 'smooth'
                });
            }
        }
        
        // Very gentle click protection
        function handleInteraction(e) {
            // Only protect problematic elements
            const problematic = e.target.matches('a[href="#"], a[href=""], button[type="button"]:not([data-bs-toggle])');
            
            if (problematic) {
                isInteracting = true;
                
                // Single check after a short delay
                setTimeout(() => {
                    preventScrollToTop();
                    isInteracting = false;
                    updateScrollPosition();
                }, 50);
            }
        }
        
        // Add minimal event listeners
        document.addEventListener('click', handleInteraction, { passive: true });
        window.addEventListener('scroll', updateScrollPosition, { passive: true });
        
        // Initialize
        updateScrollPosition();
        
    })();
    </script>
    
    <script src="{{ url_for('static', filename='js/scripts.js') }}"></script>
    
    <script>
        document.addEventListener('DOMContentLoaded', function() {
            // Global helper: perform a scroll restore while cooperating with the
            // mobile viewport stabilizer. This sets the stabilizer suppression
            // flag briefly so the stabilizer doesn't fight legitimate restores.
            window.safeRestoreScroll = function(y, opts) {
                try { if (!opts) opts = {}; } catch(e) { opts = {}; }
                try { window.__suppressMobileScrollJumps = true; } catch (e) {}
                const behavior = opts.behavior || 'auto';
                // Use requestAnimationFrame so layout has settled before scrolling
                window.requestAnimationFrame(() => {
                    try {
                        window.scrollTo({ top: (y || 0), behavior: behavior });
                    } catch (err) {
                        try { if (window.safeRestoreScroll && typeof window.safeRestoreScroll === 'function') { window.safeRestoreScroll((y || 0), { behavior: 'auto', timeout: 350 }); } else { window.scrollTo(0, (y || 0)); } } catch(e) {}
                    }
                    // Remove suppression after a short timeout; caller may override
                    setTimeout(() => { try { window.__suppressMobileScrollJumps = false; } catch(e) {} }, opts.timeout || 350);
                });
            };
            
            // Initialize mobile protection
            initializeMobileScrollProtection();
            
            // ===============================
            // GLOBAL SELECT2 MOBILE ENHANCEMENT
            // ===============================
            
            // Apply mobile fixes to any existing Select2 dropdowns
            setTimeout(() => {
                if (typeof window.initSelect2Mobile === 'function') {
                    // Re-initialize any existing Select2 instances with mobile fixes
                    $('.select2-hidden-accessible').each(function() {
                        const $this = $(this);
                        const currentOptions = $this.data('select2') ? $this.data('select2').options.options : {};
                        
                        // Get existing configuration
                        const existingConfig = {
                            placeholder: currentOptions.placeholder || 'Select...',
                            allowClear: currentOptions.allowClear || false,
                            closeOnSelect: currentOptions.closeOnSelect !== false,
                            theme: currentOptions.theme || 'bootstrap-5',
                            width: currentOptions.width || '100%'
                        };
                        
                        // Only re-initialize if on mobile and not already mobile-enhanced
                        if (window.innerWidth <= 900 && !$this.hasClass('mobile-enhanced')) {
                            try {
                                $this.addClass('mobile-enhanced');
                                window.initSelect2Mobile($this, existingConfig);
                                console.log('Enhanced Select2 dropdown for mobile:', $this.attr('id') || $this.attr('name'));
                            } catch (e) {
                                console.warn('Failed to enhance Select2 for mobile:', e);
                            }
                        }
                    });
                }
            }, 200);
            
            // Dark mode button logic
            const darkModeBtn = document.getElementById('darkModeButton');
            const body = document.body;
            const prefersDarkMode = window.matchMedia('(prefers-color-scheme: dark)').matches;
            const storedPreference = localStorage.getItem('darkMode');
            const darkModeIcon = document.getElementById('darkModeIcon');
            const darkModeLabel = document.getElementById('darkModeLabel');
            const isDarkMode = storedPreference !== null ? storedPreference === 'true' : prefersDarkMode;
            function applyState(on){
                if(on){
                    body.classList.add('dark-mode');
                    if(darkModeIcon){darkModeIcon.classList.remove('fa-moon');darkModeIcon.classList.add('fa-sun');}
                    if(darkModeLabel){darkModeLabel.textContent='Light Mode';}
                } else {
                    body.classList.remove('dark-mode');
                    if(darkModeIcon){darkModeIcon.classList.remove('fa-sun');darkModeIcon.classList.add('fa-moon');}
                    if(darkModeLabel){darkModeLabel.textContent='Dark Mode';}
                }
            }
            applyState(isDarkMode);
            
            // Server-side theme management was removed; rely on client preference (localStorage) only.
            
            if(darkModeBtn){
                darkModeBtn.addEventListener('click', ()=>{
                    const now = !body.classList.contains('dark-mode');
                    localStorage.setItem('darkMode', now ? 'true':'false');
                    applyState(now);
                    
                    // Persist only locally; no server-side theme endpoints are available.
                });
            }
            // System preference changes only if user hasn't chosen
            window.matchMedia('(prefers-color-scheme: dark)').addEventListener('change', e => {
                if (localStorage.getItem('darkMode') === null) {
                    applyState(e.matches);
                }
            });
            
            // Initialize toasts
            var toastElList = document.querySelectorAll('.toast');
            Array.from(toastElList).map(function (toastEl) {
                return new bootstrap.Toast(toastEl, {
                    autohide: true,
                    delay: 5000
                });
            });
        });
    </script>
    
    <!-- Dark mode handlers -->
    <script src="{{ url_for('static', filename='js/dark-mode-handlers.js') }}"></script>
    

    
    {% block scripts %}{% endblock %}
    {% block extra_js %}{% endblock %}

    <script>
    // Ensure service worker is registered at root (/sw.js) so PWABuilder and other tools can detect it
    if ('serviceWorker' in navigator) {
        navigator.serviceWorker.register('/sw.js?v=2', { scope: '/' })
            .then(reg => {
                console.log('SW root registered:', reg.scope);
                // Force update check
                reg.update();
            })
            .catch(err => console.warn('SW root registration failed:', err));
    }
    </script>

    {# Add a floating button for the assistant modal #}
    {# Remove the floating assistant button:
    <button id="openAssistantModalBtn" class="btn btn-primary rounded-circle shadow position-fixed" style="bottom: 32px; right: 32px; z-index: 1050; width: 60px; height: 60px; display: flex; align-items: center; justify-content: center;">
        <i class="fas fa-robot fa-lg"></i>
    </button>
    #}

    {# Assistant Chat Modal #}
    {# Remove the Assistant Chat Modal HTML and its script block. #}

    {# Add a Chat tab to the navbar #}
    {# This <li> is now inside the navbar <ul> #}

    {# Add the Chat Modal with tabs for DMs, Assistant, and Groups #}
    <div class="modal fade" id="chatModal" tabindex="-1" aria-labelledby="chatModalLabel" aria-hidden="true">
      <div class="modal-dialog modal-lg modal-dialog-centered">
        <div class="modal-content">
          <div class="modal-header">
            <h5 class="modal-title" id="chatModalLabel">Chat</h5>
            <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
          </div>
          <div class="modal-body">
            <ul class="nav nav-tabs" id="chatTab" role="tablist" style="margin-bottom: 1rem;">
              <li class="nav-item" role="presentation">
                <button class="nav-link active" id="dm-tab" data-bs-toggle="tab" data-bs-target="#dmTabPane" type="button" role="tab">DMs</button>
              </li>
              <li class="nav-item" role="presentation">
                <button class="nav-link" id="assistant-tab" data-bs-toggle="tab" data-bs-target="#assistantTabPane" type="button" role="tab">Assistant</button>
              </li>
              <li class="nav-item" role="presentation">
                <button class="nav-link" id="group-tab" data-bs-toggle="tab" data-bs-target="#groupTabPane" type="button" role="tab">Groups</button>
              </li>
            </ul>
            <div class="tab-content" id="chatTabContent">
              <div class="tab-pane fade show active" id="dmTabPane" role="tabpanel">
                <div id="dmChatContainer" style="max-height: 300px; overflow-y: auto; border: 1px solid #eee; border-radius: 8px; padding: 10px; margin-bottom: 10px; background: #fff;"></div>
                <div class="input-group mt-3">
                  <input type="text" class="form-control" id="dmChatInput" placeholder="Type a message...">
                  <button class="btn btn-primary" id="dmSendBtn">Send</button>
                </div>
              </div>
              <div class="tab-pane fade" id="assistantTabPane" role="tabpanel">
                <div id="assistantChatContainer" style="max-height: 300px; overflow-y: auto; border: 1px solid #eee; border-radius: 8px; padding: 10px; margin-bottom: 10px; background: #fff;"></div>
                <div class="input-group mt-3">
                  <input type="text" class="form-control" id="assistantChatInput" placeholder="Ask the assistant...">
                  <button class="btn btn-primary" id="assistantSendBtn">Send</button>
                </div>
              </div>
              <div class="tab-pane fade" id="groupTabPane" role="tabpanel">
                <div class="mb-2">
                  <input type="text" id="groupNameInput" class="form-control form-control-sm d-inline-block" style="width: 200px; display: inline-block;" placeholder="Group name">
                  <button class="btn btn-outline-primary btn-sm" id="joinGroupBtn">Join/Create Group</button>
                  <select id="currentGroupSelect" class="form-select form-select-sm d-inline-block" style="width: 200px; display: inline-block;"></select>
                  <button class="btn btn-outline-danger btn-sm" id="leaveGroupBtn">Leave Group</button>
                </div>
                <div id="groupChatContainer" style="max-height: 300px; overflow-y: auto; border: 1px solid #eee; border-radius: 8px; padding: 10px; margin-bottom: 10px; background: #fff;"></div>
                <div class="input-group mt-3">
                  <input type="text" class="form-control" id="groupChatInput" placeholder="Type a group message...">
                  <button class="btn btn-primary" id="groupSendBtn">Send</button>
                </div>
              </div>
            </div>
          </div>
        </div>
      </div>
    </div>

    <script>
    document.addEventListener('DOMContentLoaded', function() {
            // Global safeguard: prevent anchors with href="#" from changing the hash/scroll
            // Many templates use href="#" for buttons; on some mobile browsers tapping these
            // will jump the page to the top. Intercept and prevent default for those anchors.
            document.body.addEventListener('click', function(e) {
                try {
                    // Find nearest anchor element
                    const anchor = e.target.closest && e.target.closest('a');
                    if (!anchor) return;

                    const href = (anchor.getAttribute('href') || '').trim();

                    // Allow anchors used by Bootstrap or ARIA controls to function
                    const isToggle = anchor.hasAttribute('data-bs-toggle') || anchor.hasAttribute('data-toggle') || anchor.getAttribute('role') === 'button' || anchor.hasAttribute('data-bs-target') || anchor.hasAttribute('aria-controls');

                    // If href is empty, just '#', javascript:void, or '#' plus whitespace, prevent navigation
                    const isHarmlessHash = href === '#' || href === '' || href.toLowerCase().startsWith('javascript:') || href === '#!';

                    if (isHarmlessHash && !isToggle) {
                        // Prevent default navigation which can jump to top on mobile browsers
                        e.preventDefault();

                        // If the anchor is being used purely as a wrapper for a control element,
                        // forward the click to the first interactive child so existing handlers run.
                        const innerBtn = anchor.querySelector('button, [role="button"], input[type="button"], input[type="submit"]');
                        if (innerBtn) {
                            // Dispatch a click event on the inner control in a safe way
                            try { innerBtn.click(); } catch (err) { /* ignore */ }
                        }
                        return;
                    }

                    // If this is an href to an internal hash targeting an element on the page,
                    // allow default behavior only if the element exists; otherwise prevent jump
                    if (href.startsWith('#') && href.length > 1 && !isToggle) {
                        const targetEl = document.getElementById(href.slice(1));
                        if (!targetEl) {
                            e.preventDefault();
                            return;
                        }
                    }
                } catch (err) {
                    // swallow errors to avoid breaking pages
                    console.warn('anchor click safeguard error', err);
                }
            }, { passive: false });

            // Additional narrow-screen capture-phase guard: record scrollY before clicks
            // and prevent stray href="#" clicks from jumping the page on small viewports.
            document.addEventListener('click', function(e) {
                try {
                    // Only active for narrow screens where this is a frequent problem
                    if (window.innerWidth > 900) return;

                    // Snapshot before click
                    const beforeY = window.pageYOffset || document.documentElement.scrollTop || 0;

                    const anchor = e.target.closest && e.target.closest('a');
                    if (!anchor) return;

                    const href = (anchor.getAttribute('href') || '').trim();
                    if (!href || href === '#' || href.toLowerCase().startsWith('javascript:')) {
                        // Prevent default navigation
                        if (e.cancelable) e.preventDefault();
                        // After a microtask, if scroll moved to top, restore it
                        Promise.resolve().then(() => {
                            const afterY = window.pageYOffset || document.documentElement.scrollTop || 0;
                            if (afterY === 0 && beforeY > 50) {
                                // Use safeRestoreScroll if available to cooperate with stabilizer
                                if (window.safeRestoreScroll && typeof window.safeRestoreScroll === 'function') {
                                    window.safeRestoreScroll(beforeY, { behavior: 'auto', timeout: 300 });
                                } else {
                                    try { window.scrollTo(0, beforeY); } catch(e){}
                                }
                            }
                        });
                        return;
                    }
                } catch (err) {
                    console.warn('narrow-screen click guard error', err);
                }
            }, { passive: false, capture: true });

            // Prevent focus() calls from scrolling the page in browsers that don't support
            // the preventScroll option reliably. We wrap focus to provide preventScroll when possible.
            (function(){
                try {
                    const origFocus = HTMLElement.prototype.focus;
                    HTMLElement.prototype.focus = function(options){
                        if (typeof options === 'object' && options && options.preventScroll) {
                            // browser supports options, call through
                            return origFocus.call(this, options);
                        }
                        // Try to call with preventScroll option first
                        try {
                            return origFocus.call(this, { preventScroll: true });
                        } catch(e) {
                            // Fallback to original focus without scrolling
                            try { return origFocus.call(this); } catch(e2) { /* ignore */ }
                        }
                    };
                } catch (e) { /* ignore if prototype can't be modified */ }
            })();

            // Page-scoped defensive guard: prevent immediate scroll-to-top calls
            // caused by third-party code right after a user click inside the scouting form.
            // We now implement this by listening for clicks inside the form and, when
            // necessary, using the global safeRestoreScroll helper to perform intended
            // restores. The stabilizer suppression flag is handled by safeRestoreScroll.
            try {
                if (window.location.pathname && window.location.pathname.includes('/scouting/form')) {
                    // When user clicks in the form content, mark the element so any
                    // legitimate restore code can route through safeRestoreScroll.
                    document.body.addEventListener('click', function(ev) {
                        try {
                            const inForm = ev.target && ev.target.closest && (ev.target.closest('#form-content') || ev.target.closest('#scouting-form'));
                            if (inForm) {
                                // Attach a short-lived marker to the document that other code
                                // can check before calling window.scrollTo directly. Prefer
                                // to call safeRestoreScroll instead of calling window.scrollTo.
                                window.__recentlyClickedInScoutingForm = Date.now();
                                window.setTimeout(function(){ try { delete window.__recentlyClickedInScoutingForm; } catch(e){} }, 350);
                            }
                        } catch (e) { /* ignore */ }
                    }, true);
                }
            } catch (e) { /* ignore overall errors */ }
        // Open modal on button click


        // Socket.IO setup
        if (!window.socket) {
            window.socket = io();
        }
        const socket = window.socket;
    const recipientSelect = document.getElementById('assistantChatRecipient');
    const chatContainer = document.getElementById('assistantChatContainer');
    const chatInput = document.getElementById('assistantChatInput');
    const sendBtn = document.getElementById('assistantSendBtn');
    const deleteBtn = document.getElementById('assistantDeleteHistoryBtn');
        let allMessages = [];
        let currentRecipient = 'assistant';
        let usernameLoaded = false;

        // Fetch user list for chat (including 'assistant')
        function fetchRecipients() {
            // If the recipient select isn't present on this page, no-op
            if (!recipientSelect) return Promise.resolve();
            return fetch('/assistant/chat-users')
                .then(r => r.json())
                .then(data => {
                    recipientSelect.innerHTML = '';
                    // Always add assistant as an option
                    const optAssistant = document.createElement('option');
                    optAssistant.value = 'assistant';
                    optAssistant.textContent = 'Assistant';
                    recipientSelect.appendChild(optAssistant);
                    // Add users
                    data.users.forEach(u => {
                        const opt = document.createElement('option');
                        opt.value = u;
                        opt.textContent = u + (u === data.current_user ? ' (You)' : '');
                        recipientSelect.appendChild(opt);
                    });
                });
        }

        if (recipientSelect) {
            recipientSelect.addEventListener('change', function() {
                currentRecipient = this.value;
                renderHistory(allMessages);
            });
        }

        function renderMessage(msg) {
            // Only show messages for the selected recipient
            if ((currentRecipient === 'assistant' && msg.recipient === 'assistant') ||
                (msg.sender === currentRecipient && msg.recipient === window.currentUsername) ||
                (msg.sender === window.currentUsername && msg.recipient === currentRecipient)) {
                const div = document.createElement('div');
                div.className = 'mb-2';
                div.innerHTML = `<strong>${msg.sender}:</strong> <span>${msg.text}</span> <span class="text-muted" style="font-size:0.8em;">${new Date(msg.timestamp).toLocaleTimeString()}</span>`;
                chatContainer.appendChild(div);
                chatContainer.scrollTop = chatContainer.scrollHeight;
            }
        }

        function renderHistory(history) {
            chatContainer.innerHTML = '';
            allMessages = history;
            history.forEach(renderMessage);
        }

        socket.on('assistant_chat_message', function(msg) {
            allMessages.push(msg);
            renderMessage(msg);
        });
        socket.on('assistant_chat_history', renderHistory);

        if (sendBtn) {
            sendBtn.disabled = true;

            sendBtn.addEventListener('click', function() {
                const text = (chatInput && chatInput.value || '').trim();
                if (text && window.currentUsername) {
                    console.log('Sending:', { text, recipient: currentRecipient, sender: window.currentUsername });
                    socket.emit('assistant_chat_message', { text, recipient: currentRecipient, sender: window.currentUsername });
                    if (chatInput) chatInput.value = '';
                } else {
                    alert('Username not loaded yet. Please wait.');
                }
            });
            if (chatInput) {
                chatInput.addEventListener('keypress', function(e) {
                    if (e.key === 'Enter') sendBtn.click();
                });
            }
        }

        if (deleteBtn) {
            deleteBtn.addEventListener('click', function() {
                fetch('/assistant/delete-chat-history', { method: 'POST' })
                    .then(r => r.json())
                    .then(data => {
                        if (data.success) {
                            if (chatContainer) chatContainer.innerHTML = '';
                        } else {
                            alert(data.message || 'Failed to delete chat history');
                        }
                    });
            });
        }

        // On modal open, fetch recipients and chat history
        const openBtn = document.getElementById('openAssistantModalBtn');
        if (openBtn) {
            openBtn.addEventListener('click', function() {
                const modal = new bootstrap.Modal(document.getElementById('assistantModal'));
                modal.show();
                fetchRecipients();
                if (window.socket) {
                    window.socket.emit('assistant_chat_history_request');
                }
            });
        }

        // Get current username for filtering
        fetch('/assistant/chat-users').then(r => r.json()).then(data => {
            window.currentUsername = data.current_user;
            sendBtn.disabled = false;
            usernameLoaded = true;
            console.log('Current username loaded:', window.currentUsername);
        });

        // Open chat modal from navbar
        const openChatModalNav = document.getElementById('openChatModalNav');
        if (openChatModalNav) {
            openChatModalNav.addEventListener('click', function(e) {
                e.preventDefault();
                const modal = new bootstrap.Modal(document.getElementById('chatModal'));
                modal.show();
            });
        }
        // Assistant tab logic: send message to /assistant/ask and display response
        const assistantSendBtn = document.getElementById('assistantSendBtn');
        const assistantChatInput = document.getElementById('assistantChatInput');
        const assistantChatContainer = document.getElementById('assistantChatContainer');
        assistantSendBtn.addEventListener('click', async function() {
            const question = assistantChatInput.value.trim();
            if (!question) return;
            // Show user message
            const userDiv = document.createElement('div');
            userDiv.className = 'mb-2';
            userDiv.innerHTML = `<strong>You:</strong> <span>${question}</span>`;
            assistantChatContainer.appendChild(userDiv);
            assistantChatInput.value = '';
            assistantChatContainer.scrollTop = assistantChatContainer.scrollHeight;
            // Send to backend
            const response = await fetch('/assistant/ask', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ question })
            });
            const data = await response.json();
            const botDiv = document.createElement('div');
            botDiv.className = 'mb-2';
            botDiv.innerHTML = `<strong>Assistant:</strong> <span>${data.text || data.message || 'No response.'}</span>`;
            assistantChatContainer.appendChild(botDiv);
            assistantChatContainer.scrollTop = assistantChatContainer.scrollHeight;
        });
        assistantChatInput.addEventListener('keypress', function(e) {
            if (e.key === 'Enter') assistantSendBtn.click();
        });
        // ... (existing DM and group chat logic would go here) ...
    });
    </script>
    <script>
    document.addEventListener('DOMContentLoaded', function() {
        async function updateChatUnreadBadge() {
            try {
                const resp = await fetch('/chat/state');
                const data = await resp.json();
                const badge = document.getElementById('chatUnreadBadge');
                const userDot = document.getElementById('userChatDot');
                const userUnreadItem = document.getElementById('userDropdownUnreadItem');
                const openUnreadChatLink = document.getElementById('openUnreadChatLink');
                if (badge) {
                    if (data.unreadCount && data.unreadCount > 0) {
                        badge.textContent = data.unreadCount;
                        badge.style.display = '';
                        // show red dot on user dropdown
                        if (userDot) userDot.style.display = '';
                        if (userUnreadItem) userUnreadItem.style.display = '';
                        // if backend provided a source, add it as query param so chat page can focus
                        if (openUnreadChatLink && data.lastSource) {
                            // lastSource could be {type: 'dm'|'group', id: 'username'|'groupname'}
                            try {
                                const s = encodeURIComponent(JSON.stringify(data.lastSource));
                                openUnreadChatLink.href = `{{ url_for('main.chat_page') }}?focus=${s}`;
                            } catch(e) {}
                        } else if (openUnreadChatLink) {
                            openUnreadChatLink.href = `{{ url_for('main.chat_page') }}`;
                        }
                    } else {
                        badge.style.display = 'none';
                        if (userDot) userDot.style.display = 'none';
                        if (userUnreadItem) userUnreadItem.style.display = 'none';
                    }
                }
            } catch (e) {}
        }
        // Update on page load
        updateChatUnreadBadge();
        // Poll every 10 seconds
        setInterval(updateChatUnreadBadge, 10000);
        // Listen for real-time DM and group chat events if socket.io is available
        if (window.socket) {
            window.socket.on('dm_message', function(msg) {
                if (!window.location.pathname.startsWith('/chat')) {
                    // include source info so dropdown can open focused DM
                    fetch('/chat/increment-unread', {method: 'POST', headers: {'Content-Type':'application/json'}, body: JSON.stringify({lastSource: {type: 'dm', id: msg.sender}})}).then(updateChatUnreadBadge);
                }
            });
            // Group chat messages are disabled in this build; no-op.
        }
        // When chat page/modal is opened, reset unread count
        const chatNavItem = document.getElementById('chatNavItem');
        if (chatNavItem) {
            chatNavItem.addEventListener('click', function() {
                // When user opens chat, clear unread and any source pointer
                fetch('/chat/reset-unread', {method: 'POST'}).then(updateChatUnreadBadge);
            });
        }
        
        // ======== REAL-TIME CONFIG SYNC ========
        
        // Store current config data globally
        window.currentConfig = {
            game_config: null,
            pit_config: null,
            alliance_status: null
        };
        
        // Track if this is the initial config load
        window.configInitialized = false;
        
        // Function to fetch current configuration
        function fetchCurrentConfig() {
            return fetch('/alliances/scouting/config/current')
                .then(response => response.json())
                .then(data => {
                    window.currentConfig = data;
                    return data;
                })
                .catch(error => {
                    console.warn('Could not fetch current config:', error);
                    return null;
                });
        }
        
        // Function to update alliance status in navigation
        function updateAllianceStatusNav(allianceStatus, allianceInfo) {
            const allianceStatusElement = document.querySelector('[data-alliance-status]');
            if (allianceStatusElement) {
                if (allianceStatus) {
                    allianceStatusElement.innerHTML = `
                        <div class="d-flex align-items-center">
                            <i class="fas fa-users me-1"></i>Alliance Mode Active
                            <small class="text-muted ms-1">
                                ${allianceInfo ? allianceInfo.alliance_name : ''}
                            </small>
                        </div>
                    `;
                    allianceStatusElement.style.display = 'block';
                } else {
                    allianceStatusElement.style.display = 'none';
                }
            }
        }
        
        // Function to show auto-sync notifications
        function showAutoSyncNotification(message, type = 'info') {
            // Create a notification banner
            const notification = document.createElement('div');
            notification.className = `alert alert-${type} alert-dismissible fade show position-fixed`;
            notification.style.cssText = 'top: 80px; right: 20px; z-index: 9999; max-width: 400px; box-shadow: 0 4px 8px rgba(0,0,0,0.2);';
            
            const iconMap = {
                'info': 'fas fa-sync-alt',
                'success': 'fas fa-check-circle',
                'warning': 'fas fa-exclamation-triangle',
                'danger': 'fas fa-times-circle'
            };
            
            const icon = iconMap[type] || iconMap['info'];
            
            notification.innerHTML = `
                <div class="d-flex align-items-center">
                    <i class="${icon} me-2"></i>
                    <div>
                        <strong>Alliance Auto-Sync</strong><br>
                        <small>${message}</small>
                    </div>
                </div>
                <button type="button" class="btn-close" data-bs-dismiss="alert"></button>
            `;
            
            document.body.appendChild(notification);
            
            // Auto-remove after 8 seconds
            setTimeout(() => {
                if (notification.parentNode) {
                    const bsAlert = new bootstrap.Alert(notification);
                    bsAlert.close();
                }
            }, 8000);
        }
        
        // Function to trigger config refresh events for other scripts
        function triggerConfigUpdate(configData, isInitialLoad = false) {
            // Only dispatch update events if this is not the initial load
            if (!isInitialLoad && window.configInitialized) {
                // Dispatch custom events that other pages can listen to
                window.dispatchEvent(new CustomEvent('configUpdated', {
                    detail: configData
                }));
                
                window.dispatchEvent(new CustomEvent('gameConfigUpdated', {
                    detail: configData.game_config
                }));
                
                window.dispatchEvent(new CustomEvent('pitConfigUpdated', {
                    detail: configData.pit_config
                }));
                
                window.dispatchEvent(new CustomEvent('allianceStatusUpdated', {
                    detail: configData.alliance_status
                }));
                
                console.log('Config update events dispatched for real change');
            } else {
                console.log('Skipping config update events for initial load');
            }
        }
        
        // Socket.IO listeners for real-time updates
        if (window.socket) {
            // Auto-join team room when connected
            window.socket.on('connect', function() {
                console.log('Socket.IO connected, joining team room...');
                {% if current_user.is_authenticated and current_user.scouting_team_number %}
                    window.socket.emit('join_team_room');
                    console.log('Joined team room for team {{ current_user.scouting_team_number }}');
                {% endif %}
            });
            
            // Handle team room join confirmation
            window.socket.on('joined_team_room', function(data) {
                console.log('Successfully joined team room:', data.team_number);
            });
            
            // Listen for alliance mode toggles
            window.socket.on('alliance_mode_toggled', function(data) {
                console.log('Alliance mode toggled:', data);
                window.currentConfig.game_config = data.effective_game_config;
                window.currentConfig.pit_config = data.effective_pit_config;
                window.currentConfig.alliance_status = {
                    is_active: data.alliance_status,
                    alliance_info: data.alliance_info,
                    team_number: data.team_number
                };
                
                triggerConfigUpdate(window.currentConfig, false); // This is a real update
                updateAllianceStatusNav(data.alliance_status, data.alliance_info);
            });
            
            // Listen for general config updates
            window.socket.on('config_updated', function(data) {
                console.log('Config updated:', data);
                window.currentConfig.game_config = data.effective_game_config;
                window.currentConfig.pit_config = data.effective_pit_config;
                window.currentConfig.alliance_status = {
                    is_active: data.alliance_status,
                    alliance_info: data.alliance_info,
                    team_number: data.team_number
                };
                
                triggerConfigUpdate(window.currentConfig, false); // This is a real update
            });
            
            // Listen for alliance status changes (for nav bar updates)
            window.socket.on('alliance_status_changed', function(data) {
                console.log('Alliance status changed:', data);
                updateAllianceStatusNav(data.alliance_status, data.alliance_info);
            });
            
            // ======== ALLIANCE AUTO-SYNC HANDLERS ========
            // Listen for automatic alliance data sync
            window.socket.on('alliance_data_sync_auto', function(data) {
                console.log('Received auto-sync data from Team', data.from_team);
                
                // Automatically send acknowledgment that we received the data
                window.socket.emit('alliance_auto_sync_received', data);
                
                // Show notification about incoming data (less verbose for periodic syncs)
                if (data.type === 'periodic_sync') {
                    // Only show periodic sync notifications if there's substantial data
                    const totalEntries = data.scouting_data.length + data.pit_data.length;
                    if (totalEntries > 0) {
                        console.log(`Periodic sync: Received ${totalEntries} entries from Team ${data.from_team}`);
                        // Show subtle notification only for large periodic syncs
                        if (totalEntries >= 5) {
                            showAutoSyncNotification(`Periodic sync: ${totalEntries} entries from Team ${data.from_team}`, 'info');
                        }
                    }
                } else {
                    // Show full notifications for manual/immediate syncs
                    if (data.scouting_data.length > 0) {
                        showAutoSyncNotification(`Received ${data.scouting_data.length} scouting entries from Team ${data.from_team} (${data.alliance_name})`);
                    }
                    if (data.pit_data.length > 0) {
                        showAutoSyncNotification(`Received ${data.pit_data.length} pit scouting entries from Team ${data.from_team} (${data.alliance_name})`);
                    }
                }
            });
            
            // Listen for auto-sync completion confirmations
            window.socket.on('alliance_auto_sync_complete', function(data) {
                console.log('Auto-sync completed:', data);
                if (data.imported_count > 0) {
                    if (data.type === 'periodic_sync') {
                        // Less verbose for periodic syncs
                        console.log(`Periodic sync completed: imported ${data.imported_count} entries from Team ${data.from_team}`);
                        // Only show notification for substantial periodic imports
                        if (data.imported_count >= 3) {
                            showAutoSyncNotification(`Periodic sync: imported ${data.imported_count} entries from Team ${data.from_team}`, 'success');
                        }
                    } else {
                        // Full notification for manual syncs
                        showAutoSyncNotification(`Successfully imported ${data.imported_count} entries from Team ${data.from_team} (${data.alliance_name})`, 'success');
                    }
                    
                    // Refresh current page if it's data-related
                    if (window.location.pathname.includes('/scouting') || 
                        window.location.pathname.includes('/analysis') || 
                        window.location.pathname.includes('/pit-scouting')) {
                        setTimeout(() => {
                            window.location.reload();
                        }, 2000);
                    }
                }
            });
            
            // ======== GLOBAL CONFIG CHANGE HANDLER ========
            // Listen for global config changes that affect ALL pages
            window.socket.on('global_config_changed', function(data) {
                console.log('Global config changed:', data);
                
                // Update local config cache
                window.currentConfig.game_config = data.effective_game_config;
                window.currentConfig.pit_config = data.effective_pit_config;
                window.currentConfig.alliance_status = {
                    is_active: data.alliance_status,
                    alliance_info: data.alliance_info,
                    team_number: data.team_number
                };
                
                // Trigger all config update events
                triggerConfigUpdate(window.currentConfig, false);
                updateAllianceStatusNav(data.alliance_status, data.alliance_info);
                
                // Dispatch global reload events for pages to refresh their content
                window.dispatchEvent(new CustomEvent('globalConfigReload', {
                    detail: {
                        type: data.type,
                        message: data.message,
                        game_config: data.effective_game_config,
                        pit_config: data.effective_pit_config,
                        alliance_status: data.alliance_status,
                        alliance_info: data.alliance_info,
                        timestamp: data.timestamp
                    }
                }));
                
                // Show user notification
                if (data.message) {
                    showGlobalConfigNotification(data.message, data.type);
                }
                
                // Reload page content that depends on config
                reloadConfigDependentContent();
            });
        }
        
        // ======== GLOBAL CONFIG MANAGEMENT FUNCTIONS ========
        
        // Function to show global config notifications
        function showGlobalConfigNotification(message, type) {
            // Create or update notification element
            let notificationId = 'global-config-notification';
            let existingNotification = document.getElementById(notificationId);
            
            if (existingNotification) {
                existingNotification.remove();
            }
            
            const notificationHtml = `
                <div id="${notificationId}" class="alert alert-info alert-dismissible fade show position-fixed" 
                     style="top: 20px; right: 20px; z-index: 9999; max-width: 400px;">
                    <div class="d-flex align-items-center">
                        <i class="fas fa-sync-alt me-2"></i>
                        <div>
                            <strong>Configuration Updated</strong><br>
                            <small>${message}</small>
                        </div>
                    </div>
                    <button type="button" class="btn-close" data-bs-dismiss="alert"></button>
                </div>
            `;
            
            document.body.insertAdjacentHTML('beforeend', notificationHtml);
            
            // Auto-remove after 5 seconds
            setTimeout(() => {
                const notification = document.getElementById(notificationId);
                if (notification) {
                    notification.remove();
                }
            }, 5000);
        }
        
        // Function to reload config-dependent content on the current page
        function reloadConfigDependentContent() {
            const currentPath = window.location.pathname;
            
            // Page-specific content reloading
            if (currentPath.includes('/scouting/form')) {
                reloadScoutingFormContent();
            } else if (currentPath.includes('/graphs') || currentPath.includes('/analytics')) {
                reloadAnalyticsContent();
            } else if (currentPath.includes('/pit_scouting')) {
                reloadPitScoutingContent();
            } else if (currentPath.includes('/matches')) {
                reloadMatchesContent();
            } else if (currentPath.includes('/alliances')) {
                reloadAlliancesContent();
            }
            
            // Reload any generic config-dependent elements
            reloadGenericConfigElements();
        }
        
        // Page-specific reload functions
        function reloadScoutingFormContent() {
            // Trigger form reload if function exists
            if (typeof window.reloadFormWithNewConfig === 'function') {
                window.reloadFormWithNewConfig();
            }
        }
        
        function reloadAnalyticsContent() {
            // Trigger analytics reload if function exists
            if (typeof window.reloadAnalyticsWithNewConfig === 'function') {
                window.reloadAnalyticsWithNewConfig();
            }
        }
        
        function reloadPitScoutingContent() {
            // Trigger pit scouting reload if function exists
            if (typeof window.reloadPitScoutingWithNewConfig === 'function') {
                window.reloadPitScoutingWithNewConfig();
            }
        }
        
        function reloadMatchesContent() {
            // Trigger matches reload if function exists
            if (typeof window.reloadMatchesWithNewConfig === 'function') {
                window.reloadMatchesWithNewConfig();
            }
        }
        
        function reloadAlliancesContent() {
            // Trigger alliances reload if function exists
            if (typeof window.reloadAlliancesWithNewConfig === 'function') {
                window.reloadAlliancesWithNewConfig();
            }
        }
        
        function reloadGenericConfigElements() {
            // Reload any elements with data-config-dependent attribute
            const configElements = document.querySelectorAll('[data-config-dependent]');
            configElements.forEach(element => {
                const reloadType = element.getAttribute('data-config-dependent');
                if (reloadType === 'game' && window.currentConfig.game_config) {
                    // Trigger custom event for this element
                    element.dispatchEvent(new CustomEvent('configReload', {
                        detail: { config: window.currentConfig.game_config, type: 'game' }
                    }));
                } else if (reloadType === 'pit' && window.currentConfig.pit_config) {
                    element.dispatchEvent(new CustomEvent('configReload', {
                        detail: { config: window.currentConfig.pit_config, type: 'pit' }
                    }));
                }
            });
        }
        
        // Initial config fetch on page load
        fetchCurrentConfig().then(configData => {
            if (configData) {
                triggerConfigUpdate(configData, true); // Mark as initial load
                updateAllianceStatusNav(
                    configData.alliance_status.is_active, 
                    configData.alliance_status.alliance_info
                );
                window.configInitialized = true; // Mark config as initialized
            }
        });
        
        // Navbar improvements
        function initNavbarImprovements() {
            // Sync chat badges between desktop and mobile
            function syncChatBadges() {
                const desktopBadge = document.getElementById('chatUnreadBadge');
                const mobileBadge = document.getElementById('chatUnreadBadgeMobile');
                
                if (desktopBadge && mobileBadge) {
                    // Sync visibility
                    if (desktopBadge.style.display !== 'none') {
                        mobileBadge.style.display = 'inline';
                        mobileBadge.textContent = desktopBadge.textContent;
                    } else {
                        mobileBadge.style.display = 'none';
                    }
                }
            }
            
            // Observe changes to desktop badge
            const desktopBadge = document.getElementById('chatUnreadBadge');
            if (desktopBadge) {
                const observer = new MutationObserver(syncChatBadges);
                observer.observe(desktopBadge, {
                    attributes: true,
                    childList: true,
                    subtree: true
                });
                syncChatBadges(); // Initial sync
            }
            
            // Enhanced dropdown animations
            const dropdowns = document.querySelectorAll('.dropdown-menu-animated');
            dropdowns.forEach(dropdown => {
                const parent = dropdown.closest('.dropdown');
                if (parent) {
                    parent.addEventListener('show.bs.dropdown', function() {
                        dropdown.classList.add('show');
                    });
                    
                    parent.addEventListener('hide.bs.dropdown', function() {
                        dropdown.classList.remove('show');
                    });
                }
            });
            
            // Close mobile menu when clicking outside
            document.addEventListener('click', function(e) {
                const navbarCollapse = document.getElementById('navbarMain');
                const navbarToggler = document.querySelector('.navbar-toggler');
                
                if (navbarCollapse && navbarCollapse.classList.contains('show')) {
                    if (!navbarCollapse.contains(e.target) && !navbarToggler.contains(e.target)) {
                        const collapse = new bootstrap.Collapse(navbarCollapse, {
                            toggle: false
                        });
                        collapse.hide();
                    }
                }
            });
            
            // Smooth scroll for navbar brand
            const navbarBrand = document.querySelector('.navbar-brand');
            if (navbarBrand) {
                navbarBrand.addEventListener('click', function(e) {
                    // Only smooth scroll if we're on the same page
                    const href = this.getAttribute('href');
                    if (href && window.location.pathname === href) {
                        e.preventDefault();
                        try {
                            if (window.safeRestoreScroll && typeof window.safeRestoreScroll === 'function') {
                                // Route through global helper so it coordinates with mobile stabilizer
                                window.safeRestoreScroll(0, { behavior: 'smooth', timeout: 200 });
                            } else {
                                // Fallback for older pages/environments
                                window.scrollTo({ top: 0, behavior: 'smooth' });
                            }
                        } catch (err) {
                            try { window.scrollTo({ top: 0, behavior: 'smooth' }); } catch(e) {}
                        }
                    }
                });
            }
            
            // Active state management for single-page navigation
            function updateActiveNavItem() {
                const currentPath = window.location.pathname;
                const navLinks = document.querySelectorAll('.nav-link, .dropdown-item');
                
                navLinks.forEach(link => {
                    const href = link.getAttribute('href');
                    if (href === currentPath) {
                        link.classList.add('active');
                        
                        // Also activate parent dropdown if this is a dropdown item
                        const parentDropdown = link.closest('.dropdown');
                        if (parentDropdown) {
                            const parentToggle = parentDropdown.querySelector('.dropdown-toggle');
                            if (parentToggle) {
                                parentToggle.classList.add('active');
                            }
                        }
                    }
                });
            }
            
            // Call on initial load
            updateActiveNavItem();
        }
        
        // Initialize navbar improvements
        initNavbarImprovements();

            // Clear unread button (x) handler
            const clearUnreadBtn = document.getElementById('clearUnreadBtn');
            if (clearUnreadBtn) {
                clearUnreadBtn.addEventListener('click', function() {
                    fetch('/chat/reset-unread', { method: 'POST' })
                        .then(r => {
                            if (r.ok) {
                                // hide dot and this button
                                const dot = document.getElementById('userChatDot');
                                if (dot) dot.style.display = 'none';
                                clearUnreadBtn.style.display = 'none';
                                const unreadItem = document.getElementById('userDropdownUnreadItem');
                                if (unreadItem) unreadItem.style.display = 'none';
                                const chatBadge = document.getElementById('chatUnreadBadge');
                                if (chatBadge) { chatBadge.style.display = 'none'; chatBadge.textContent = '' }
                            }
                        }).catch(e => console.warn('Failed to clear unread', e));
                });
            }
        
        // Initialize search functionality
        initSearchFunctionality();
        
        // Reinitialize on window resize (when responsive classes change)
        window.addEventListener('resize', function() {
            clearTimeout(window.searchResizeTimeout);
            window.searchResizeTimeout = setTimeout(initSearchFunctionality, 250);
        });
        
        // Initialize dropdown positioning fix
        initDropdownPositioning();

        // Mobile: ensure touch devices reliably open dropdown toggles
        (function ensureTouchDropdowns(){
            if (!('ontouchstart' in window)) return; // only for touch devices
            document.querySelectorAll('.dropdown-toggle').forEach(btn => {
                // Avoid attaching multiple times
                if (btn.__touchHandlerAttached) return;
                btn.__touchHandlerAttached = true;

                btn.addEventListener('touchend', function(e){
                    // If bootstrap dropdown exists, toggle explicitly â€” this avoids issues when clicks are swallowed by overlays
                    try {
                        if (window.bootstrap && window.bootstrap.Dropdown) {
                            const inst = window.bootstrap.Dropdown.getOrCreateInstance(btn);
                            // If menu not shown, show it; otherwise let Bootstrap handle hide on outside tap
                            const menu = btn.closest('.dropdown')?.querySelector('.dropdown-menu');
                            if (menu && !menu.classList.contains('show')) {
                                inst.show();
                                e.preventDefault();
                            }
                        }
                    } catch (err) {
                        // Fallback to click to let browser/Bootstrap handle it
                        try { btn.click(); } catch(e){}
                    }
                }, { passive: false });
            });
        })();
        
        // Global fallback for any dropdown that opens in the navbar/topbar
        document.addEventListener('show.bs.dropdown', function(event) {
            const dropdown = event.target.closest('.navbar .dropdown, .topbar .dropdown');
            if (dropdown && window.innerWidth >= 992) {
                const toggle = dropdown.querySelector('.dropdown-toggle');
                const menu = dropdown.querySelector('.dropdown-menu');
                if (toggle && menu) {
                    setTimeout(() => {
                        positionFixedDropdown(toggle, menu);
                    }, 1);
                }
            }
        });

        // Also catch the shown event as a final fallback
        document.addEventListener('shown.bs.dropdown', function(event) {
            const dropdown = event.target.closest('.navbar .dropdown, .topbar .dropdown');
            if (dropdown && window.innerWidth >= 992) {
                const toggle = dropdown.querySelector('.dropdown-toggle');
                const menu = dropdown.querySelector('.dropdown-menu');
                if (toggle && menu) {
                    positionFixedDropdown(toggle, menu);
                }
            }
        });

        // Portal topbar dropdowns to body so they stay fixed during page scroll (desktop only)
        document.addEventListener('shown.bs.dropdown', function(event) {
            try {
                const dropdown = event.target.closest('.topbar .dropdown');
                if (!dropdown) return;
                // Only portal dropdowns on desktop where we handle fixed positioning.
                if (window.innerWidth < 992) return;
                const menu = dropdown.querySelector('.dropdown-menu');
                const toggle = dropdown.querySelector('.dropdown-toggle');
                if (!menu || !toggle) return;

                // If already portalled, just reposition
                if (menu.__portalPlaceholder) {
                    positionFixedDropdown(toggle, menu);
                    return;
                }

                // Create placeholder in original location
                const placeholder = document.createComment('dropdown-portal-placeholder');
                menu.parentNode.insertBefore(placeholder, menu);
                // Move menu to body and mark as navbar-glass so it matches topbar surface
                menu.classList.add('navbar-glass');
                document.body.appendChild(menu);
                // Mark placeholder for restoration
                menu.__portalPlaceholder = placeholder;

                // Make it fixed and position it
                menu.style.position = 'fixed';
                menu.style.zIndex = '1060';
                menu.style.willChange = 'transform, top, left';
                positionFixedDropdown(toggle, menu);

                // Destroy Popper instance if Bootstrap created one so it won't overwrite our fixed positioning on scroll
                try {
                    if (window.bootstrap && window.bootstrap.Dropdown) {
                        const bsInstance = window.bootstrap.Dropdown.getInstance(toggle);
                        if (bsInstance && bsInstance._popper) {
                            try { bsInstance._popper.destroy(); } catch(e){}
                            try { bsInstance._popper = null; } catch(e){}
                        }
                    }
                } catch (e) { /* ignore */ }

                // Remove any Popper-applied transform/inset so the menu remains where we placed it
                try {
                    menu.style.removeProperty('transform');
                    menu.style.removeProperty('inset');
                    menu.style.removeProperty('right');
                } catch (e) {}
            } catch (e) {
                // ignore portal errors
                console.warn('Dropdown portal error', e);
            }
        });

        // Restore portalled dropdowns when they hide
        document.addEventListener('hide.bs.dropdown', function(event) {
            try {
                const dropdown = event.target.closest('.topbar .dropdown');
                if (!dropdown) return;
                // The menu might already be in the dropdown or on body. Prefer any portalled menu (navbar-glass) first.
                const menu = document.querySelector('.dropdown-menu.navbar-glass') || dropdown.querySelector('.dropdown-menu') || document.querySelector('.dropdown-menu[aria-expanded="true"]');
                if (!menu) return;
                const placeholder = menu.__portalPlaceholder;
                if (!placeholder) return;

                // Grab the toggle so we can re-create Popper/Dropdown instances later
                const toggle = dropdown.querySelector('.dropdown-toggle');

                // Restore into original parent before the placeholder
                if (placeholder.parentNode) {
                    placeholder.parentNode.insertBefore(menu, placeholder);
                    placeholder.parentNode.removeChild(placeholder);
                } else {
                    // Fallback: append back to dropdown
                    dropdown.appendChild(menu);
                }

                // Remove glass class when restoring
                menu.classList.remove('navbar-glass');

                // Clean up styles
                menu.style.position = '';
                menu.style.left = '';
                menu.style.top = '';
                menu.style.right = '';
                menu.style.bottom = '';
                menu.style.zIndex = '';
                menu.style.willChange = '';
                // Reinitialize Popper/Dropdown for normal future behavior (if toggle exists)
                try {
                    if (toggle && window.bootstrap && window.bootstrap.Dropdown) {
                        // If there's an existing instance, dispose then re-create
                        const existing = window.bootstrap.Dropdown.getInstance(toggle);
                        if (existing && typeof existing.dispose === 'function') existing.dispose();
                        window.bootstrap.Dropdown.getOrCreateInstance(toggle);
                    }
                } catch (e) { /* ignore */ }

                // Normalize ARIA and classes so toggle and menu remain in a consistent hidden state
                try {
                    if (toggle) {
                        toggle.setAttribute('aria-expanded', 'false');
                        toggle.classList.remove('show');
                    }
                    if (menu) {
                        // Remove visibility classes and any Popper styles that might keep it visible
                        menu.classList.remove('show');
                        menu.style.removeProperty('transform');
                        menu.style.removeProperty('inset');
                        menu.removeAttribute('data-popper-placement');

                        // Clear any sizing/overflow we may have set while positioning
                        menu.style.removeProperty('max-height');
                        menu.style.removeProperty('maxWidth');
                        menu.style.removeProperty('overflow');
                        menu.style.removeProperty('overflow-y');

                        // Ensure it's not forcing display or opacity
                        menu.style.display = '';
                        try { menu.style.opacity = ''; } catch(e){}

                        // mark as just hidden to avoid immediate re-open from stray click events
                        try { menu.__justHidden = Date.now(); } catch(e){}
                    }
                } catch (e) { /* ignore */ }

                delete menu.__portalPlaceholder;
            } catch (e) {
                console.warn('Dropdown portal restore error', e);
            }
        });
    });
    
    // Fix dropdown positioning for navbar dropdowns
    function initDropdownPositioning() {
        // Only apply to desktop navbar dropdowns
        function handleDropdownPositioning() {
        if (window.innerWidth >= 992) {
            // Include both .navbar and topbar dropdowns so topbar menus are positioned fixed
            const navbarDropdowns = document.querySelectorAll('.navbar .dropdown, .topbar .dropdown');

            navbarDropdowns.forEach(dropdown => {
                const toggle = dropdown.querySelector('.dropdown-toggle');
                const menu = dropdown.querySelector('.dropdown-menu');
                    
                    if (toggle && menu) {
                        // Remove any existing event listeners to prevent duplicates
                        toggle.removeEventListener('click', handleDropdownClick);
                        dropdown.removeEventListener('show.bs.dropdown', handleDropdownShow);
                        dropdown.removeEventListener('shown.bs.dropdown', handleDropdownShown);
                        
                        // Add event listeners
                        toggle.addEventListener('click', handleDropdownClick);
                        dropdown.addEventListener('show.bs.dropdown', handleDropdownShow);
                        dropdown.addEventListener('shown.bs.dropdown', handleDropdownShown);
                        
                        function handleDropdownClick(e) {
                            // If the menu was just hidden (restored) very recently, ignore this click to
                            // avoid a double-toggle situation caused by reparenting and Popper timing.
                            try {
                                const now = Date.now();
                                if (menu && menu.__justHidden && (now - menu.__justHidden) < 400) {
                                    // Clear the flag and bail
                                    delete menu.__justHidden;
                                    return;
                                }
                            } catch (e) {}

                            setTimeout(() => {
                                if (menu.classList.contains('show')) {
                                    positionFixedDropdown(toggle, menu);
                                }
                            }, 5);
                        }
                        
                        function handleDropdownShow() {
                            setTimeout(() => {
                                if (menu.classList.contains('show')) {
                                    positionFixedDropdown(toggle, menu);
                                }
                            }, 5);
                        }
                        
                        function handleDropdownShown() {
                            positionFixedDropdown(toggle, menu);
                        }
                    }
                });
            } else {
                // Reset any fixed positioning for mobile
                const navbarDropdowns = document.querySelectorAll('.navbar .dropdown-menu, .topbar .dropdown-menu');
                navbarDropdowns.forEach(menu => {
                    menu.style.position = '';
                    menu.style.left = '';
                    menu.style.top = '';
                    menu.style.right = '';
                    menu.style.bottom = '';
                });
            }
        }
        
        handleDropdownPositioning();
        
        // Reposition on window resize
        window.addEventListener('resize', function() {
            handleDropdownPositioning();
            
            if (window.innerWidth >= 992) {
                const visibleDropdowns = document.querySelectorAll('.navbar .dropdown-menu.show');
                visibleDropdowns.forEach(menu => {
                    const toggle = menu.closest('.dropdown').querySelector('.dropdown-toggle');
                    if (toggle) {
                        positionFixedDropdown(toggle, menu);
                    }
                });
            }
        });
    }
    
    function positionFixedDropdown(toggle, menu) {
        if (window.innerWidth < 992) return; // Don't apply to mobile
        
        // Force the menu to be visible but transparent to measure it
        menu.style.opacity = '0';
        menu.style.display = 'block';
        menu.style.position = 'fixed';
        menu.style.zIndex = '1060';
        
        const toggleRect = toggle.getBoundingClientRect();
        const menuRect = menu.getBoundingClientRect();
        const viewportWidth = window.innerWidth;
        const viewportHeight = window.innerHeight;
        
        // More generous edge buffers
        const edgeBuffer = 15;
        const bottomBuffer = 20;
        
        // Calculate initial position
        let left = toggleRect.left;
        let top = toggleRect.bottom + 8; // 8px margin-top
        
        // Check if this is a right-aligned dropdown (like user menu)
        const isRightAligned = menu.classList.contains('dropdown-menu-end');
        
        if (isRightAligned) {
            // For right-aligned dropdowns, align to the right edge of the button
            left = toggleRect.right - menuRect.width;
            
            // Enhanced right edge detection - check if dropdown would go off screen
            if (left + menuRect.width > viewportWidth - edgeBuffer) {
                // Move dropdown further left to stay on screen
                left = viewportWidth - menuRect.width - edgeBuffer;
            }
            
            // Enhanced left edge detection - ensure dropdown doesn't go off left edge
            if (left < edgeBuffer) {
                left = edgeBuffer;
                // If dropdown is still too wide for screen, reduce its width
                if (menuRect.width > viewportWidth - (2 * edgeBuffer)) {
                    menu.style.maxWidth = (viewportWidth - (2 * edgeBuffer)) + 'px';
                    menu.style.overflowY = 'auto';
                }
            }
        } else {
            // For left-aligned dropdowns, check if they extend beyond right edge
            if (left + menuRect.width > viewportWidth - edgeBuffer) {
                // Try aligning to right edge of toggle button first
                let rightAlignedLeft = toggleRect.right - menuRect.width;
                if (rightAlignedLeft >= edgeBuffer) {
                    left = rightAlignedLeft;
                    menu.classList.add('dropdown-menu-end');
                } else {
                    // If that still doesn't work, force it to fit within viewport
                    left = viewportWidth - menuRect.width - edgeBuffer;
                    if (left < edgeBuffer) {
                        left = edgeBuffer;
                        menu.style.maxWidth = (viewportWidth - (2 * edgeBuffer)) + 'px';
                        menu.style.overflowY = 'auto';
                    }
                }
            } else {
                menu.classList.remove('dropdown-menu-end');
            }
            // Ensure left-aligned dropdowns don't go off the left edge
            left = Math.max(edgeBuffer, left);
        }
        
        // Enhanced bottom edge detection
        if (top + menuRect.height > viewportHeight - bottomBuffer) {
            // Try showing above the toggle button
            let newTop = toggleRect.top - menuRect.height - 8;
            if (newTop >= 0) {
                top = newTop;
            } else {
                // If it doesn't fit above either, constrain height and add scroll
                top = edgeBuffer;
                menu.style.maxHeight = (viewportHeight - (2 * edgeBuffer)) + 'px';
                menu.style.overflowY = 'auto';
            }
        }
        
        // Apply positioning with !important to override any conflicting CSS
        menu.style.setProperty('left', left + 'px', 'important');
        menu.style.setProperty('top', top + 'px', 'important');
        menu.style.setProperty('right', 'auto', 'important');
        menu.style.setProperty('bottom', 'auto', 'important');
        menu.style.setProperty('position', 'fixed', 'important');
        menu.style.opacity = '1'; // Make visible again
        
        // Debug logging (can be removed in production)
        if (window.location.hostname === 'localhost' || window.location.hostname === '127.0.0.1') {
            console.log('Dropdown positioned:', {
                toggleRect: toggleRect,
                menuRect: menuRect,
                finalLeft: left,
                finalTop: top,
                viewportWidth: viewportWidth,
                isRightAligned: isRightAligned
            });
        }
    }
    
    // Enhanced Search functionality
    // Global function for hiding suggestions
    window.hideSuggestions = function() {
    const searchSuggestions = document.getElementById('searchSuggestionsTop') || document.getElementById('searchSuggestions');
    const searchInput = document.getElementById('quickSearchInputTop') || document.getElementById('quickSearchInput');
        
        if (searchSuggestions) {
            searchSuggestions.classList.remove('show');
            searchSuggestions.style.display = 'none';
            selectedIndex = -1;
            if (searchInput) {
                searchInput.setAttribute('aria-expanded', 'false');
            }
            console.log('Suggestions hidden');
        }
    };

    // Global variables for search functionality
    let searchTimeout;
    let selectedIndex = -1;
    let currentSuggestions = [];
    
    // Global function for selecting suggestions
    window.selectSuggestion = function(text, type, searchQuery) {
        const searchInput = document.getElementById('quickSearchInput');
        const searchSuggestions = document.getElementById('searchSuggestions');
        
        if (searchInput) {
            // Use the provided searchQuery if available, otherwise fall back to extraction logic
            let finalSearchQuery = searchQuery;
            
            if (!finalSearchQuery) {
                // Extract meaningful search terms based on type (fallback)
                if (type === 'team') {
                    // For team suggestions like "Team 5454 - Obsidian", extract the team number
                    const teamNumberMatch = text.match(/Team (\d+)/);
                    if (teamNumberMatch) {
                        finalSearchQuery = teamNumberMatch[1]; // Just the team number (e.g., "5454")
                    } else {
                        // If no team number found, use the full text
                        finalSearchQuery = text;
                    }
                } else if (type === 'user') {
                    // For users, use the username as-is
                    finalSearchQuery = text;
                } else {
                    // For other types, use the full text
                    finalSearchQuery = text;
                }
            }
            
            console.log('Selected suggestion:', text, 'Searching for:', finalSearchQuery);
            
            searchInput.value = finalSearchQuery;
            window.hideSuggestions();
            
            // Navigate to search page with the optimized query
            window.location.href = `/search?q=${encodeURIComponent(finalSearchQuery)}`;
        }
    };

    function initSearchFunctionality() {
        // Check if screen is large enough for desktop search
        if (window.innerWidth < 992) {
            console.log('Screen too small for desktop search, skipping initialization');
            return;
        }
        
    const searchInput = document.getElementById('quickSearchInputTop') || document.getElementById('quickSearchInput');
    const searchSuggestions = document.getElementById('searchSuggestionsTop') || document.getElementById('searchSuggestions');
    const searchClearBtn = document.getElementById('searchClearBtnTop') || document.getElementById('searchClearBtn');
        
        console.log('Search elements found:', {
            searchInput: !!searchInput,
            searchSuggestions: !!searchSuggestions,
            searchClearBtn: !!searchClearBtn
        });
        
        if (!searchInput) {
            console.warn('No search input element found');
            return;
        }
        
        if (!searchSuggestions) {
            console.warn('searchSuggestions element not found');
            return;
        }
        
        // Position search suggestions using absolute positioning
        function positionSearchSuggestions() {
            if (searchSuggestions && searchInput) {
                console.log('Positioning search suggestions');
                
                // Get the search input wrapper position
                const inputWrapper = searchInput.closest('.search-input-wrapper');
                const inputRect = inputWrapper.getBoundingClientRect();
                
                // Position dropdown directly below the search bar
                searchSuggestions.style.cssText = `
                    position: fixed !important;
                    top: ${inputRect.bottom + 8}px !important;
                    left: ${inputRect.left}px !important;
                    width: ${Math.max(inputRect.width, 300)}px !important;
                    z-index: 2147483647 !important;
                    background: var(--bs-body-bg) !important;
                    border: 1px solid var(--bs-border-color) !important;
                    border-radius: 12px !important;
                    box-shadow: 0 8px 32px rgba(0, 0, 0, 0.15) !important;
                    display: block !important;
                    opacity: 1 !important;
                    visibility: visible !important;
                    pointer-events: auto !important;
                    overflow-y: auto !important;
                    max-height: 400px !important;
                    backdrop-filter: blur(10px) !important;
                    -webkit-backdrop-filter: blur(10px) !important;
                `;
                
                console.log('Modern dropdown positioning applied');
            }
        }
        
        // Show loading state
        function showLoading() {
            if (!searchSuggestions) return;
            console.log('Showing loading state');
            searchSuggestions.innerHTML = `
                <div class="search-loading" style="padding: 16px; text-align: center; color: var(--bs-secondary);">
                    <div class="spinner-border spinner-border-sm me-2" role="status" aria-hidden="true"></div>
                    Searching...
                </div>
            `;
            searchSuggestions.classList.add('show');
            positionSearchSuggestions();
        }
        
        // Handle search input with debouncing
        searchInput.addEventListener('input', function(e) {
            clearTimeout(searchTimeout);
            const query = this.value.trim();
            
            console.log('Input event (top/global):', query, 'length:', query.length);
            
            // Show/hide clear button
            if (searchClearBtn) {
                searchClearBtn.style.display = query ? 'flex' : 'none';
            }
            
            // Update ARIA attributes
            searchInput.setAttribute('aria-expanded', query.length >= 2 ? 'true' : 'false');
            
            // Hide suggestions immediately if search is empty
            if (query.length === 0) {
                window.hideSuggestions();
                return;
            }
            
            if (query.length < 2) {
                window.hideSuggestions();
                return;
            }
            
            // Show loading immediately for better UX
            showLoading();
            
            searchTimeout = setTimeout(() => {
                console.log('Fetching suggestions for:', query);
                fetchSuggestions(query);
            }, 300); // Increased delay to reduce API calls
        });
        
        // Clear button functionality
        if (searchClearBtn) {
            searchClearBtn.addEventListener('click', function() {
                searchInput.value = '';
                searchInput.focus();
                window.hideSuggestions();
                this.style.display = 'none';
                searchInput.setAttribute('aria-expanded', 'false');
            });
        }
        
        // Hide suggestions when search input loses focus (with delay for clicks)
        searchInput.addEventListener('blur', function() {
            // Small delay to allow for clicking on suggestions
            setTimeout(() => {
                window.hideSuggestions();
            }, 150);
        });
        
        // Show suggestions when search input gains focus (if there's content)
        searchInput.addEventListener('focus', function() {
            if (this.value.trim().length >= 2 && currentSuggestions.length > 0) {
                searchSuggestions.classList.add('show');
                positionSearchSuggestions();
            }
        });
        
        // Add click event delegation for suggestion items
        if (searchSuggestions) {
            searchSuggestions.addEventListener('click', function(e) {
                const suggestionItem = e.target.closest('.suggestion-item');
                if (suggestionItem) {
                    const text = suggestionItem.getAttribute('data-value');
                    const type = suggestionItem.getAttribute('data-type');
                    const searchQuery = suggestionItem.getAttribute('data-search-query');
                    if (text && type) {
                        window.selectSuggestion(text, type, searchQuery);
                    }
                }
            });
        } else {
            console.warn('searchSuggestions element not found for event delegation');
        }
        
        // Reposition dropdown on window resize
        window.addEventListener('resize', function() {
            if (searchSuggestions && searchSuggestions.classList.contains('show')) {
                positionSearchSuggestions();
            }
        });
        
        // Reposition dropdown on scroll
        window.addEventListener('scroll', function() {
            if (searchSuggestions && searchSuggestions.classList.contains('show')) {
                positionSearchSuggestions();
            }
        });
        
        window.addEventListener('resize', positionSearchSuggestions);
        
        // Enhanced keyboard navigation
        searchInput.addEventListener('keydown', function(e) {
            const suggestions = searchSuggestions?.querySelectorAll('.suggestion-item');
            
            if (!suggestions || suggestions.length === 0) {
                if (e.key === 'Enter') {
                    e.preventDefault();
                    performQuickSearch();
                }
                return;
            }
            
            switch (e.key) {
                case 'ArrowDown':
                    e.preventDefault();
                    selectedIndex = Math.min(selectedIndex + 1, suggestions.length - 1);
                    updateSelectedSuggestion(suggestions);
                    scrollToActiveSuggestion();
                    break;
                case 'ArrowUp':
                    e.preventDefault();
                    selectedIndex = Math.max(selectedIndex - 1, -1);
                    updateSelectedSuggestion(suggestions);
                    scrollToActiveSuggestion();
                    break;
                case 'Enter':
                    e.preventDefault();
                    if (selectedIndex >= 0 && suggestions[selectedIndex]) {
                        const text = suggestions[selectedIndex].getAttribute('data-value');
                        const type = suggestions[selectedIndex].getAttribute('data-type');
                        const searchQuery = suggestions[selectedIndex].getAttribute('data-search-query');
                        if (text && type) {
                            window.selectSuggestion(text, type, searchQuery);
                        }
                    } else {
                        performQuickSearch();
                    }
                    break;
                case 'Escape':
                    window.hideSuggestions();
                    searchInput.blur();
                    break;
                case 'Tab':
                    // Allow tabbing through suggestions
                    if (selectedIndex >= 0 && suggestions[selectedIndex]) {
                        e.preventDefault();
                        const text = suggestions[selectedIndex].getAttribute('data-value');
                        const type = suggestions[selectedIndex].getAttribute('data-type');
                        const searchQuery = suggestions[selectedIndex].getAttribute('data-search-query');
                        if (text && type) {
                            window.selectSuggestion(text, type, searchQuery);
                        }
                    }
                    break;
            }
        });
        
        // Scroll active suggestion into view
        function scrollToActiveSuggestion() {
            const activeSuggestion = searchSuggestions?.querySelector('.suggestion-item.active');
            if (activeSuggestion && searchSuggestions) {
                const containerRect = searchSuggestions.getBoundingClientRect();
                const itemRect = activeSuggestion.getBoundingClientRect();
                
                if (itemRect.bottom > containerRect.bottom) {
                    activeSuggestion.scrollIntoView({ block: 'end', behavior: 'smooth' });
                } else if (itemRect.top < containerRect.top) {
                    activeSuggestion.scrollIntoView({ block: 'start', behavior: 'smooth' });
                }
            }
        }
        
        // Hide suggestions when clicking outside
        document.addEventListener('click', function(e) {
            // Don't hide if clicking on the search input, suggestions dropdown, or clear button
            if (!e.target.closest('.enhanced-search-container') && 
                !e.target.closest('#searchSuggestions') &&
                !e.target.closest('#searchClearBtn')) {
                window.hideSuggestions();
            }
        });
        
        // Prevent suggestions from hiding when clicking inside the dropdown
        if (searchSuggestions) {
            searchSuggestions.addEventListener('mousedown', function(e) {
                // Prevent the blur event from firing when clicking on suggestions
                e.preventDefault();
            });
        }
        
        // Enhanced fetch suggestions with categorization
        function fetchSuggestions(query) {
            console.log('Fetching suggestions for:', query); // Debug log
            
            fetch(`/search/api/suggestions?q=${encodeURIComponent(query)}&types=team,user`)
                .then(response => {
                    console.log('Response received:', response.status); // Debug log
                    return response.json();
                })
                .then(data => {
                    console.log('Data received:', data); // Debug log
                    displaySuggestions(data.suggestions || []);
                })
                .catch(error => {
                    console.error('Error fetching suggestions:', error);
                    showNoResults();
                });
        }
        
        // Enhanced display suggestions with categories and icons
        function displaySuggestions(suggestions) {
            console.log('Displaying suggestions:', suggestions); // Debug log
            
            if (!searchSuggestions) {
                console.log('No searchSuggestions element found'); // Debug log
                return;
            }
            
            if (suggestions.length === 0) {
                console.log('No suggestions to display'); // Debug log
                showNoResults();
                return;
            }
            
            currentSuggestions = suggestions;
            console.log('Building HTML for', suggestions.length, 'suggestions'); // Debug log
            
            // Group suggestions by type
            const grouped = suggestions.reduce((acc, suggestion) => {
                const type = suggestion.type || 'other';
                if (!acc[type]) acc[type] = [];
                acc[type].push(suggestion);
                return acc;
            }, {});
            
            let html = '';
            
            // Define category order and labels
            const categoryOrder = ['team', 'user'];
            const categoryLabels = {
                'team': 'Teams',
                'user': 'Users'
            };
            
            // Build HTML with categories
            categoryOrder.forEach(type => {
                if (grouped[type] && grouped[type].length > 0) {
                    if (html) html += ''; // Separator between categories
                    html += `<div class="suggestion-category">${categoryLabels[type]}</div>`;
                    
                    grouped[type].forEach((suggestion, index) => {
                        const iconClass = getIconForType(suggestion.type);
                        const globalIndex = suggestions.indexOf(suggestion);
                        
                        html += `
                            <div class="suggestion-item" 
                                 data-index="${globalIndex}" 
                                 data-type="${suggestion.type}" 
                                 data-value="${escapeHtml(suggestion.text)}"
                                 data-search-query="${escapeHtml(suggestion.search_query || suggestion.text)}"
                                 role="option">
                                <div class="suggestion-icon">
                                    <i class="${iconClass}"></i>
                                </div>
                                <div class="suggestion-content">
                                    <div class="suggestion-title">${escapeHtml(suggestion.text)}</div>
                                    <div class="suggestion-type">${suggestion.type}</div>
                                </div>
                            </div>
                        `;
                    });
                }
            });
            
            console.log('Generated HTML:', html.substring(0, 100) + '...'); // Debug log
            
            searchSuggestions.innerHTML = html;
            console.log('HTML set, adding show class');
            searchSuggestions.classList.add('show');
            console.log('Show class added, checking visibility:', getComputedStyle(searchSuggestions).display);
            positionSearchSuggestions();
            selectedIndex = -1;
            
            // Debug: Check element dimensions and position
            const rect = searchSuggestions.getBoundingClientRect();
            console.log('Dropdown dimensions:', {
                width: rect.width,
                height: rect.height,
                top: rect.top,
                left: rect.left,
                visible: rect.width > 0 && rect.height > 0,
                hasContent: searchSuggestions.innerHTML.length > 0
            });
            
            console.log('Suggestions should now be visible'); // Debug log
            
            // Update ARIA attributes
            searchInput.setAttribute('aria-expanded', 'true');
            searchSuggestions.setAttribute('aria-activedescendant', '');
        }
        
        // Show no results message
        function showNoResults() {
            if (!searchSuggestions) return;
            console.log('Showing no results message'); // Debug log
            searchSuggestions.innerHTML = `
                <div class="no-suggestions">
                    <i class="fas fa-search-minus mb-2"></i><br>
                    No suggestions found
                </div>
            `;
            searchSuggestions.classList.add('show');
            positionSearchSuggestions();
        }
        
        // Update selected suggestion styling
        function updateSelectedSuggestion(suggestions) {
            suggestions.forEach((item, index) => {
                item.classList.toggle('active', index === selectedIndex);
            });
            
            // Update ARIA attributes
            if (selectedIndex >= 0 && suggestions[selectedIndex]) {
                const activeId = `suggestion-${selectedIndex}`;
                suggestions[selectedIndex].id = activeId;
                searchInput.setAttribute('aria-activedescendant', activeId);
            } else {
                searchInput.setAttribute('aria-activedescendant', '');
            }
        }
        
        // Enhanced icon mapping
        function getIconForType(type) {
            const icons = {
                'team': 'fas fa-users',
                'user': 'fas fa-user',
                'event': 'fas fa-calendar',
                'match': 'fas fa-trophy',
                'scouting_data': 'fas fa-clipboard-list'
            };
            return icons[type] || 'fas fa-search';
        }
        
        // Escape HTML to prevent XSS
        function escapeHtml(text) {
            const div = document.createElement('div');
            div.textContent = text;
            return div.innerHTML;
        }
        
        // Perform quick search
        function performQuickSearch() {
            const query = searchInput.value.trim();
            if (query) {
                // Add a subtle animation before navigation
                searchInput.style.transform = 'scale(0.98)';
                setTimeout(() => {
                    window.location.href = `/search?q=${encodeURIComponent(query)}`;
                }, 100);
            }
        }
    }
    
    // Helper function for performQuickSearch (moved outside initSearchFunctionality)
    function performQuickSearch() {
        const searchInput = document.getElementById('quickSearchInput');
        if (searchInput) {
            const query = searchInput.value.trim();
            if (query) {
                window.location.href = `/search?q=${encodeURIComponent(query)}`;
            }
        }
    }
    </script>
</body>
</html>