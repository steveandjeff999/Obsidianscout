<!DOCTYPE html>
<html lang="en" class="h-100">
<head>
    <!-- Early theme detection: apply dark-mode class to <html> before CSS loads to prevent white flash -->
    <script>
        (function(){
            try {
                // Check explicit user preference stored in localStorage (string 'true' / 'false')
                var stored = null;
                try { stored = localStorage.getItem('darkMode'); } catch (e) { stored = null; }
                var prefersDark = false;
                try { prefersDark = window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches; } catch(e) { prefersDark = false; }
                var useDark = null;
                if (stored === 'true') useDark = true;
                else if (stored === 'false') useDark = false;
                else useDark = prefersDark;

                if (useDark) {
                    // Apply to documentElement so early CSS can target html.dark-mode or body.dark-mode
                    document.documentElement.classList.add('dark-mode');
                    // Also set a small inline style to ensure background is dark immediately
                    var css = 'html.dark-mode, html.dark-mode body { background: #0b0b0d; color: #e6e6e6; }';
                    var s = document.createElement('style');
                    s.setAttribute('data-ob-theme','early');
                    s.appendChild(document.createTextNode(css));
                    // Insert before other head children
                    var head = document.getElementsByTagName('head')[0];
                    if (head) head.insertBefore(s, head.firstChild);
                }
            } catch (e) { /* fail silently - don't block page */ }
        })();
    </script>
    <script>
    // Ensure suggestion dropdowns use dark background when the app is in dark mode.
    (function(){
        function applyDarkToSuggestions(root){
            try{
                const els = (root || document).querySelectorAll('.enhanced-search-suggestions, .enhanced-search-suggestions-main, #suggestions, #searchSuggestionsTop');
                els.forEach(el => {
                    // Use setProperty with priority 'important' to overwrite inline !important styles
                    el.style.setProperty('background', '#0b0b0d', 'important');
                    el.style.setProperty('color', '#ffffff', 'important');
                    el.style.setProperty('border-color', 'rgba(255,255,255,0.04)', 'important');
                });
            }catch(e){console && console.warn && console.warn('applyDarkToSuggestions error', e);}    
        }

        function init() {
            if (document.documentElement.classList.contains('dark-mode')) {
                applyDarkToSuggestions(document);

                // Watch for new suggestion elements being added dynamically
                const bodyObs = new MutationObserver(mutations => {
                    mutations.forEach(m => {
                        m.addedNodes && m.addedNodes.forEach(node => {
                            if (node.nodeType === 1) {
                                if (node.matches && (node.matches('.enhanced-search-suggestions') || node.matches('.enhanced-search-suggestions-main') || node.id === 'searchSuggestionsTop' || node.id === 'suggestions')) {
                                    applyDarkToSuggestions(node.parentNode || document);
                                }
                            }
                        });
                    });
                });
                bodyObs.observe(document.body, { childList: true, subtree: true });

                // Also observe html element class changes (theme toggles)
                const htmlObs = new MutationObserver(mutations => {
                    mutations.forEach(m => {
                        if (m.attributeName === 'class') {
                            if (document.documentElement.classList.contains('dark-mode')) applyDarkToSuggestions(document);
                        }
                    });
                });
                htmlObs.observe(document.documentElement, { attributes: true });
            }
        }

        if (document.readyState === 'loading') document.addEventListener('DOMContentLoaded', init); else init();
    })();
    </script>
    <script>
    // Aggressive short-duration re-apply to catch suggestion elements created very early
    (function(){
        function reapplyDark() {
            try {
                if (!document.documentElement.classList.contains('dark-mode')) return;
                const sel = ['.enhanced-search-suggestions', '.enhanced-search-suggestions-main', '#suggestions', '#searchSuggestionsTop'];
                sel.forEach(s => {
                    document.querySelectorAll(s).forEach(el => {
                        el.style.setProperty('background', '#0b0b0d', 'important');
                        el.style.setProperty('color', '#ffffff', 'important');
                        el.style.setProperty('border-color', 'rgba(255,255,255,0.04)', 'important');
                        el.querySelectorAll('.suggestion-item').forEach(it => {
                            it.style.setProperty('background', 'transparent', 'important');
                            it.style.setProperty('color', '#ffffff', 'important');
                        });
                    });
                });
            } catch (e) { console && console.debug && console.debug('reapplyDark error', e); }
        }

        if (document.readyState === 'complete' || document.readyState === 'interactive') {
            // Run immediately and schedule short repeated attempts
            reapplyDark();
        } else {
            document.addEventListener('DOMContentLoaded', reapplyDark);
        }

        // Run repeatedly for a short window to catch dynamically added inline-styled elements
        let tries = 0;
        const id = setInterval(() => {
            reapplyDark();
            tries += 1;
            if (tries > 20) clearInterval(id); // ~2 seconds at 100ms intervals
        }, 100);
    })();
    </script>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover, shrink-to-fit=no">
    <title>{% block title %}ObsidianScout{% endblock %}</title>
    
    {% if game_config %}
    <meta name="auto_duration" content="{{ game_config.get('auto_period', {}).get('duration_seconds', 15) }}">
    <meta name="teleop_duration" content="{{ game_config.get('teleop_period', {}).get('duration_seconds', 120) }}">
    <meta name="endgame_duration" content="{{ game_config.get('endgame_period', {}).get('duration_seconds', 30) }}">
    <script>
        // Pass game configuration as a JavaScript variable to avoid HTML escaping issues
        window.GAME_CONFIG = JSON.parse('{{ game_config|tojson|safe }}');
    </script>
    {% endif %}
    
    <link href="{{ url_for('static', filename='css/vendor/bootstrap.min.css') }}" rel="stylesheet">
    
    <link href="{{ url_for('static', filename='css/vendor/fontawesome-all.min.css') }}" rel="stylesheet">
    
    {# Google Fonts are internet-hosted; fallback to system fonts for offline use #}
    <style>body{font-family: Roboto, Montserrat, system-ui, -apple-system, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif;}</style>
    
    <link href="{{ url_for('static', filename='css/vendor/select2.min.css') }}" rel="stylesheet">
    <link href="{{ url_for('static', filename='css/vendor/select2-bootstrap-5-theme.min.css') }}" rel="stylesheet">
    
    <link rel="stylesheet" href="{{ url_for('static', filename='css/styles.css') }}">
    <link rel="stylesheet" href="{{ url_for('static', filename='css/theme-overrides.css') }}">
    <link rel="stylesheet" href="{{ url_for('static', filename='css/modal-fix.css') }}">
    <link rel="stylesheet" href="{{ url_for('static', filename='css/navbar-improvements.css') }}">
    <link rel="stylesheet" href="{{ url_for('static', filename='css/topbar-notifications.css') }}">
    <link rel="stylesheet" href="{{ url_for('static', filename='css/search-enhancements.css') }}">
    <link rel="stylesheet" href="{{ url_for('static', filename='css/sidebar.css') }}">
    <link rel="stylesheet" href="{{ url_for('static', filename='css/modern-ui.css') }}">
    <link rel="stylesheet" href="{{ url_for('static', filename='css/dark-mode-force.css') }}">
    <link rel="stylesheet" href="{{ url_for('static', filename='css/mobile-fixes.css') }}">
    <!-- Use UMD build of Chart.js for compatibility with non-module script loading -->
    <script src="{{ url_for('static', filename='js/vendor/chart.umd.min.js') }}"></script>
    
    <!-- Dynamic Theme CSS Variables -->
    {% if theme_css_variables and theme_css_variables.strip() %}
    <style id="theme-variables">
        :root { {{ theme_css_variables | safe }} }
    </style>
    {% endif %}
    <style>
        /* Ensure card-bg variable uses the neutral, non-blue glass color in dark mode */
        body.dark-mode, body.modern-layout.dark-mode {
            --card-bg: rgba(24,24,26,0.78) !important;
            --glass-bg: rgba(22,22,24,0.6) !important;
            --glass-border: rgba(255,255,255,0.035) !important;
        }
        /* Force nested cards and small panels to match the neutral card background in dark mode.
           This duplicate inline rule helps in cases where external CSS is loaded before our override
           and prevents visual mismatches on initial render. */
        body.dark-mode .card .card,
        body.modern-layout.dark-mode .card .card,
        body.dark-mode .stat-card,
        body.modern-layout.dark-mode .stat-card,
        body.dark-mode .dashboard-card,
        body.modern-layout.dark-mode .dashboard-card {
            background: var(--card-bg) !important;
            background-color: var(--card-bg) !important;
            border: 1px solid rgba(0,0,0,0.45) !important;
            box-shadow: 0 2px 6px rgba(0,0,0,0.45) !important;
            color: var(--bs-body-color) !important;
            background-clip: padding-box !important;
            overflow: hidden !important;
        }
    </style>
    
    <link rel="manifest" href="{{ url_for('static', filename='manifest.json') }}">
    <link rel="icon" type="image/png" sizes="192x192" href="/static/obsidian-192.png">
    <link rel="apple-touch-icon" href="/static/obsidian-192.png">
    <meta name="theme-color" content="#1976d2">
    
    <style>
        .form-switch .form-check-input {
            height: 1.2rem;
            width: 2.2rem;
            cursor: pointer;
        }
        .form-check-label {
            cursor: pointer;
        }
        .dark-mode #darkModeIcon {
            color: #ffc107 !important;
        }
        .dark-mode #darkModeLabel {
            color: #e6e6e6;
        }
        .obsidian-gradient {
            background: linear-gradient(90deg, #7065a2 0%, #625591 100%);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            text-fill-color: transparent;
        }
        /* Small red dot used on user dropdown to indicate unread chat */
        .user-chat-dot {
            display: inline-block;
            width: 10px;
            height: 10px;
            border-radius: 50%;
            background: #dc3545; /* bootstrap danger */
            margin-left: 6px;
            vertical-align: middle;
        }
        
        /* Enhanced Search Component Styles */
        .search-wrapper {
            position: relative;
            flex: 1;
            max-width: 320px;
            min-width: 200px;
        }
        
        .enhanced-search-container {
            position: relative;
            width: 100%;
        }
        
        .search-input-wrapper {
            position: relative;
            display: flex;
            align-items: center;
            background: var(--bs-body-bg);
            border: 2px solid var(--bs-border-color);
            border-radius: 25px;
            transition: all 0.3s ease;
            overflow: hidden;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.08);
        }
        
        .search-input-wrapper:hover {
            border-color: var(--bs-primary);
            box-shadow: 0 4px 12px rgba(var(--bs-primary-rgb), 0.15);
        }
        
        .search-input-wrapper:focus-within {
            border-color: var(--bs-primary);
            box-shadow: 0 0 0 0.2rem rgba(var(--bs-primary-rgb), 0.25);
        }
        
        .search-icon {
            position: absolute;
            left: 14px;
            color: var(--bs-secondary);
            font-size: 0.9rem;
            z-index: 2;
            transition: color 0.3s ease;
        }
        
        .search-input-wrapper:focus-within .search-icon {
            color: var(--bs-primary);
        }
        
        .enhanced-search-input {
            flex: 1;
            border: none !important;
            outline: none !important;
            background: transparent !important;
            padding: 10px 45px 10px 40px !important;
            font-size: 0.9rem;
            color: var(--bs-body-color);
            box-shadow: none !important;
            border-radius: 0;
        }
        
        .enhanced-search-input::placeholder {
            color: var(--bs-secondary);
            font-style: italic;
        }
        
        .search-clear-btn {
            position: absolute;
            right: 45px;
            background: none;
            border: none;
            color: var(--bs-secondary);
            padding: 4px;
            border-radius: 50%;
            width: 20px;
            height: 20px;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            transition: all 0.2s ease;
            z-index: 2;
        }
        
        .search-clear-btn:hover {
            background: var(--bs-secondary-bg);
            color: var(--bs-danger);
        }
        
        .search-submit-btn {
            position: absolute;
            right: 4px;
            background: var(--bs-primary);
            border: none;
            color: white;
            padding: 8px;
            border-radius: 50%;
            width: 34px;
            height: 34px;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            transition: all 0.2s ease;
            z-index: 2;
        }
        
        .search-submit-btn:hover {
            background: var(--bs-primary);
            filter: brightness(110%);
            transform: scale(1.05);
        }
        
        .search-submit-btn:active {
            transform: scale(0.95);
        }

        /* Dark-mode overrides for navbar/main search so input is dark and text is white */
        body.dark-mode .search-input-wrapper,
        body.dark-mode .enhanced-search-input,
        body.dark-mode .search-input-wrapper .enhanced-search-input {
            background: #121212 !important;
            border-color: rgba(255,255,255,0.06) !important;
            color: #ffffff !important;
        }

        body.dark-mode .search-input-wrapper .search-icon,
        body.dark-mode .search-input-wrapper .search-clear-btn,
        body.dark-mode .search-input-wrapper .search-submit-btn {
            color: #ececec !important;
        }

        body.dark-mode .enhanced-search-input::placeholder {
            color: #bfbfbf !important;
            opacity: 1;
        }

        /* Make suggestions dropdown dark as well in dark mode */
        body.dark-mode .enhanced-search-suggestions,
        body.dark-mode .enhanced-search-suggestions.show,
        body.dark-mode .enhanced-search-suggestions-main,
        body.dark-mode .enhanced-search-suggestions-main.show,
        body.dark-mode #suggestions {
            background: #0b0b0d !important;
            color: #ffffff !important;
            border-color: rgba(255,255,255,0.04) !important;
        }
        
        /* Enhanced Search Suggestions */
        .enhanced-search-suggestions {
            display: none !important;
        }
        
        .enhanced-search-suggestions.show {
            display: block !important;
            z-index: 9999 !important;
        }
        
        @keyframes searchFadeIn {
            from {
                opacity: 0;
                transform: translateY(-10px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }
        
        .suggestion-item {
            display: flex;
            align-items: center;
            padding: 12px 16px;
            cursor: pointer;
            border-bottom: 1px solid var(--bs-border-color);
            transition: all 0.2s ease;
            position: relative;
        }
        
        .suggestion-item:last-child {
            border-bottom: none;
        }
        
        .suggestion-item:hover,
        .suggestion-item.active {
            background: linear-gradient(135deg, rgba(var(--bs-primary-rgb), 0.1), rgba(var(--bs-primary-rgb), 0.05));
            transform: translateX(4px);
        }
        
        .suggestion-item.active::before {
            content: '';
            position: absolute;
            left: 0;
            top: 0;
            bottom: 0;
            width: 3px;
            background: var(--bs-primary);
            border-radius: 0 2px 2px 0;
        }
        
        .suggestion-icon {
            width: 20px;
            height: 20px;
            display: flex;
            align-items: center;
            justify-content: center;
            margin-right: 12px;
            background: rgba(var(--bs-primary-rgb), 0.1);
            border-radius: 6px;
            color: var(--bs-primary);
            font-size: 0.8rem;
            flex-shrink: 0;
        }
        
        .suggestion-content {
            flex: 1;
            min-width: 0;
        }
        
        .suggestion-title {
            font-weight: 600;
            color: var(--bs-body-color);
            margin-bottom: 2px;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
        }
        
        .suggestion-type {
            font-size: 0.75rem;
            color: var(--bs-secondary);
            text-transform: uppercase;
            letter-spacing: 0.5px;
            font-weight: 500;
        }
        
        .suggestion-category {
            padding: 8px 16px;
            background: var(--bs-secondary-bg);
            color: var(--bs-secondary);
            font-size: 0.75rem;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            border-bottom: 1px solid var(--bs-border-color);
            position: sticky;
            top: 0;
            z-index: 1;
        }
        
        .search-loading {
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 20px;
            color: var(--bs-secondary);
        }
        
        .search-loading-spinner {
            width: 16px;
            height: 16px;
            border: 2px solid var(--bs-secondary-bg);
            border-top: 2px solid var(--bs-primary);
            border-radius: 50%;
            animation: spin 1s linear infinite;
            margin-right: 8px;
        }
        
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
        
        .no-suggestions {
            padding: 20px;
            text-align: center;
            color: var(--bs-secondary);
            font-style: italic;
        }
        
        /* Mobile Search Button Enhancement */
        .modern-search-mobile {
            border-radius: 12px !important;
            background: var(--bs-primary) !important;
            border-color: var(--bs-primary) !important;
            color: white !important;
            transition: all 0.2s ease;
        }
        
        .modern-search-mobile:hover {
            background: var(--bs-primary) !important;
            border-color: var(--bs-primary) !important;
            color: white !important;
            transform: scale(1.05);
            filter: brightness(110%);
        }
        
        /* Responsive Design */
        @media (max-width: 1400px) {
            .search-wrapper {
                max-width: 280px;
                min-width: 180px;
            }
        }
        
        @media (max-width: 1200px) {
            .search-wrapper {
                max-width: 240px;
                min-width: 160px;
            }
            
            .enhanced-search-input {
                font-size: 0.85rem;
                padding: 9px 42px 9px 38px !important;
            }
            
            .search-icon {
                left: 12px;
                font-size: 0.85rem;
            }
            
            .search-submit-btn {
                width: 30px;
                height: 30px;
                right: 3px;
            }
        }
        
        @media (max-width: 992px) {
            .search-wrapper {
                max-width: 200px;
                min-width: 140px;
            }
        }
        
        @media (max-width: 768px) {
            .search-wrapper {
                max-width: auto;
                min-width: auto;
                flex: 0 0 auto;
            }
        }
        
        /* Dark Mode Support */
        .dark-mode .search-input-wrapper {
            background: var(--card-bg);
            border-color: rgba(255, 255, 255, 0.2);
        }
        
        .dark-mode .search-input-wrapper:hover {
            border-color: var(--bs-primary);
        }
        
        .dark-mode .enhanced-search-suggestions {
            background: var(--card-bg);
            border-color: rgba(255, 255, 255, 0.1);
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3);
        }
        
        .dark-mode .suggestion-item {
            border-bottom-color: rgba(255, 255, 255, 0.1);
        }
        
        .dark-mode .suggestion-item:hover,
        .dark-mode .suggestion-item.active {
            background: linear-gradient(135deg, rgba(var(--bs-primary-rgb), 0.2), rgba(var(--bs-primary-rgb), 0.1));
        }
        
        .dark-mode .suggestion-category {
            background: rgba(255, 255, 255, 0.05);
            border-bottom-color: rgba(255, 255, 255, 0.1);
        }
        
        /* Search functionality styles */
        .search-wrapper {
            position: relative;
            flex: 1;
            max-width: 280px;
            min-width: 160px;
        }
        
        /* Mobile Touch and Input Stability Fixes */
        @media (max-width: 768px) {
            /* Prevent iOS zoom on input focus */
            input, textarea, select, .form-control, .form-select {
                font-size: 16px !important;
                transform: translateZ(0);
                -webkit-transform: translateZ(0);
                -webkit-appearance: none;
                border-radius: 4px;
            }
            
            /* Prevent focus outline from causing scroll */
            input:focus, textarea:focus, select:focus, .form-control:focus, .form-select:focus {
                scroll-margin: 0 !important;
                scroll-behavior: auto !important;
                outline: 2px solid var(--bs-primary);
                outline-offset: -2px;
            }
            
            /* Stabilize form containers */
            .form-group, .input-group, .form-floating, .tab-content {
                contain: layout;
                transform: translateZ(0);
                -webkit-transform: translateZ(0);
            }
            
            /* Force hardware acceleration on interactive elements */
            button, .btn, [role="button"], .dropdown-toggle, .nav-link {
                transform: translateZ(0);
                -webkit-transform: translateZ(0);
                -webkit-tap-highlight-color: transparent;
            }
            
            /* Prevent dropdown and modal scroll issues */
            .dropdown-menu, .modal-dialog {
                transform: translateZ(0);
                -webkit-transform: translateZ(0);
            }
            
            /* Prevent body overflow during modal/dropdown interactions */
            body.modal-open, body.dropdown-open {
                overflow: hidden;
                position: fixed;
                width: 100%;
            }
        }
        
        /* Enhanced Mobile Click Protection */
        @media (max-width: 900px) {
            /* Prevent unwanted scroll during interactions */
            * {
                -webkit-overflow-scrolling: touch;
                touch-action: manipulation;
            }
            
            /* Specific protection for common culprits */
            a[href="#"], a[href=""], a[href="javascript:void(0)"] {
                touch-action: none !important;
            }
            
            /* Stable positioning for fixed elements */
            .topbar, .sidebar, .navbar-fixed-top {
                transform: translateZ(0);
                -webkit-transform: translateZ(0);
            }
        }
        
        @media (max-width: 1400px) {
            .search-wrapper {
                max-width: 220px;
                min-width: 140px;
            }
        }
        
        @media (max-width: 1200px) {
            .search-wrapper {
                max-width: 180px;
                min-width: 120px;
            }
        }
        
        @media (max-width: 992px) {
            .search-wrapper {
                max-width: 140px;
                min-width: 100px;
            }
        }
        
        @media (max-width: 768px) {
            .search-wrapper {
                max-width: auto;
                min-width: auto;
                flex: 0 0 auto;
            }
        }
        
        /* Make the navbar more responsive */
        .navbar-actions {
            flex-wrap: nowrap;
            align-items: center;
        }
        
        .navbar-actions > * {
            flex-shrink: 0;
        }
        
        /* Adjust button sizes for mobile */
        @media (max-width: 768px) {
            .btn-sm {
                padding: 0.25rem 0.5rem;
                font-size: 0.775rem;
            }
            
            .dropdown-toggle::after {
                margin-left: 0.255rem;
            }
        }
        
        .search-wrapper .form-control {
            transition: width 0.3s ease;
        }
        
        .search-wrapper .form-control:focus {
            width: 100%;
        }
        
        #searchSuggestions {
            position: absolute;
            top: 100%;
            left: 0;
            right: 0;
            background: var(--bs-body-bg);
            border: 1px solid var(--bs-border-color);
            border-radius: 0.375rem;
            box-shadow: 0 0.5rem 1rem rgba(0, 0, 0, 0.15);
            z-index: 1060; /* Higher than navbar dropdowns */
            max-height: 300px;
            overflow-y: auto;
            display: none;
        }
        
        .suggestion-item {
            cursor: pointer;
            border-bottom: 1px solid var(--bs-border-color);
            transition: background-color 0.15s ease-in-out;
        }
        
        .suggestion-item:last-child {
            border-bottom: none;
        }
        
        .suggestion-item:hover,
        .suggestion-item.active {
            background-color: var(--bs-secondary-bg);
        }
        
        .search-mobile-btn {
            border: none;
            background: none;
            color: var(--bs-nav-link-color);
            padding: 0.5rem;
            border-radius: 0.375rem;
            transition: background-color 0.15s ease-in-out;
        }
        
        .search-mobile-btn:hover {
            background-color: var(--bs-secondary-bg);
            color: var(--bs-nav-link-hover-color);
        }
    </style>
    
    {% block head %}{% endblock %}
</head>
<body class="d-flex flex-column h-100 with-sidebar topbar-fixed">
    <!-- Global Top Bar (search + user) -->
    <div class="topbar glass d-flex align-items-center gap-2 px-3 py-2 shadow-sm" role="banner">
        <div class="d-flex align-items-center gap-2 flex-shrink-0">
            <button id="sidebarToggle" class="btn btn-outline-primary btn-sm" aria-label="Toggle navigation"><i class="fas fa-bars"></i></button>
        </div>
        {% if current_user.is_authenticated %}
        <div class="top-search d-none d-sm-block">
            <form method="GET" action="{{ url_for('search.search_page') }}" class="position-relative" role="search" aria-label="Global search">
                <div class="enhanced-search-container w-100">
                    <div class="search-input-wrapper">
                        <i class="fas fa-search search-icon"></i>
                        <input type="text" class="form-control enhanced-search-input" name="q" placeholder="Search" id="quickSearchInputTop" autocomplete="off" aria-label="Search teams and users" aria-expanded="false" role="combobox">
                        <button type="button" class="search-clear-btn" id="searchClearBtnTop" aria-label="Clear search" style="display:none;">
                            <i class="fas fa-times"></i>
                        </button>
                        <button class="search-submit-btn" type="submit" title="Search" aria-label="Submit search">
                            <i class="fas fa-arrow-right"></i>
                        </button>
                    </div>
                    <div id="searchSuggestionsTop" class="enhanced-search-suggestions" role="listbox" aria-label="Search suggestions"></div>
                </div>
            </form>
        </div>
        <a href="{{ url_for('search.search_page') }}" class="btn btn-outline-secondary btn-sm d-sm-none" aria-label="Search"><i class="fas fa-search"></i></a>
        {% endif %}
        <!-- User dropdown and notifications -->
        <div class="ms-auto d-flex align-items-center flex-shrink-0 navbar-actions">
            {% if current_user.is_authenticated %}
                <div class="d-flex align-items-center">
                    <!-- Notifications dropdown -->
                    <div class="dropdown me-2 topbar-notifications">
                        <button id="notificationsToggle" class="btn btn-outline-secondary btn-sm d-flex align-items-center dropdown-toggle" type="button" data-bs-toggle="dropdown" aria-expanded="false" aria-haspopup="true" aria-controls="notificationsMenu" aria-label="Notifications">
                            <i class="fas fa-bell"></i>
                            <span id="notificationsBadge" class="badge bg-danger ms-1" style="display:none; font-size:0.65rem;">0</span>
                        </button>
                        <div id="notificationsMenu" class="dropdown-menu dropdown-menu-end shadow notifications-dropdown" aria-labelledby="notificationsToggle">
                            <div class="dropdown-header d-flex align-items-center justify-content-between px-3 py-2">
                                <strong>Notifications</strong>
                                <button id="clearAllNotificationsBtn" class="btn btn-sm btn-link small" title="Clear all">Clear all</button>
                            </div>
                            <div id="notificationsList" class="list-group list-group-flush" style="max-height:320px; overflow:auto;">
                                <div class="list-group-item text-muted small">Loading...</div>
                            </div>
                            <div class="dropdown-footer text-center py-2">
                                <a href="{{ url_for('main.chat_page') }}" class="small">Open chat</a>
                            </div>
                        </div>
                    </div>
                    <div class="dropdown">
                        <button id="userToggle" class="btn btn-outline-primary btn-sm d-flex align-items-center dropdown-toggle" type="button" data-bs-toggle="dropdown" aria-expanded="false" aria-haspopup="true" aria-controls="userMenu">
                            <i class="fas fa-user-circle me-1"></i>
                            <span class="d-none d-md-inline">{{ current_user.username }}</span>
                            <span id="userChatDot" class="user-chat-dot" style="display:none;" title="You have unread chat messages"></span>
                        </button>
                        <ul id="userMenu" class="dropdown-menu dropdown-menu-end shadow notifications-dropdown navbar-glass" aria-labelledby="userToggle">
                            <li id="userDropdownUnreadItem" style="display:none;"><a id="openUnreadChatLink" class="dropdown-item py-2" href="{{ url_for('main.chat_page') }}"><i class="fas fa-comments me-2 text-danger"></i>Open unread chat</a></li>
                            <li><hr class="dropdown-divider my-1"></li>
                            <li>
                                <div class="dropdown-user-header d-flex align-items-center px-3 py-2">
                                    <div class="me-2">
                                        <i class="fas fa-user-circle fa-2x"></i>
                                    </div>
                                    <div class="flex-grow-1">
                                        <div class="user-name fw-semibold">{{ current_user.username or 'User' }}</div>
                                        <div class="user-roles text-muted small">
                                            {% for role in current_user.roles %}
                                                <span class="badge bg-secondary text-uppercase me-1">{{ role.name }}</span>
                                            {% else %}
                                                <span class="text-muted">No roles</span>
                                            {% endfor %}
                                        </div>
                                    </div>
                                </div>
                            </li>
                            <li><hr class="dropdown-divider my-1"></li>
                            <li><a class="dropdown-item py-2" href="{{ url_for('auth.profile') }}"><i class="fas fa-user-edit me-2 text-primary"></i>Profile</a></li>
                            {% if user_has_role('admin') or user_has_role('analytics') %}
                            <li><a class="dropdown-item py-2 {% if request.endpoint == 'main.config' %}active{% endif %}" href="{{ url_for('main.config') }}"><i class="fas fa-wrench me-2 text-primary"></i>Game Configuration</a></li>
                            {% endif %}
                            {% if user_has_role('superadmin') %}
                            <li><a class="dropdown-item py-2" href="{{ url_for('db_admin.database_status') }}"><i class="fas fa-database me-2 text-success"></i>Database Admin</a></li>
                            {% endif %}
                            <li><hr class="dropdown-divider my-1"></li>
                            <li><a class="dropdown-item py-2 text-danger" href="{{ url_for('auth.logout') }}"><i class="fas fa-sign-out-alt me-2"></i>Logout</a></li>
                        </ul>
                    </div>
                </div>
            {% else %}
            <a href="{{ url_for('auth.login') }}" class="btn btn-primary btn-sm">Login</a>
            {% endif %}
        </div>
    </div>

    <!-- Sidebar -->
    <aside id="appSidebar" class="sidebar glass" role="navigation" aria-label="Main sidebar">
        <div class="sidebar-header d-flex align-items-center justify-content-between">
            <a class="brand d-flex align-items-center text-decoration-none" href="{% if user_has_role('scout') and not user_has_role('admin') and not user_has_role('analytics') %}{{ url_for('scouting.index') }}{% else %}{{ url_for('main.index') }}{% endif %}">
                <i class="fas fa-robot brand-icon me-2"></i>
                <span class="brand-text fw-bold"><span class="obsidian-gradient">Obsidian</span>Scout</span>
            </a>
            <button id="sidebarClose" class="btn btn-link text-muted d-lg-none" aria-label="Close sidebar"><i class="fas fa-times"></i></button>
        </div>
    {# Removed quick search from sidebar (now in top bar) #}
        <nav class="sidebar-nav flex-grow-1" aria-label="Main navigation">
            {% if current_user.is_authenticated %}
            {% if user_has_role('superadmin') %}
            <div class="nav-group" id="group-superadmin">
                <button class="nav-group-title btn btn-toggle" aria-expanded="true" aria-controls="group-superadmin-items" data-group="group-superadmin">
                    Super Admin <i class="fas fa-chevron-down group-chevron ms-2" aria-hidden="true"></i>
                </button>
                <div class="nav-group-items" id="group-superadmin-items">
                    <a class="nav-link {% if request.endpoint == 'auth.manage_users' %}active{% endif %}" href="{{ url_for('auth.manage_users') }}"><i class="fas fa-user-shield"></i><span>Manage Users</span></a>
                    <a class="nav-link {% if request.endpoint == 'auth.add_user' %}active{% endif %}" href="{{ url_for('auth.add_user') }}"><i class="fas fa-user-plus"></i><span>Add User</span></a>
                </div>
            </div>
            {% endif %}
            {# Administration nav-group removed on request #}
            <div class="nav-group" id="group-core">
                <button class="nav-group-title btn btn-toggle" aria-expanded="true" aria-controls="group-core-items" data-group="group-core">
                    Core <i class="fas fa-chevron-down group-chevron ms-2" aria-hidden="true"></i>
                </button>
                <div class="nav-group-items" id="group-core-items">
                {% if not (user_has_role('scout') and not user_has_role('admin') and not user_has_role('analytics')) %}
                <a class="nav-link {% if request.endpoint == 'main.index' %}active{% endif %}" href="{{ url_for('main.index') }}"><i class="fas fa-home"></i><span>Dashboard</span></a>
                {% endif %}
                <a class="nav-link {% if request.endpoint == 'scouting.index' %}active{% endif %}" href="{{ url_for('scouting.index') }}"><i class="fas fa-clipboard"></i><span>Scouting Dashboard</span></a>
                <a class="nav-link {% if request.endpoint == 'scouting.scouting_form' %}active{% endif %}" href="{{ url_for('scouting.scouting_form') }}"><i class="fas fa-rocket"></i><span>Start Scouting</span></a>
                <a class="nav-link {% if request.endpoint == 'pit_scouting.index' %}active{% endif %}" href="{{ url_for('pit_scouting.index') }}"><i class="fas fa-wrench"></i><span>Pit Scouting</span></a>
                <a class="nav-link {% if request.endpoint and request.endpoint.startswith('scouting_alliances') %}active{% endif %}" href="{{ url_for('scouting_alliances.dashboard') }}"><i class="fas fa-users"></i><span>Scouting Alliances</span></a>
                <a class="nav-link {% if request.endpoint == 'scouting.list_data' %}active{% endif %}" href="{{ url_for('scouting.list_data') }}"><i class="fas fa-list"></i><span>All Data</span></a>
                <a class="nav-link {% if request.endpoint == 'scouting.view_text_elements' %}active{% endif %}" href="{{ url_for('scouting.view_text_elements') }}"><i class="fas fa-comment-alt"></i><span>Text Elements</span></a>
                </div>
            </div>
            {% if user_has_role('admin') or user_has_role('analytics') %}
            <div class="nav-group" id="group-analytics">
                <button class="nav-group-title btn btn-toggle" aria-expanded="true" aria-controls="group-analytics-items" data-group="group-analytics">
                    Analytics <i class="fas fa-chevron-down group-chevron ms-2" aria-hidden="true"></i>
                </button>
                <div class="nav-group-items" id="group-analytics-items">
                <a class="nav-link {% if request.endpoint and request.endpoint.startswith('teams') and request.endpoint != 'teams.ranks' %}active{% endif %}" href="{{ url_for('teams.index') }}"><i class="fas fa-users"></i><span>Teams</span></a>
                <a class="nav-link {% if request.endpoint == 'teams.ranks' %}active{% endif %}" href="{{ url_for('teams.ranks') }}"><i class="fas fa-list-ol"></i><span>Team Rankings</span></a>
                <a class="nav-link {% if request.endpoint == 'matches.index' %}active{% endif %}" href="{{ url_for('matches.index') }}"><i class="fas fa-gamepad"></i><span>Matches</span></a>
                <a class="nav-link {% if request.endpoint and request.endpoint.startswith('alliances') %}active{% endif %}" href="{{ url_for('alliances.index') }}"><i class="fas fa-handshake"></i><span>Alliance Selection</span></a>
                <a class="nav-link {% if request.endpoint and request.endpoint.startswith('graphs') %}active{% endif %}" href="{{ url_for('graphs.index') }}"><i class="fas fa-chart-line"></i><span>Graphs</span></a>
                <a class="nav-link {% if request.endpoint and request.endpoint.startswith('graphs') and 'side-by-side' in request.endpoint %}active{% endif %}" href="{{ url_for('graphs.side_by_side') }}"><i class="fas fa-columns"></i><span>Comparison</span></a>
                <a class="nav-link {% if request.endpoint and request.endpoint.startswith('graphs.pages') %}active{% endif %}" href="{{ url_for('graphs.pages_index') }}"><i class="fas fa-file-alt"></i><span>Custom Pages</span></a>
                <a class="nav-link {% if request.endpoint == 'matches.strategy' %}active{% endif %}" href="{{ url_for('matches.strategy') }}"><i class="fas fa-chess"></i><span>Strategy</span></a>
                <a class="nav-link {% if request.endpoint == 'matches.strategy_all' %}active{% endif %}" href="{{ url_for('matches.strategy_all') }}"><i class="fas fa-th-large"></i><span>Strategy — All Matches</span></a>
                <a class="nav-link {% if request.endpoint == 'matches.strategy_draw' %}active{% endif %}" href="{{ url_for('matches.strategy_draw') }}"><i class="fas fa-pen-ruler"></i><span>Strategy Draw</span></a>
                <a class="nav-link {% if request.endpoint == 'graphs.my_shares' %}active{% endif %}" href="{{ url_for('graphs.my_shares') }}"><i class="fas fa-share-alt"></i><span>My Graph Shares</span></a>
                    <a class="nav-link {% if request.endpoint == 'teams.my_ranks_shares' %}active{% endif %}" href="{{ url_for('teams.my_ranks_shares') }}"><i class="fas fa-trophy"></i><span>My Ranking Shares</span></a>
                <a class="nav-link {% if request.endpoint and request.endpoint.startswith('team_trends') %}active{% endif %}" href="{{ url_for('team_trends.index') }}"><i class="fas fa-chart-line"></i><span>Trends</span></a>
                <a class="nav-link {% if request.endpoint and request.endpoint.startswith('data') %}active{% endif %}" href="{{ url_for('data.index') }}"><i class="fas fa-database"></i><span>Data</span></a>
                </div>
            </div>
            {% endif %}
            <div class="nav-group" id="group-community">
                <button class="nav-group-title btn btn-toggle" aria-expanded="true" aria-controls="group-community-items" data-group="group-community">
                    Community <i class="fas fa-chevron-down group-chevron ms-2" aria-hidden="true"></i>
                </button>
                <div class="nav-group-items" id="group-community-items">
                <a class="nav-link {% if request.endpoint == 'main.users_page' %}active{% endif %}" href="{{ url_for('main.users_page') }}"><i class="fas fa-users"></i><span>Users</span></a>
                <a class="nav-link {% if request.endpoint == 'main.chat_page' %}active{% endif %}" href="{{ url_for('main.chat_page') }}"><i class="fas fa-comments"></i><span>Chat <span id="chatUnreadBadge" class="badge bg-danger ms-1" style="display:none;">0</span></span></a>
                <a class="nav-link {% if request.endpoint == 'main.sponsors' %}active{% endif %}" href="{{ url_for('main.sponsors') }}"><i class="fas fa-handshake"></i><span>Sponsors</span></a>
                <a class="nav-link {% if request.endpoint == 'graphs.scout_leaderboard' %}active{% endif %}" href="{{ url_for('graphs.scout_leaderboard') }}"><i class="fas fa-medal"></i><span>Scout Leaderboard</span></a>
                </div>
            </div>
            <div class="nav-group" id="group-help">
                <button class="nav-group-title btn btn-toggle" aria-expanded="true" aria-controls="group-help-items" data-group="group-help">
                    Help <i class="fas fa-chevron-down group-chevron ms-2" aria-hidden="true"></i>
                </button>
                <div class="nav-group-items" id="group-help-items">
                <a class="nav-link {% if request.endpoint == 'main.help_page' %}active{% endif %}" href="{{ url_for('main.help_page') }}"><i class="fas fa-book"></i><span>Documentation</span></a>
                <a class="nav-link {% if request.endpoint and request.endpoint.startswith('setup') %}active{% endif %}" href="{{ url_for('setup.index') }}"><i class="fas fa-graduation-cap"></i><span>Setup & Tutorial</span></a>
                </div>
            </div>
            {% endif %}
        </nav>
        {% if current_user.is_authenticated %}
        <div class="sidebar-footer mt-auto">
            <div class="user-mini d-flex align-items-center mb-2">
                <i class="fas fa-user-circle me-2 fs-4"></i>
                <div class="flex-grow-1">
                    <div class="fw-semibold small">{{ current_user.username }}</div>
                    <div class="text-muted tiny">
                        {% for role in current_user.roles %}
                            <span class="badge bg-secondary text-uppercase me-1 mb-1">{{ role.name }}</span>
                        {% endfor %}
                    </div>
                </div>
            </div>
            <div class="d-flex flex-column gap-2">
                {% if user_has_role('admin') %}
                <a class="btn btn-outline-primary btn-sm w-100 text-start {% if request.endpoint == 'auth.admin_settings' %}active{% endif %}" href="{{ url_for('auth.admin_settings') }}"><i class="fas fa-cog me-2"></i>Admin Settings</a>
                {% endif %}
                {% if user_has_role('admin') or user_has_role('analytics') %}
                <a class="btn btn-outline-primary btn-sm w-100 text-start {% if request.endpoint == 'main.config' %}active{% endif %}" href="{{ url_for('main.config') }}"><i class="fas fa-wrench me-2"></i>Game Config</a>
                {% endif %}
                <button id="darkModeButton" class="btn btn-outline-secondary btn-sm w-100 text-start" type="button">
                    <i class="fas fa-moon me-2" id="darkModeIcon"></i><span id="darkModeLabel">Dark Mode</span>
                </button>
                {% if user_has_role('superadmin') %}
                <a class="btn btn-outline-secondary btn-sm w-100 text-start" href="{{ url_for('db_admin.database_status') }}"><i class="fas fa-database me-2"></i>DB Admin</a>
                {% endif %}
                <a class="btn btn-outline-danger btn-sm w-100 text-start" href="{{ url_for('auth.logout') }}"><i class="fas fa-sign-out-alt me-2"></i>Logout</a>
            </div>
        </div>
        {% endif %}
    </aside>

    <script>
    // Sidebar toggle logic (mobile overlay + desktop collapse)
    (function(){
        const sidebar = document.getElementById('appSidebar');
        const toggle = document.getElementById('sidebarToggle');
        const closeBtn = document.getElementById('sidebarClose');
        const body = document.body;
        let _scrollPosition = 0;

        // Use an overlay to absorb touch/scroll events when sidebar is open on mobile.
        // This avoids fixing body position which on some devices can clip fixed children.
            function lockBodyScroll(){
                _scrollPosition = window.scrollY || document.documentElement.scrollTop || 0;

                // Prevent background scrolling while sidebar is open
                document.documentElement.style.overflow = 'hidden';
                document.body.style.overflow = 'hidden';

                // Add a transparent overlay that captures touch and click events outside the sidebar
                let overlay = document.getElementById('sidebarBackdropOverlay');
                if(!overlay){
                    overlay = document.createElement('div');
                    overlay.id = 'sidebarBackdropOverlay';
                    overlay.style.position = 'fixed';
                    overlay.style.inset = '0';
                    overlay.style.zIndex = '1035';
                    overlay.style.background = 'transparent';
                    overlay.style.touchAction = 'none';
                    overlay.addEventListener('touchmove', function(e){ e.preventDefault(); }, { passive: false });
                    overlay.addEventListener('click', function(){ closeSidebar(); });
                    document.body.appendChild(overlay);
                }

                // Ensure sidebar can scroll smoothly on iOS
                if(sidebar) {
                    sidebar.style['-webkit-overflow-scrolling'] = 'touch';
                }
            }
        function unlockBodyScroll(){
                const overlay = document.getElementById('sidebarBackdropOverlay');
                if(overlay && overlay.parentNode) overlay.parentNode.removeChild(overlay);

                document.documentElement.style.overflow = '';
                document.body.style.overflow = '';
                // Restore scroll position (use safe helper to cooperate with stabilizer)
                try {
                    if (typeof window.safeRestoreScroll === 'function') {
                        window.safeRestoreScroll(_scrollPosition || 0, { behavior: 'auto', timeout: 350 });
                    } else {
                        try { if (window.safeRestoreScroll && typeof window.safeRestoreScroll === 'function') { window.safeRestoreScroll(_scrollPosition || 0, { behavior: 'auto', timeout: 300 }); } else { window.scrollTo(0, _scrollPosition || 0); } } catch(e) {}
                    }
                } catch (e) { /* ignore */ }
            }

        // Sidebar open/close with localStorage persistence for desktop
        const SIDEBAR_STORAGE_KEY = 'obsidian_sidebar_collapsed';

        function isDesktop() { return window.innerWidth >= 992; }

        function setSidebarCollapsed(collapsed) {
            if (collapsed) {
                document.body.classList.add('sidebar-collapsed');
            } else {
                document.body.classList.remove('sidebar-collapsed');
            }
            try { localStorage.setItem(SIDEBAR_STORAGE_KEY, collapsed ? '1' : '0'); } catch(e){}
        }

        function getStoredSidebarCollapsed() {
            try { return localStorage.getItem(SIDEBAR_STORAGE_KEY) === '1'; } catch(e){ return null; }
        }

        function openSidebar(){
            if(!isDesktop()){
                sidebar.classList.add('open');
                body.classList.add('sidebar-open');
                lockBodyScroll();
            } else {
                setSidebarCollapsed(false);
            }
            if(toggle) toggle.setAttribute('aria-expanded','true');
        }

        function closeSidebar(){
            if(!isDesktop()){
                sidebar.classList.remove('open');
                body.classList.remove('sidebar-open');
                try { unlockBodyScroll(); } catch(e){}
            } else {
                setSidebarCollapsed(true);
            }
            if(toggle) toggle.setAttribute('aria-expanded','false');
        }

        function toggleSidebar(){
            if(!isDesktop()){
                if(sidebar.classList.contains('open')){ closeSidebar(); } else { openSidebar(); }
            } else {
                // desktop: toggle collapse state
                const collapsed = document.body.classList.contains('sidebar-collapsed');
                setSidebarCollapsed(!collapsed);
            }
        }

        if(toggle){
            toggle.setAttribute('aria-controls','appSidebar');
            toggle.setAttribute('aria-expanded','true');
            toggle.addEventListener('click', (e)=>{ e.preventDefault(); toggleSidebar(); });
        }

        // Apply stored state on load (desktop only)
        (function applyStoredSidebarState(){
            const stored = getStoredSidebarCollapsed();
            if (stored === null) return; // no preference stored
            if (isDesktop()) {
                setSidebarCollapsed(stored);
            } else {
                // if mobile, ensure collapsed flag is reflected but don't force open/close overlay
                if (stored) document.body.classList.add('sidebar-collapsed');
            }
        })();

        if(closeBtn){ closeBtn.addEventListener('click', (e)=>{ e.preventDefault(); closeSidebar(); }); }

        // Nav link click (mobile)
        if (sidebar) {
            sidebar.querySelectorAll('a.nav-link').forEach(a=>{
                a.addEventListener('click', ()=>{ if(window.innerWidth < 992) closeSidebar(); });
            });
        }

        // Outside click (mobile)
        document.addEventListener('click', (e)=>{
            if(window.innerWidth >= 992) return;
            if(!sidebar.contains(e.target) && !(toggle && toggle.contains(e.target))) closeSidebar();
        });

        // Esc key
        document.addEventListener('keydown', (e)=>{ if(e.key==='Escape'){ if(window.innerWidth < 992 && sidebar.classList.contains('open')) closeSidebar(); }});

        // Initialize desktop state: respect stored preference if present
        if (window.innerWidth >= 992) {
            try {
                const stored = getStoredSidebarCollapsed();
                if (stored === null) {
                    // No preference stored: default to expanded
                    body.classList.remove('sidebar-collapsed');
                } else {
                    // Apply stored preference
                    setSidebarCollapsed(stored);
                }
            } catch (e) {
                // Fallback: ensure sidebar is expanded
                body.classList.remove('sidebar-collapsed');
            }
        }

        window.addEventListener('resize', ()=>{
            if(window.innerWidth >= 992){
                sidebar.classList.remove('open');
                body.classList.remove('sidebar-open');
                try { unlockBodyScroll(); } catch(e){}
            } else {
                body.classList.remove('sidebar-collapsed');
            }
        });

        // Re-apply stored sidebar state when resizing across breakpoint
        let lastWasDesktop = window.innerWidth >= 992;
        window.addEventListener('resize', function() {
            const nowDesktop = window.innerWidth >= 992;
            if (nowDesktop !== lastWasDesktop) {
                // crossed breakpoint
                const stored = getStoredSidebarCollapsed();
                if (stored !== null) {
                    if (nowDesktop) setSidebarCollapsed(stored);
                    else document.body.classList.remove('sidebar-collapsed');
                }
            }
            lastWasDesktop = nowDesktop;
        });

        // Avoid repositioning fixed dropdowns while page scrolls; only reposition if user opens a dropdown or resizes
        let lastScrollY = window.scrollY;
        window.addEventListener('scroll', function() {
            // If any topbar dropdown menu is positioned fixed, don't adjust its position on scroll
            const fixedMenus = document.querySelectorAll('.topbar .dropdown-menu');
            let hasFixed = false;
            fixedMenus.forEach(menu => {
                if (getComputedStyle(menu).position === 'fixed' && menu.classList.contains('show')) hasFixed = true;
            });
            if (hasFixed) {
                // nothing to do while scrolling
                lastScrollY = window.scrollY;
                return;
            }

            // If no fixed menus, allow repositioning logic for dropdowns that rely on normal flow
            // (for example on desktop navbar dropdowns not positioned fixed)
            lastScrollY = window.scrollY;
        });
    })();
    </script>
    <script>
    // Populate data-label attributes on sidebar nav links for collapsed hover tooltips
    (function(){
        const sidebar = document.getElementById('appSidebar');
        function setNavLabels(){
            if(!sidebar) return;
            const links = sidebar.querySelectorAll('a.nav-link');
            links.forEach(a=>{
                const label = a.querySelector('span') ? a.querySelector('span').textContent.trim() : a.textContent.trim();
                if(label) a.setAttribute('data-label', label);
            });
        }
        setNavLabels();
        // Update labels if window resizes or user toggles sidebar
        window.addEventListener('resize', setNavLabels);
        document.addEventListener('obsidian:sidebar:toggled', setNavLabels);
        // Also hook into existing toggle button to dispatch an event for other listeners
        const toggle = document.getElementById('sidebarToggle');
        if(toggle) toggle.addEventListener('click', ()=>{ setTimeout(()=>{ document.dispatchEvent(new CustomEvent('obsidian:sidebar:toggled')); }, 250); });
    })();
    </script>
    <style>
    /* Tooltip-like labels when sidebar is collapsed (lightweight, non-JS fallback via title is also applied) */
    .sidebar-collapsed .sidebar-nav a.nav-link {
        position: relative;
        padding-left: 0.75rem; /* compact spacing when collapsed */
    }
    .sidebar-collapsed .sidebar-nav a.nav-link::after {
        content: attr(data-label);
        position: absolute;
        left: 100%;
        margin-left: 8px;
        top: 50%;
        transform: translateY(-50%);
        background: var(--bs-body-bg);
        border: 1px solid var(--bs-border-color);
        padding: 6px 8px;
        border-radius: 6px;
        white-space: nowrap;
        box-shadow: 0 2px 8px rgba(0,0,0,0.12);
        display: none;
        z-index: 2000;
        font-size: 0.85rem;
    }
    .sidebar-collapsed .sidebar-nav a.nav-link:hover::after,
    .sidebar-collapsed .sidebar-nav a.nav-link:focus::after {
        display: block;
    }
    /* Slightly emphasize active link for better contrast */
    .sidebar .nav-link.active {
        background: linear-gradient(90deg, rgba(var(--bs-primary-rgb),0.06), transparent);
        border-radius: 6px;
    }
    </style>

    <script>
    // Accessibility helpers for sidebar: set aria-current on active links,
    // provide title attributes and keep the toggle button's pressed state in sync.
    document.addEventListener('DOMContentLoaded', function(){
        const sidebar = document.getElementById('appSidebar');
        const toggle = document.getElementById('sidebarToggle');

        function refreshSidebarA11y(){
            if(!sidebar) return;
            const collapsed = document.body.classList.contains('sidebar-collapsed');

            // Update toggle pressed/expanded states
            if(toggle){
                try{ toggle.setAttribute('aria-pressed', collapsed ? 'true' : 'false'); }catch(e){}
                try{ toggle.setAttribute('aria-expanded', (!collapsed && window.innerWidth >= 992) ? 'true' : 'false'); }catch(e){}
            }

            // Update links: aria-current for screen readers and title for hover fallback
            sidebar.querySelectorAll('a.nav-link').forEach(a=>{
                if(a.classList.contains('active')){
                    a.setAttribute('aria-current','page');
                } else {
                    a.removeAttribute('aria-current');
                }
                // Keep a pragmatic title attribute so tooltip works on platforms without CSS support
                const lbl = a.getAttribute('data-label');
                if(lbl) a.setAttribute('title', lbl);
            });
        }

        refreshSidebarA11y();
        document.addEventListener('obsidian:sidebar:toggled', refreshSidebarA11y);
        window.addEventListener('resize', refreshSidebarA11y);
    });
    </script>
    <script>
    // Sidebar nav-group collapse/expand behavior with simple persistence
    (function(){
        const GROUP_KEY = 'obsidian_sidebar_groups';
        function loadState(){ try{ const v = localStorage.getItem(GROUP_KEY); return v ? JSON.parse(v) : {}; }catch(e){ return {}; } }
        function saveState(state){ try{ localStorage.setItem(GROUP_KEY, JSON.stringify(state)); }catch(e){} }

        const state = loadState();
        document.querySelectorAll('.btn-toggle[data-group]').forEach(btn=>{
            const group = btn.getAttribute('data-group');
            const items = document.getElementById(group + '-items');
            if(!items) return;
            // initialize from state
            const open = (state[group] === undefined) ? true : !!state[group];
            btn.setAttribute('aria-expanded', open? 'true' : 'false');
            if(!open) items.classList.add('collapsed');

            btn.addEventListener('click', ()=>{
                const expanded = btn.getAttribute('aria-expanded') === 'true';
                btn.setAttribute('aria-expanded', expanded ? 'false' : 'true');
                items.classList.toggle('collapsed');
                state[group] = !expanded;
                saveState(state);
            });

            // keyboard accessibility: toggle on Enter/Space
            btn.addEventListener('keydown', (e)=>{
                if(e.key === 'Enter' || e.key === ' ') { e.preventDefault(); btn.click(); }
            });
        });
    })();
    </script>
    {# Embedded site-wide notification banner placed directly under the navbar #}
    {% include '_notification_banner.html' %}

    <div class="toast-container position-fixed top-0 end-0 p-3">
        {% with messages = get_flashed_messages(with_categories=true) %}
            {% if messages %}
                {% for category, message in messages %}
                    {# Normalize category values so templates can rely on Bootstrap color classes #}
                    {% set normalized = category %}
                    {# Map common non-Bootstrap category names to Bootstrap classes #}
                    {% if not category or category == 'message' or category == 'info' or category == 'regular' or category == 'normal' %}
                        {% set normalized = 'success' %}
                    {% elif category == 'error' or category == 'err' %}
                        {% set normalized = 'danger' %}
                    {% elif category == 'warn' or category == 'warning' %}
                        {% set normalized = 'warning' %}
                    {% endif %}

                    <div class="toast show" role="alert" aria-live="assertive" aria-atomic="true">
                        <div class="toast-header bg-{{ normalized }}{% if normalized in ['danger', 'success', 'primary'] %} text-white{% endif %}">
                            <i class="fas {% if normalized == 'success' %}fa-check-circle{% elif normalized == 'danger' %}fa-exclamation-triangle{% elif normalized == 'warning' %}fa-exclamation-circle{% else %}fa-info-circle{% endif %} me-2"></i>
                            <strong class="me-auto">Notification</strong>
                            <small>Just now</small>
                            <button type="button" class="btn-close {% if normalized in ['danger', 'success', 'primary'] %}btn-close-white{% endif %}" data-bs-dismiss="toast" aria-label="Close"></button>
                        </div>
                        <div class="toast-body">
                            {{ message }}
                        </div>
                    </div>
                {% endfor %}
            {% endif %}
        {% endwith %}
    </div>

    {% block breadcrumb %}{% endblock %}

    <main class="flex-shrink-0 py-4">
        <div class="container">
            <div class="row mb-4">
                <div class="col-12">
                    <h1 class="page-title">{% block heading %}ObsidianScout{% endblock %}</h1>
                    {% block subheading %}{% endblock %}
                </div>
            </div>
            
            {% block content %}{% endblock %}
        </div>
    </main>

    <footer class="footer mt-auto py-3">
        <div class="container">
            <div class="row align-items-center g-2">
                <div class="col-md-6 text-center text-md-start">
                    <div class="d-flex align-items-center justify-content-center justify-content-md-start">
                        <i class="fas fa-robot brand-icon me-2 text-primary"></i>
                        <span class="fw-bold">ObsidianScout</span>
                        <span class="text-muted mx-2">•</span>
                        <span class="small text-muted">ObsidianScout</span>
                    </div>
                </div>
                <div class="col-md-6 text-center text-md-end">
                    <div class="small text-muted">
                        {% if game_config %}
                        <span>{{ game_config.game_name }} {{ game_config.season }}</span>
                        {% else %}
                        <span>No active configuration</span>
                        {% endif %}
                    </div>
                <!--<div class="mt-2">
                        <a href="https://www.paypal.com" target="_blank" rel="noopener" class="btn btn-sm btn-warning d-inline-flex align-items-center">
                            <i class="fas fa-heart me-1"></i> Donate(Not yet available)
                        </a>
                    </div> -->
                </div>
            </div>
        </div>
    </footer>

    <div id="loading-overlay" class="d-none">
        <div class="spinner-container">
            <div class="spinner-border text-primary" role="status">
                <span class="visually-hidden">Loading...</span>
            </div>
            <div class="mt-2">Loading...</div>
        </div>
    </div>

    <script src="{{ url_for('static', filename='js/vendor/jquery-3.7.1.min.js') }}"></script>
    <script>
        // Enhanced jQuery loading check with timeout
        (function() {
            let retryCount = 0;
            const maxRetries = 5;
            const checkInterval = 100; // 100ms
            
            function checkJQuery() {
                if (typeof jQuery !== 'undefined' && typeof $ !== 'undefined') {
                    console.log('jQuery loaded successfully');
                    return true;
                }
                
                retryCount++;
                if (retryCount < maxRetries) {
                    setTimeout(checkJQuery, checkInterval);
                } else {
                    // Final fallback - load jQuery synchronously
                    console.warn('jQuery failed to load from CDNs, loading local fallback');
                    const script = document.createElement('script');
                    // Fallback now points to local vendor file for offline use
                    script.src = '{{ url_for('static', filename='js/vendor/jquery-3.7.1.min.js') }}';
                    script.integrity = 'sha384-1H217gwSVyLSIfaLxHbE7dRb3v4mYCKbpQvzx0cegeju1MVsGrX5xXxAvs/HgeFs';
                    script.crossOrigin = 'anonymous';
                    document.head.appendChild(script);
                    
                    script.onload = function() {
                        console.log('jQuery loaded from fallback CDN');
                    };
                    
                    script.onerror = function() {
                        console.error('All jQuery CDNs failed to load');
                        alert('jQuery failed to load from all sources. Please check your internet connection and refresh the page.');
                    };
                }
                return false;
            }
            
            // Start checking after a short delay
            setTimeout(checkJQuery, 50);
        })();
    </script>
    
    <script src="{{ url_for('static', filename='js/vendor/bootstrap.bundle.min.js') }}"></script>
    
    <script src="{{ url_for('static', filename='js/vendor/select2.min.js') }}"></script>
    
    <script src="{{ url_for('static', filename='js/select2-mobile-fix.js') }}"></script>
    
    <script src="{{ url_for('static', filename='js/vendor/plotly-latest.min.js') }}"></script>
    
    <script src="{{ url_for('static', filename='js/vendor/socket.io.js') }}"></script>
    
    <script src="{{ url_for('static', filename='js/qrcode.min.js') }}"></script>
    
    <!-- Gentle Mobile Scroll Protection -->
    <script>
    (function() {
        'use strict';
        
    // Treat narrow screens and tall portrait screens (height > width and tall) as "mobile-like"
    const isMobile = window.innerWidth <= 768 || /Android|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
    const isPortraitTall = (window.innerHeight > window.innerWidth) && (window.innerHeight >= 900);

    // If not mobile and not a tall portrait device, skip this gentle protection.
    if (!isMobile && !isPortraitTall) return;
        
        console.log('Gentle mobile scroll protection active');
        
        let isInteracting = false;
        let lastScrollY = 0;
        
        // Track scroll position when not interacting
        function updateScrollPosition() {
            if (!isInteracting) {
                lastScrollY = window.pageYOffset || document.documentElement.scrollTop || 0;
            }
        }
        
        // Gentle protection only for obvious scroll-to-top jumps
        function preventScrollToTop() {
            const currentScrollY = window.pageYOffset || document.documentElement.scrollTop || 0;
            
            // Only intervene if scroll jumped to exactly 0 from a significant position
            if (currentScrollY === 0 && lastScrollY > 100) {
                console.log('Preventing scroll-to-top jump');
                // Use smooth scroll to restore position
                window.scrollTo({
                    top: lastScrollY,
                    behavior: 'smooth'
                });
            }
        }
        
        // Very gentle click protection
        function handleInteraction(e) {
            // Only protect problematic elements
            const problematic = e.target.matches('a[href="#"], a[href=""], button[type="button"]:not([data-bs-toggle])');
            
            if (problematic) {
                isInteracting = true;
                
                // Single check after a short delay
                setTimeout(() => {
                    preventScrollToTop();
                    isInteracting = false;
                    updateScrollPosition();
                }, 50);
            }
        }
        
        // Add minimal event listeners
        document.addEventListener('click', handleInteraction, { passive: true });
        window.addEventListener('scroll', updateScrollPosition, { passive: true });
        
        // Initialize
        updateScrollPosition();
        
    })();
    </script>
    
    <script src="{{ url_for('static', filename='js/scripts.js') }}"></script>
    <script src="{{ url_for('static', filename='js/topbar-notifications.js') }}"></script>
    
    <script>
        document.addEventListener('DOMContentLoaded', function() {
            // Global helper: perform a scroll restore while cooperating with the
            // mobile viewport stabilizer. This sets the stabilizer suppression
            // flag briefly so the stabilizer doesn't fight legitimate restores.
            window.safeRestoreScroll = function(y, opts) {
                try { if (!opts) opts = {}; } catch(e) { opts = {}; }
                try { window.__suppressMobileScrollJumps = true; } catch (e) {}
                const behavior = opts.behavior || 'auto';
                // Use requestAnimationFrame so layout has settled before scrolling
                window.requestAnimationFrame(() => {
                    try {
                        window.scrollTo({ top: (y || 0), behavior: behavior });
                    } catch (err) {
                        try { if (window.safeRestoreScroll && typeof window.safeRestoreScroll === 'function') { window.safeRestoreScroll((y || 0), { behavior: 'auto', timeout: 350 }); } else { window.scrollTo(0, (y || 0)); } } catch(e) {}
                    }
                    // Remove suppression after a short timeout; caller may override
                    setTimeout(() => { try { window.__suppressMobileScrollJumps = false; } catch(e) {} }, opts.timeout || 350);
                });
            };
            
            // Initialize mobile protection (guard in case the function isn't present)
            if (typeof initializeMobileScrollProtection === 'function') {
                initializeMobileScrollProtection();
            }
            
            // ===============================
            // GLOBAL SELECT2 MOBILE ENHANCEMENT
            // ===============================
            
            // Apply mobile fixes to any existing Select2 dropdowns
            setTimeout(() => {
                if (typeof window.initSelect2Mobile === 'function') {
                    // Re-initialize any existing Select2 instances with mobile fixes
                    $('.select2-hidden-accessible').each(function() {
                        const $this = $(this);
                        const currentOptions = $this.data('select2') ? $this.data('select2').options.options : {};
                        
                        // Get existing configuration
                        const existingConfig = {
                            placeholder: currentOptions.placeholder || 'Select...',
                            allowClear: currentOptions.allowClear || false,
                            closeOnSelect: currentOptions.closeOnSelect !== false,
                            theme: currentOptions.theme || 'bootstrap-5',
                            width: currentOptions.width || '100%'
                        };
                        
                        // Only re-initialize if on mobile and not already mobile-enhanced
                        if (window.innerWidth <= 900 && !$this.hasClass('mobile-enhanced')) {
                            try {
                                $this.addClass('mobile-enhanced');
                                window.initSelect2Mobile($this, existingConfig);
                                console.log('Enhanced Select2 dropdown for mobile:', $this.attr('id') || $this.attr('name'));
                            } catch (e) {
                                console.warn('Failed to enhance Select2 for mobile:', e);
                            }
                        }
                    });
                }
            }, 200);
            
            // Dark mode button logic
            const darkModeBtn = document.getElementById('darkModeButton');
            const body = document.body;
            const prefersDarkMode = window.matchMedia('(prefers-color-scheme: dark)').matches;
            const storedPreference = localStorage.getItem('darkMode');
            const darkModeIcon = document.getElementById('darkModeIcon');
            const darkModeLabel = document.getElementById('darkModeLabel');
            const isDarkMode = storedPreference !== null ? storedPreference === 'true' : prefersDarkMode;
            function applyState(on){
                if(on){
                    body.classList.add('dark-mode');
                    if(darkModeIcon){darkModeIcon.classList.remove('fa-moon');darkModeIcon.classList.add('fa-sun');}
                    if(darkModeLabel){darkModeLabel.textContent='Light Mode';}
                } else {
                    body.classList.remove('dark-mode');
                    if(darkModeIcon){darkModeIcon.classList.remove('fa-sun');darkModeIcon.classList.add('fa-moon');}
                    if(darkModeLabel){darkModeLabel.textContent='Dark Mode';}
                }
            }
            applyState(isDarkMode);
            
            // Server-side theme management was removed; rely on client preference (localStorage) only.
            
            if(darkModeBtn){
                darkModeBtn.addEventListener('click', ()=>{
                    const now = !body.classList.contains('dark-mode');
                    localStorage.setItem('darkMode', now ? 'true':'false');
                    applyState(now);
                    
                    // Persist only locally; no server-side theme endpoints are available.
                });
            }
            // System preference changes only if user hasn't chosen
            window.matchMedia('(prefers-color-scheme: dark)').addEventListener('change', e => {
                if (localStorage.getItem('darkMode') === null) {
                    applyState(e.matches);
                }
            });
            
            // Initialize toasts
            var toastElList = document.querySelectorAll('.toast');
            Array.from(toastElList).map(function (toastEl) {
                return new bootstrap.Toast(toastEl, {
                    autohide: true,
                    delay: 5000
                });
            });
        });
    </script>
    
    <!-- Dark mode handlers -->
    <script src="{{ url_for('static', filename='js/dark-mode-handlers.js') }}"></script>
    

    
    {% block scripts %}{% endblock %}
    {% block extra_js %}{% endblock %}

    <script>
    // Ensure service worker is registered at root (/sw.js) so PWABuilder and other tools can detect it
    if ('serviceWorker' in navigator) {
    navigator.serviceWorker.register('/sw.js', { scope: '/' })
            .then(reg => {
                console.log('SW root registered:', reg.scope);
                // Force update check
                reg.update();
            })
            .catch(err => console.warn('SW root registration failed:', err));
    }

    // Reposition any portalled dropdowns on scroll/resize/mousewheel to prevent visual drift
    (function addPortalledRepositionHandler(){
        let pending = false;
        function repositionPortalled() {
            pending = false;
            // Find any portalled menus
            document.querySelectorAll('.dropdown-menu.navbar-glass').forEach(menu => {
                try {
                    if (!menu.__isPortalled || !menu.__portalToggle) return;
                    positionFixedDropdown(menu.__portalToggle, menu);
                } catch(e) { /* ignore */ }
            });
        }

        function scheduleReposition() {
            if (pending) return;
            pending = true;
            window.requestAnimationFrame(repositionPortalled);
        }

        // Listen to scroll, wheel and touchmove for robust repositioning
        window.addEventListener('scroll', scheduleReposition, { passive: true });
        window.addEventListener('wheel', scheduleReposition, { passive: true });
        window.addEventListener('touchmove', scheduleReposition, { passive: true });
        window.addEventListener('resize', scheduleReposition);
    })();
    </script>

    <!-- Temporary debug shim: intercept scrollTo to capture unexpected jumps to top on tall portrait screens -->
    <script>
    (function(){
        try {
            const isPortraitTall = (window.innerHeight > window.innerWidth) && (window.innerHeight >= 900);
            if (!isPortraitTall) return; // only active for the environment where you reported the bug

            window.__scrollJumpLogs = window.__scrollJumpLogs || [];

            const origScrollTo = window.scrollTo.bind(window);
            let lastUserClickY = null;

            // Track recent clicks
            document.addEventListener('click', function(e){
                try { lastUserClickY = window.pageYOffset || document.documentElement.scrollTop || 0; } catch(e) { lastUserClickY = null; }
                // expire after short time
                setTimeout(function(){ lastUserClickY = null; }, 700);
            }, true);

            window.scrollTo = function(){
                try {
                    // Normalize arguments
                    let targetY = null;
                    if (arguments.length === 1 && typeof arguments[0] === 'object' && arguments[0] !== null) {
                        targetY = arguments[0].top != null ? arguments[0].top : (arguments[0].left != null ? arguments[0].left : null);
                    } else if (arguments.length >= 2) {
                        // scrollTo(x, y)
                        targetY = arguments[1];
                    }

                    // If a call is trying to jump to the very top (0) shortly after a user click
                    if (targetY === 0 && lastUserClickY && lastUserClickY > 50) {
                        const entry = {
                            time: Date.now(),
                            beforeY: lastUserClickY,
                            stack: (new Error('scrollTo captured')).stack,
                            args: Array.prototype.slice.call(arguments)
                        };
                        window.__scrollJumpLogs.push(entry);
                        // Print brief warning so you can observe in console if present
                        console.warn('Captured scrollTo(0) after user click — recorded to window.__scrollJumpLogs (first 3 chars of stack):', (entry.stack||'').slice(0,120));
                        // Still perform the original call so behavior is unchanged while debugging
                        return origScrollTo.apply(window, arguments);
                    }
                } catch (err) {
                    // ignore errors in debug shim
                }
                return origScrollTo.apply(window, arguments);
            };
            console.log('Scroll debug shim active for tall-portrait screens — logs available at window.__scrollJumpLogs');
        } catch(e) { /* ignore */ }
    })();
    </script>

    <!-- Extra debug instrumentation: focus, history, and hashchange logging (temporary) -->
    <script>
    (function(){
        try {
            const isPortraitTall = (window.innerHeight > window.innerWidth) && (window.innerHeight >= 900);
            if (!isPortraitTall) return;

            window.__scrollActionLogs = window.__scrollActionLogs || [];

            // Wrap the current focus implementation (don't clobber earlier production wrapper)
            const currentFocus = HTMLElement.prototype.focus;
            HTMLElement.prototype.focus = function(options){
                let beforeY = window.pageYOffset || document.documentElement.scrollTop || 0;
                try {
                    // Call whatever focus implementation is present (production wrapper or native)
                    return currentFocus.call(this, options);
                } finally {
                    // Check shortly after focus whether the page was moved to top
                    setTimeout(() => {
                        try {
                            const afterY = window.pageYOffset || document.documentElement.scrollTop || 0;
                            if (afterY === 0 && beforeY > 50) {
                                const entry = { type: 'focus', tag: this && this.tagName, beforeY, time: Date.now(), stack: (new Error('focus captured')).stack };
                                window.__scrollActionLogs.push(entry);
                                console.warn('Debug: focus caused scroll-to-top; entry recorded in window.__scrollActionLogs (focus)');
                            }
                        } catch(e) {}
                    }, 40);
                }
            };

            // Wrap history methods to detect scroll changes after push/replace
            ['pushState','replaceState'].forEach(function(name){
                try {
                    const orig = history[name];
                    history[name] = function(){
                        const beforeY = window.pageYOffset || document.documentElement.scrollTop || 0;
                        const res = orig.apply(history, arguments);
                        setTimeout(() => {
                            try {
                                const afterY = window.pageYOffset || document.documentElement.scrollTop || 0;
                                if (afterY === 0 && beforeY > 50) {
                                    const entry = { type: name, args: Array.prototype.slice.call(arguments), beforeY, time: Date.now(), stack: (new Error(name+' captured')).stack };
                                    window.__scrollActionLogs.push(entry);
                                    console.warn('Debug: history.'+name+' caused scroll-to-top; entry recorded in window.__scrollActionLogs');
                                }
                            } catch(e) {}
                        }, 30);
                        return res;
                    };
                } catch(e) { /* ignore */ }
            });

            // Hashchange listener
            window.addEventListener('hashchange', function(e){
                try {
                    const beforeY = window.__lastUserScrollBeforeHash || 0;
                    const afterY = window.pageYOffset || document.documentElement.scrollTop || 0;
                    if (afterY === 0 && beforeY > 50) {
                        const entry = { type: 'hashchange', beforeY, time: Date.now(), stack: (new Error('hashchange captured')).stack };
                        window.__scrollActionLogs.push(entry);
                        console.warn('Debug: hashchange caused scroll-to-top; entry recorded in window.__scrollActionLogs');
                    }
                } catch(e) {}
            }, true);

            // Track last scroll position before clicks (helps hashchange detection)
            document.addEventListener('click', function(){
                try { window.__lastUserScrollBeforeHash = window.pageYOffset || document.documentElement.scrollTop || 0; } catch(e) { window.__lastUserScrollBeforeHash = 0; }
                setTimeout(function(){ window.__lastUserScrollBeforeHash = 0; }, 700);
            }, true);

            console.log('Extra scroll/focus/history debug instrumentation active — logs available at window.__scrollActionLogs');
        } catch(e) { /* ignore */ }
    })();
    </script>

    <!-- Aggressive click watcher: detect sudden jump-to-top after clicks and restore previous scroll Y -->
    <script>
    (function(){
        try {
            const isPortraitTall = (window.innerHeight > window.innerWidth) && (window.innerHeight >= 900);
            if (!isPortraitTall) return;

            // Keep a short history of recent restores so we don't loop
            window.__recentAutoRestores = window.__recentAutoRestores || [];

            document.addEventListener('click', function(ev){
                try {
                    const beforeY = window.pageYOffset || document.documentElement.scrollTop || 0;
                    // Only watch if user was scrolled down a bit
                    if (!beforeY || beforeY <= 30) return;

                    let rafCount = 0;
                    const maxRafs = 20; // watch for a short period (~20 frames)

                    function checkFrame(){
                        rafCount++;
                        const nowY = window.pageYOffset || document.documentElement.scrollTop || 0;
                        // If it jumped to top (or nearly top) restore immediately
                        if ((nowY === 0 || Math.abs(nowY) <= 2) && beforeY > 30) {
                            // Avoid rapidly re-restoring the same Y repeatedly
                            const last = window.__recentAutoRestores[window.__recentAutoRestores.length - 1] || {};
                            if (last.y === beforeY && (Date.now() - (last.t || 0) < 1000)) {
                                return; // recently restored same position
                            }

                            // Log with stacktrace
                            const trace = (new Error('auto-restore')).stack;
                            window.__scrollJumpLogs = window.__scrollJumpLogs || [];
                            window.__scrollJumpLogs.push({ time: Date.now(), beforeY, afterY: nowY, stack: trace, cause: 'auto-restore-after-click' });
                            window.__recentAutoRestores.push({ t: Date.now(), y: beforeY });
                            if (window.__recentAutoRestores.length > 10) window.__recentAutoRestores.shift();

                            // Use safeRestoreScroll if present to cooperate with stabilizer
                            if (window.safeRestoreScroll && typeof window.safeRestoreScroll === 'function') {
                                try { window.safeRestoreScroll(beforeY, { behavior: 'auto', timeout: 300 }); } catch(e) { try { window.scrollTo(0, beforeY); } catch(e2) {} }
                            } else {
                                try { window.scrollTo(0, beforeY); } catch(e) { /* ignore */ }
                            }

                            console.warn('Auto-restored scroll position after unexpected jump-to-top (debug): restored to', beforeY);
                            return;
                        }

                        if (rafCount < maxRafs) {
                            window.requestAnimationFrame(checkFrame);
                        }
                    }

                    window.requestAnimationFrame(checkFrame);
                } catch(e) { /* ignore */ }
            }, true);

            console.log('Aggressive click watcher active on tall-portrait screens');
        } catch(e) { /* ignore */ }
    })();
    </script>

    <!-- Very aggressive polling detector: sample scrollTop rapidly after clicks and restore if it jumps to top -->
    <script>
    (function(){
        try {
            const isPortraitTall = (window.innerHeight > window.innerWidth) && (window.innerHeight >= 900);
            if (!isPortraitTall) return;

            window.__scrollJumpLogs = window.__scrollJumpLogs || [];

            document.addEventListener('click', function(){
                try {
                    const beforeY = window.pageYOffset || document.documentElement.scrollTop || 0;
                    if (!beforeY || beforeY <= 30) return;

                    let elapsed = 0;
                    const intervalMs = 12; // rapid sampling
                    const maxDuration = 700; // watch for 700ms

                    const id = setInterval(() => {
                        try {
                            elapsed += intervalMs;
                            const nowY = window.pageYOffset || document.documentElement.scrollTop || 0;
                            if ((nowY === 0 || Math.abs(nowY) <= 2) && beforeY > 30) {
                                // Capture stack
                                let stack = null;
                                try { stack = (new Error('poll-capture')).stack; } catch(e) { stack = 'no-stack'; }

                                const entry = { t: Date.now(), beforeY, afterY: nowY, stack, note: 'poll-detected' };
                                window.__scrollJumpLogs.push(entry);

                                // Avoid loops: if last restore same y recently, skip
                                const recent = window.__recentAutoRestores || [];
                                const last = recent[recent.length-1] || {};
                                if (!(last.y === beforeY && (Date.now() - (last.t||0) < 1000))) {
                                    // restore using safeRestoreScroll when available
                                    try {
                                        if (window.safeRestoreScroll && typeof window.safeRestoreScroll === 'function') {
                                            window.safeRestoreScroll(beforeY, { behavior: 'auto', timeout: 300 });
                                        } else {
                                            window.scrollTo(0, beforeY);
                                        }
                                        window.__recentAutoRestores = window.__recentAutoRestores || [];
                                        window.__recentAutoRestores.push({ t: Date.now(), y: beforeY });
                                        if (window.__recentAutoRestores.length > 10) window.__recentAutoRestores.shift();
                                    } catch(e) { /* ignore */ }
                                }

                                clearInterval(id);
                                return;
                            }
                            if (elapsed >= maxDuration) {
                                clearInterval(id);
                                return;
                            }
                        } catch(e) { clearInterval(id); }
                    }, intervalMs);
                } catch(e) { /* ignore */ }
            }, true);

            console.log('Polling scroll detector active on tall-portrait screens');
        } catch(e) { /* ignore */ }
    })();
    </script>

    <!-- Strong capture-phase anchor guard: prevents href="#" and empty/invalid anchors from jumping to top -->
    <script>
    (function(){
        'use strict';
        // This runs on all viewports (conservative safety) to block anchors that would change the hash
        // and cause browsers to scroll to top. We whitelist elements that explicitly opt-in or are
        // known interactive controls (Bootstrap toggles, ARIA buttons, data attributes).

        function isWhitelistedAnchor(anchor) {
            if (!anchor) return false;
            if (anchor.hasAttribute('data-allow-navigation') || anchor.hasAttribute('data-allow-top')) return true;
            if (anchor.hasAttribute('data-bs-toggle') || anchor.hasAttribute('data-toggle') || anchor.hasAttribute('data-bs-target') || anchor.getAttribute('role') === 'button') return true;
            // If anchor has a real href to an external location or a valid same-page target, allow
            return false;
        }

        document.body.addEventListener('click', function(e){
            try {
                const anchor = e.target && e.target.closest ? e.target.closest('a') : null;
                if (!anchor) return;

                const href = (anchor.getAttribute('href') || '').trim();

                // Allow whitelisted anchors
                if (isWhitelistedAnchor(anchor)) return;

                // Block empty, hash-only, or javascript:void anchors which often cause jumps
                if (href === '' || href === '#' || href.toLowerCase().startsWith('javascript:') || href === '#!') {
                    if (e.cancelable) e.preventDefault();
                    // Stop other handlers from acting on this anchor which might trigger navigation
                    e.stopImmediatePropagation();

                    // If anchor wraps a real control, forward the click to it
                    const inner = anchor.querySelector('button, [role="button"], input[type="button"], input[type="submit"]');
                    if (inner) {
                        try { inner.click(); } catch(err) { /* ignore */ }
                    }
                    return;
                }

                // If it's a hash targeting an element that doesn't exist, prevent the jump
                if (href.startsWith('#') && href.length > 1) {
                    const id = href.slice(1);
                    if (!document.getElementById(id)) {
                        if (e.cancelable) e.preventDefault();
                        e.stopImmediatePropagation();
                        return;
                    }
                }
            } catch(err) { /* swallow errors to avoid breaking page */ }
        }, true); // capture phase ensures we intercept before other handlers
    })();
    </script>

    <!-- Unconditional conservative click+scroll guard (production-safe):
         - Records last user click scroll position/time
         - Microtask restores scroll if it immediately jumps to top after a click
         - Overrides window.scrollTo to block programmatic scroll-to-top right after interaction
         - Whitelist by setting `window.allowScrollToTop = true` when needed
    -->
    <script>
    (function(){
        'use strict';
        try {
            window.__lastUserInteraction = window.__lastUserInteraction || { time: 0, y: 0 };

            // Capture-phase listener records last Y and timestamp for user interactions
            document.addEventListener('click', function(e){
                try {
                    var y = window.pageYOffset || document.documentElement.scrollTop || 0;
                    window.__lastUserInteraction.time = Date.now();
                    window.__lastUserInteraction.y = y;

                    // schedule a microtask to detect immediate jump-to-top caused by this click
                    Promise.resolve().then(function(){
                        try {
                            var afterY = window.pageYOffset || document.documentElement.scrollTop || 0;
                            if ((afterY === 0 || Math.abs(afterY) <= 2) && window.__lastUserInteraction.y > 30 && !window.allowScrollToTop) {
                                // restore using safeRestoreScroll if available
                                try {
                                    if (window.safeRestoreScroll && typeof window.safeRestoreScroll === 'function') {
                                        window.safeRestoreScroll(window.__lastUserInteraction.y, { behavior: 'auto', timeout: 300 });
                                    } else {
                                        window.scrollTo(0, window.__lastUserInteraction.y);
                                    }
                                } catch (err) {
                                    try { window.scrollTo(0, window.__lastUserInteraction.y); } catch(e){}
                                }
                            }
                        } catch(e) {}
                    });
                } catch(e) { /* ignore */ }
            }, true);

            // Override window.scrollTo conservatively: if a script tries to programmatically set top=0
            // shortly after a user interaction, prevent it unless explicitly allowed.
            (function(){
                var origScrollTo = window.scrollTo.bind(window);
                window.scrollTo = function(x, y){
                    try {
                        var targetY = null;
                        if (arguments.length === 1 && typeof x === 'object' && x !== null) {
                            if (x.top !== undefined) targetY = x.top;
                        } else if (arguments.length >= 2) {
                            targetY = y;
                        }

                        var now = Date.now();
                        if (targetY === 0 || targetY === 0) {
                            var last = window.__lastUserInteraction || { time: 0, y: 0 };
                            if (!window.allowScrollToTop && last && (now - last.time) < 700 && last.y > 30) {
                                // Block the jump-to-top; instead restore to last y.
                                try {
                                    if (window.safeRestoreScroll && typeof window.safeRestoreScroll === 'function') {
                                        window.safeRestoreScroll(last.y, { behavior: 'auto', timeout: 300 });
                                    } else {
                                        origScrollTo(0, last.y);
                                    }
                                } catch (e) {
                                    try { origScrollTo(0, last.y); } catch(_) {}
                                }
                                return;
                            }
                        }
                    } catch (e) { /* ignore */ }
                    return origScrollTo.apply(window, arguments);
                };
            })();

            console.log('Conservative click+scroll guard initialized');
        } catch(e) { console.warn('click+scroll guard init failed', e); }
    })();
    </script>

    {# Add a floating button for the assistant modal #}
    {# Remove the floating assistant button:
    <button id="openAssistantModalBtn" class="btn btn-primary rounded-circle shadow position-fixed" style="bottom: 32px; right: 32px; z-index: 1050; width: 60px; height: 60px; display: flex; align-items: center; justify-content: center;">
        <i class="fas fa-robot fa-lg"></i>
    </button>
    #}

    {# Assistant Chat Modal #}
    {# Remove the Assistant Chat Modal HTML and its script block. #}

    {# Add a Chat tab to the navbar #}
    {# This <li> is now inside the navbar <ul> #}

    {# Add the Chat Modal with tabs for DMs, Assistant, and Groups #}
    <div class="modal fade" id="chatModal" tabindex="-1" aria-labelledby="chatModalLabel" aria-hidden="true">
      <div class="modal-dialog modal-lg modal-dialog-centered">
        <div class="modal-content">
          <div class="modal-header">
            <h5 class="modal-title" id="chatModalLabel">Chat</h5>
            <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
          </div>
          <div class="modal-body">
            <ul class="nav nav-tabs" id="chatTab" role="tablist" style="margin-bottom: 1rem;">
              <li class="nav-item" role="presentation">
                <button class="nav-link active" id="dm-tab" data-bs-toggle="tab" data-bs-target="#dmTabPane" type="button" role="tab">DMs</button>
              </li>
              <li class="nav-item" role="presentation">
                <button class="nav-link" id="assistant-tab" data-bs-toggle="tab" data-bs-target="#assistantTabPane" type="button" role="tab">Assistant</button>
              </li>
              <li class="nav-item" role="presentation">
                <button class="nav-link" id="group-tab" data-bs-toggle="tab" data-bs-target="#groupTabPane" type="button" role="tab">Groups</button>
              </li>
            </ul>
            <div class="tab-content" id="chatTabContent">
              <div class="tab-pane fade show active" id="dmTabPane" role="tabpanel">
                <div id="dmChatContainer" style="max-height: 300px; overflow-y: auto; border: 1px solid #eee; border-radius: 8px; padding: 10px; margin-bottom: 10px; background: #fff;"></div>
                <div class="input-group mt-3">
                  <input type="text" class="form-control" id="dmChatInput" placeholder="Type a message...">
                  <button class="btn btn-primary" id="dmSendBtn">Send</button>
                </div>
              </div>
              <div class="tab-pane fade" id="assistantTabPane" role="tabpanel">
                <div id="assistantChatContainer" style="max-height: 300px; overflow-y: auto; border: 1px solid #eee; border-radius: 8px; padding: 10px; margin-bottom: 10px; background: #fff;"></div>
                <div class="input-group mt-3">
                  <input type="text" class="form-control" id="assistantChatInput" placeholder="Ask the assistant...">
                  <button class="btn btn-primary" id="assistantSendBtn">Send</button>
                </div>
              </div>
              <div class="tab-pane fade" id="groupTabPane" role="tabpanel">
                <div class="mb-2">
                  <input type="text" id="groupNameInput" class="form-control form-control-sm d-inline-block" style="width: 200px; display: inline-block;" placeholder="Group name">
                  <button class="btn btn-outline-primary btn-sm" id="joinGroupBtn">Join/Create Group</button>
                  <select id="currentGroupSelect" class="form-select form-select-sm d-inline-block" style="width: 200px; display: inline-block;"></select>
                  <button class="btn btn-outline-danger btn-sm" id="leaveGroupBtn">Leave Group</button>
                </div>
                <div id="groupChatContainer" style="max-height: 300px; overflow-y: auto; border: 1px solid #eee; border-radius: 8px; padding: 10px; margin-bottom: 10px; background: #fff;"></div>
                <div class="input-group mt-3">
                  <input type="text" class="form-control" id="groupChatInput" placeholder="Type a group message...">
                  <button class="btn btn-primary" id="groupSendBtn">Send</button>
                </div>
              </div>
            </div>
          </div>
        </div>
      </div>
    </div>

    <script>
    document.addEventListener('DOMContentLoaded', function() {
            // Global safeguard: prevent anchors with href="#" from changing the hash/scroll
            // Many templates use href="#" for buttons; on some mobile browsers tapping these
            // will jump the page to the top. Intercept and prevent default for those anchors.
            document.body.addEventListener('click', function(e) {
                try {
                    // Find nearest anchor element
                    const anchor = e.target.closest && e.target.closest('a');
                    if (!anchor) return;

                    const href = (anchor.getAttribute('href') || '').trim();

                    // Allow anchors used by Bootstrap or ARIA controls to function
                    const isToggle = anchor.hasAttribute('data-bs-toggle') || anchor.hasAttribute('data-toggle') || anchor.getAttribute('role') === 'button' || anchor.hasAttribute('data-bs-target') || anchor.hasAttribute('aria-controls');

                    // If href is empty, just '#', javascript:void, or '#' plus whitespace, prevent navigation
                    const isHarmlessHash = href === '#' || href === '' || href.toLowerCase().startsWith('javascript:') || href === '#!';

                    if (isHarmlessHash && !isToggle) {
                        // Prevent default navigation which can jump to top on mobile browsers
                        e.preventDefault();

                        // If the anchor is being used purely as a wrapper for a control element,
                        // forward the click to the first interactive child so existing handlers run.
                        const innerBtn = anchor.querySelector('button, [role="button"], input[type="button"], input[type="submit"]');
                        if (innerBtn) {
                            // Dispatch a click event on the inner control in a safe way
                            try { innerBtn.click(); } catch (err) { /* ignore */ }
                        }
                        return;
                    }

                    // If this is an href to an internal hash targeting an element on the page,
                    // allow default behavior only if the element exists; otherwise prevent jump
                    if (href.startsWith('#') && href.length > 1 && !isToggle) {
                        const targetEl = document.getElementById(href.slice(1));
                        if (!targetEl) {
                            e.preventDefault();
                            return;
                        }
                    }
                } catch (err) {
                    // swallow errors to avoid breaking pages
                    console.warn('anchor click safeguard error', err);
                }
            }, { passive: false });

            // Additional narrow-screen capture-phase guard: record scrollY before clicks
            // and prevent stray href="#" clicks from jumping the page on small viewports.
            document.addEventListener('click', function(e) {
                try {
                                // Only active for narrow screens or tall portrait devices where this is a frequent problem
                                const isPortraitTallNow = (window.innerHeight > window.innerWidth) && (window.innerHeight >= 900);
                                if (window.innerWidth > 900 && !isPortraitTallNow) return;

                    // Snapshot before click
                    const beforeY = window.pageYOffset || document.documentElement.scrollTop || 0;

                    const anchor = e.target.closest && e.target.closest('a');
                    if (!anchor) return;

                    const href = (anchor.getAttribute('href') || '').trim();
                    if (!href || href === '#' || href.toLowerCase().startsWith('javascript:')) {
                        // Prevent default navigation
                        if (e.cancelable) e.preventDefault();
                        // After a microtask, if scroll moved to top, restore it
                        Promise.resolve().then(() => {
                            const afterY = window.pageYOffset || document.documentElement.scrollTop || 0;
                            if (afterY === 0 && beforeY > 50) {
                                // Use safeRestoreScroll if available to cooperate with stabilizer
                                if (window.safeRestoreScroll && typeof window.safeRestoreScroll === 'function') {
                                    window.safeRestoreScroll(beforeY, { behavior: 'auto', timeout: 300 });
                                } else {
                                    try { window.scrollTo(0, beforeY); } catch(e){}
                                }
                            }
                        });
                        return;
                    }
                } catch (err) {
                    console.warn('narrow-screen click guard error', err);
                }
            }, { passive: false, capture: true });

            // Prevent focus() calls from scrolling the page in browsers that don't support
            // the preventScroll option reliably. We wrap focus to provide preventScroll when possible.
            (function(){
                try {
                    const origFocus = HTMLElement.prototype.focus;
                    HTMLElement.prototype.focus = function(options){
                        if (typeof options === 'object' && options && options.preventScroll) {
                            // browser supports options, call through
                            return origFocus.call(this, options);
                        }
                        // Try to call with preventScroll option first
                        try {
                            return origFocus.call(this, { preventScroll: true });
                        } catch(e) {
                            // Fallback to original focus without scrolling
                            try { return origFocus.call(this); } catch(e2) { /* ignore */ }
                        }
                    };
                } catch (e) { /* ignore if prototype can't be modified */ }
            })();

            // Page-scoped defensive guard: prevent immediate scroll-to-top calls
            // caused by third-party code right after a user click inside the scouting form.
            // We now implement this by listening for clicks inside the form and, when
            // necessary, using the global safeRestoreScroll helper to perform intended
            // restores. The stabilizer suppression flag is handled by safeRestoreScroll.
            try {
                if (window.location.pathname && window.location.pathname.includes('/scouting/form')) {
                    // When user clicks in the form content, mark the element so any
                    // legitimate restore code can route through safeRestoreScroll.
                    document.body.addEventListener('click', function(ev) {
                        try {
                            const inForm = ev.target && ev.target.closest && (ev.target.closest('#form-content') || ev.target.closest('#scouting-form'));
                            if (inForm) {
                                // Attach a short-lived marker to the document that other code
                                // can check before calling window.scrollTo directly. Prefer
                                // to call safeRestoreScroll instead of calling window.scrollTo.
                                window.__recentlyClickedInScoutingForm = Date.now();
                                window.setTimeout(function(){ try { delete window.__recentlyClickedInScoutingForm; } catch(e){} }, 350);
                            }
                        } catch (e) { /* ignore */ }
                    }, true);
                }
            } catch (e) { /* ignore overall errors */ }
        // Open modal on button click


        // Socket.IO setup
        if (!window.socket) {
            window.socket = io();
        }
        const socket = window.socket;
    const recipientSelect = document.getElementById('assistantChatRecipient');
    const chatContainer = document.getElementById('assistantChatContainer');
    const chatInput = document.getElementById('assistantChatInput');
    const sendBtn = document.getElementById('assistantSendBtn');
    const deleteBtn = document.getElementById('assistantDeleteHistoryBtn');
        let allMessages = [];
        let currentRecipient = 'assistant';
        let usernameLoaded = false;

        // Fetch user list for chat (including 'assistant')
        function fetchRecipients() {
            // If the recipient select isn't present on this page, no-op
            if (!recipientSelect) return Promise.resolve();
            return fetch('/assistant/chat-users')
                .then(r => r.json())
                .then(data => {
                    recipientSelect.innerHTML = '';
                    // Always add assistant as an option
                    const optAssistant = document.createElement('option');
                    optAssistant.value = 'assistant';
                    optAssistant.textContent = 'Assistant';
                    recipientSelect.appendChild(optAssistant);
                    // Add users
                    data.users.forEach(u => {
                        const opt = document.createElement('option');
                        opt.value = u;
                        opt.textContent = u + (u === data.current_user ? ' (You)' : '');
                        recipientSelect.appendChild(opt);
                    });
                });
        }

        if (recipientSelect) {
            recipientSelect.addEventListener('change', function() {
                currentRecipient = this.value;
                renderHistory(allMessages);
            });
        }

        function renderMessage(msg) {
            // Only show messages for the selected recipient
            if ((currentRecipient === 'assistant' && msg.recipient === 'assistant') ||
                (msg.sender === currentRecipient && msg.recipient === window.currentUsername) ||
                (msg.sender === window.currentUsername && msg.recipient === currentRecipient)) {
                const div = document.createElement('div');
                div.className = 'mb-2';
                div.innerHTML = `<strong>${msg.sender}:</strong> <span>${msg.text}</span> <span class="text-muted" style="font-size:0.8em;">${new Date(msg.timestamp).toLocaleTimeString()}</span>`;
                chatContainer.appendChild(div);
                chatContainer.scrollTop = chatContainer.scrollHeight;
            }
        }

        function renderHistory(history) {
            chatContainer.innerHTML = '';
            allMessages = history;
            history.forEach(renderMessage);
        }

        socket.on('assistant_chat_message', function(msg) {
            allMessages.push(msg);
            renderMessage(msg);
        });
        socket.on('assistant_chat_history', renderHistory);

        if (sendBtn) {
            sendBtn.disabled = true;

            sendBtn.addEventListener('click', function() {
                const text = (chatInput && chatInput.value || '').trim();
                if (text && window.currentUsername) {
                    console.log('Sending:', { text, recipient: currentRecipient, sender: window.currentUsername });
                    socket.emit('assistant_chat_message', { text, recipient: currentRecipient, sender: window.currentUsername });
                    if (chatInput) chatInput.value = '';
                } else {
                    alert('Username not loaded yet. Please wait.');
                }
            });
            if (chatInput) {
                chatInput.addEventListener('keypress', function(e) {
                    if (e.key === 'Enter') sendBtn.click();
                });
            }
        }

        if (deleteBtn) {
            deleteBtn.addEventListener('click', function() {
                fetch('/assistant/delete-chat-history', { method: 'POST' })
                    .then(r => r.json())
                    .then(data => {
                        if (data.success) {
                            if (chatContainer) chatContainer.innerHTML = '';
                        } else {
                            alert(data.message || 'Failed to delete chat history');
                        }
                    });
            });
        }

        // On modal open, fetch recipients and chat history
        const openBtn = document.getElementById('openAssistantModalBtn');
        if (openBtn) {
            openBtn.addEventListener('click', function() {
                const modal = new bootstrap.Modal(document.getElementById('assistantModal'));
                modal.show();
                fetchRecipients();
                if (window.socket) {
                    window.socket.emit('assistant_chat_history_request');
                }
            });
        }

        // Get current username for filtering
        fetch('/assistant/chat-users').then(r => r.json()).then(data => {
            window.currentUsername = data.current_user;
            sendBtn.disabled = false;
            usernameLoaded = true;
            console.log('Current username loaded:', window.currentUsername);
        });

        // Open chat modal from navbar
        const openChatModalNav = document.getElementById('openChatModalNav');
        if (openChatModalNav) {
            openChatModalNav.addEventListener('click', function(e) {
                e.preventDefault();
                const modal = new bootstrap.Modal(document.getElementById('chatModal'));
                modal.show();
            });
        }
        // Assistant tab logic: send message to /assistant/ask and display response
        const assistantSendBtn = document.getElementById('assistantSendBtn');
        const assistantChatInput = document.getElementById('assistantChatInput');
        const assistantChatContainer = document.getElementById('assistantChatContainer');
        assistantSendBtn.addEventListener('click', async function() {
            const question = assistantChatInput.value.trim();
            if (!question) return;
            // Show user message
            const userDiv = document.createElement('div');
            userDiv.className = 'mb-2';
            userDiv.innerHTML = `<strong>You:</strong> <span>${question}</span>`;
            assistantChatContainer.appendChild(userDiv);
            assistantChatInput.value = '';
            assistantChatContainer.scrollTop = assistantChatContainer.scrollHeight;
            // Send to backend
            const response = await fetch('/assistant/ask', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ question })
            });
            const data = await response.json();
            const botDiv = document.createElement('div');
            botDiv.className = 'mb-2';
            botDiv.innerHTML = `<strong>Assistant:</strong> <span>${data.text || data.message || 'No response.'}</span>`;
            assistantChatContainer.appendChild(botDiv);
            assistantChatContainer.scrollTop = assistantChatContainer.scrollHeight;
        });
        assistantChatInput.addEventListener('keypress', function(e) {
            if (e.key === 'Enter') assistantSendBtn.click();
        });
        // ... (existing DM and group chat logic would go here) ...
    });
    </script>
    <script>
    document.addEventListener('DOMContentLoaded', function() {
        async function updateChatUnreadBadge() {
            try {
                const resp = await fetch('/chat/state');
                const data = await resp.json();
                const badge = document.getElementById('chatUnreadBadge');
                const userDot = document.getElementById('userChatDot');
                const userUnreadItem = document.getElementById('userDropdownUnreadItem');
                const openUnreadChatLink = document.getElementById('openUnreadChatLink');
                if (badge) {
                    if (data.unreadCount && data.unreadCount > 0) {
                        badge.textContent = data.unreadCount;
                        badge.style.display = '';
                        // show red dot on user dropdown
                        if (userDot) userDot.style.display = '';
                        if (userUnreadItem) userUnreadItem.style.display = '';
                        // if backend provided a source, add it as query param so chat page can focus
                        if (openUnreadChatLink && data.lastSource) {
                            // lastSource could be {type: 'dm'|'group', id: 'username'|'groupname'}
                            try {
                                const s = encodeURIComponent(JSON.stringify(data.lastSource));
                                openUnreadChatLink.href = `{{ url_for('main.chat_page') }}?focus=${s}`;
                            } catch(e) {}
                        } else if (openUnreadChatLink) {
                            openUnreadChatLink.href = `{{ url_for('main.chat_page') }}`;
                        }
                    } else {
                        badge.style.display = 'none';
                        if (userDot) userDot.style.display = 'none';
                        if (userUnreadItem) userUnreadItem.style.display = 'none';
                    }
                }
            } catch (e) {}
        }
        // Update on page load
        updateChatUnreadBadge();
        // Poll every 10 seconds
        setInterval(updateChatUnreadBadge, 10000);
        // Listen for real-time DM and group chat events if socket.io is available
        if (window.socket) {
            window.socket.on('dm_message', function(msg) {
                if (!window.location.pathname.startsWith('/chat')) {
                    // include source info so dropdown can open focused DM
                    fetch('/chat/increment-unread', {method: 'POST', headers: {'Content-Type':'application/json'}, body: JSON.stringify({lastSource: {type: 'dm', id: msg.sender}})}).then(updateChatUnreadBadge);
                }
            });
            // Group chat messages are disabled in this build; no-op.
        }
        // When chat page/modal is opened, reset unread count
        const chatNavItem = document.getElementById('chatNavItem');
        if (chatNavItem) {
            chatNavItem.addEventListener('click', function() {
                // When user opens chat, clear unread and any source pointer
                fetch('/chat/reset-unread', {method: 'POST'}).then(updateChatUnreadBadge);
            });
        }
        
        // ======== REAL-TIME CONFIG SYNC ========
        
        // Store current config data globally
        window.currentConfig = {
            game_config: null,
            pit_config: null,
            alliance_status: null
        };
        
        // Track if this is the initial config load
        window.configInitialized = false;
        
        // Function to fetch current configuration
        function fetchCurrentConfig() {
            return fetch('/alliances/scouting/config/current')
                .then(response => response.json())
                .then(data => {
                    window.currentConfig = data;
                    return data;
                })
                .catch(error => {
                    console.warn('Could not fetch current config:', error);
                    return null;
                });
        }
        
        // Function to update alliance status in navigation
        function updateAllianceStatusNav(allianceStatus, allianceInfo) {
            const allianceStatusElement = document.querySelector('[data-alliance-status]');
            if (allianceStatusElement) {
                if (allianceStatus) {
                    allianceStatusElement.innerHTML = `
                        <div class="d-flex align-items-center">
                            <i class="fas fa-users me-1"></i>Alliance Mode Active
                            <small class="text-muted ms-1">
                                ${allianceInfo ? allianceInfo.alliance_name : ''}
                            </small>
                        </div>
                    `;
                    allianceStatusElement.style.display = 'block';
                } else {
                    allianceStatusElement.style.display = 'none';
                }
            }
        }
        
        // Function to show auto-sync notifications
        function showAutoSyncNotification(message, type = 'info') {
            // Normalize type values to Bootstrap alert classes
            let normalizedType = type;
            if (!type || type === 'info' || type === 'message' || type === 'default') {
                normalizedType = 'success';
            } else if (type === 'error' || type === 'err') {
                normalizedType = 'danger';
            } else if (type === 'warn') {
                normalizedType = 'warning';
            }

            // Create a notification banner
            const notification = document.createElement('div');
            notification.className = `alert alert-${normalizedType} alert-dismissible fade show position-fixed`;
            notification.style.cssText = 'top: 80px; right: 20px; z-index: 9999; max-width: 400px; box-shadow: 0 4px 8px rgba(0,0,0,0.2);';
            
            const iconMap = {
                'info': 'fas fa-sync-alt',
                'success': 'fas fa-check-circle',
                'warning': 'fas fa-exclamation-triangle',
                'danger': 'fas fa-times-circle'
            };

            const icon = iconMap[normalizedType] || iconMap['info'];
            
            notification.innerHTML = `
                <div class="d-flex align-items-center">
                    <i class="${icon} me-2"></i>
                    <div>
                        <strong>Alliance Auto-Sync</strong><br>
                        <small>${message}</small>
                    </div>
                </div>
                <button type="button" class="btn-close" data-bs-dismiss="alert"></button>
            `;
            
            document.body.appendChild(notification);
            
            // Auto-remove after 8 seconds
            setTimeout(() => {
                if (notification.parentNode) {
                    const bsAlert = new bootstrap.Alert(notification);
                    bsAlert.close();
                }
            }, 8000);
        }
        
        // Function to trigger config refresh events for other scripts
        function triggerConfigUpdate(configData, isInitialLoad = false) {
            // Only dispatch update events if this is not the initial load
            if (!isInitialLoad && window.configInitialized) {
                // Dispatch custom events that other pages can listen to
                window.dispatchEvent(new CustomEvent('configUpdated', {
                    detail: configData
                }));
                
                window.dispatchEvent(new CustomEvent('gameConfigUpdated', {
                    detail: configData.game_config
                }));
                
                window.dispatchEvent(new CustomEvent('pitConfigUpdated', {
                    detail: configData.pit_config
                }));
                
                window.dispatchEvent(new CustomEvent('allianceStatusUpdated', {
                    detail: configData.alliance_status
                }));
                
                console.log('Config update events dispatched for real change');
            } else {
                console.log('Skipping config update events for initial load');
            }
        }
        
        // Socket.IO listeners for real-time updates
        if (window.socket) {
            // Auto-join team room when connected
            window.socket.on('connect', function() {
                console.log('Socket.IO connected, joining team room...');
                {% if current_user.is_authenticated and current_user.scouting_team_number %}
                    window.socket.emit('join_team_room');
                    console.log('Joined team room for team {{ current_user.scouting_team_number }}');
                {% endif %}
            });
            
            // Handle team room join confirmation
            window.socket.on('joined_team_room', function(data) {
                console.log('Successfully joined team room:', data.team_number);
            });
            
            // Listen for alliance mode toggles
            window.socket.on('alliance_mode_toggled', function(data) {
                console.log('Alliance mode toggled:', data);
                window.currentConfig.game_config = data.effective_game_config;
                window.currentConfig.pit_config = data.effective_pit_config;
                window.currentConfig.alliance_status = {
                    is_active: data.alliance_status,
                    alliance_info: data.alliance_info,
                    team_number: data.team_number
                };
                
                triggerConfigUpdate(window.currentConfig, false); // This is a real update
                updateAllianceStatusNav(data.alliance_status, data.alliance_info);
            });
            
            // Listen for general config updates
            window.socket.on('config_updated', function(data) {
                console.log('Config updated:', data);
                window.currentConfig.game_config = data.effective_game_config;
                window.currentConfig.pit_config = data.effective_pit_config;
                window.currentConfig.alliance_status = {
                    is_active: data.alliance_status,
                    alliance_info: data.alliance_info,
                    team_number: data.team_number
                };
                
                triggerConfigUpdate(window.currentConfig, false); // This is a real update
            });
            
            // Listen for alliance status changes (for nav bar updates)
            window.socket.on('alliance_status_changed', function(data) {
                console.log('Alliance status changed:', data);
                updateAllianceStatusNav(data.alliance_status, data.alliance_info);
            });
            
            // ======== ALLIANCE AUTO-SYNC HANDLERS ========
            // Listen for automatic alliance data sync
            window.socket.on('alliance_data_sync_auto', function(data) {
                console.log('Received auto-sync data from Team', data.from_team);
                
                // Automatically send acknowledgment that we received the data
                window.socket.emit('alliance_auto_sync_received', data);
                
                // Show notification about incoming data (less verbose for periodic syncs)
                if (data.type === 'periodic_sync') {
                    // Only show periodic sync notifications if there's substantial data
                    const totalEntries = data.scouting_data.length + data.pit_data.length;
                    if (totalEntries > 0) {
                        console.log(`Periodic sync: Received ${totalEntries} entries from Team ${data.from_team}`);
                        // Show subtle notification only for large periodic syncs
                        if (totalEntries >= 5) {
                            showAutoSyncNotification(`Periodic sync: ${totalEntries} entries from Team ${data.from_team}`, 'info');
                        }
                    }
                } else {
                    // Show full notifications for manual/immediate syncs
                    if (data.scouting_data.length > 0) {
                        showAutoSyncNotification(`Received ${data.scouting_data.length} scouting entries from Team ${data.from_team} (${data.alliance_name})`);
                    }
                    if (data.pit_data.length > 0) {
                        showAutoSyncNotification(`Received ${data.pit_data.length} pit scouting entries from Team ${data.from_team} (${data.alliance_name})`);
                    }
                }
            });
            
            // Listen for auto-sync completion confirmations
            window.socket.on('alliance_auto_sync_complete', function(data) {
                console.log('Auto-sync completed:', data);
                if (data.imported_count > 0) {
                    if (data.type === 'periodic_sync') {
                        // Less verbose for periodic syncs
                        console.log(`Periodic sync completed: imported ${data.imported_count} entries from Team ${data.from_team}`);
                        // Only show notification for substantial periodic imports
                        if (data.imported_count >= 3) {
                            showAutoSyncNotification(`Periodic sync: imported ${data.imported_count} entries from Team ${data.from_team}`, 'success');
                        }
                    } else {
                        // Full notification for manual syncs
                        showAutoSyncNotification(`Successfully imported ${data.imported_count} entries from Team ${data.from_team} (${data.alliance_name})`, 'success');
                    }
                    
                    // Refresh current page if it's data-related
                    if (window.location.pathname.includes('/scouting') || 
                        window.location.pathname.includes('/analysis') || 
                        window.location.pathname.includes('/pit-scouting')) {
                        setTimeout(() => {
                            window.location.reload();
                        }, 2000);
                    }
                }
            });
            
            // ======== GLOBAL CONFIG CHANGE HANDLER ========
            // Listen for global config changes that affect ALL pages
            window.socket.on('global_config_changed', function(data) {
                console.log('Global config changed:', data);
                
                // Update local config cache
                window.currentConfig.game_config = data.effective_game_config;
                window.currentConfig.pit_config = data.effective_pit_config;
                window.currentConfig.alliance_status = {
                    is_active: data.alliance_status,
                    alliance_info: data.alliance_info,
                    team_number: data.team_number
                };
                
                // Trigger all config update events
                triggerConfigUpdate(window.currentConfig, false);
                updateAllianceStatusNav(data.alliance_status, data.alliance_info);
                
                // Dispatch global reload events for pages to refresh their content
                window.dispatchEvent(new CustomEvent('globalConfigReload', {
                    detail: {
                        type: data.type,
                        message: data.message,
                        game_config: data.effective_game_config,
                        pit_config: data.effective_pit_config,
                        alliance_status: data.alliance_status,
                        alliance_info: data.alliance_info,
                        timestamp: data.timestamp
                    }
                }));
                
                // Show user notification
                if (data.message) {
                    showGlobalConfigNotification(data.message, data.type);
                }
                
                // Reload page content that depends on config
                reloadConfigDependentContent();
            });
        }
        
        // ======== GLOBAL CONFIG MANAGEMENT FUNCTIONS ========
        
        // Function to show global config notifications
        function showGlobalConfigNotification(message, type) {
            // Create or update notification element
            let notificationId = 'global-config-notification';
            let existingNotification = document.getElementById(notificationId);
            
            if (existingNotification) {
                existingNotification.remove();
            }
            
            const notificationHtml = `
                <div id="${notificationId}" class="alert alert-info alert-dismissible fade show position-fixed" 
                     style="top: 20px; right: 20px; z-index: 9999; max-width: 400px;">
                    <div class="d-flex align-items-center">
                        <i class="fas fa-sync-alt me-2"></i>
                        <div>
                            <strong>Configuration Updated</strong><br>
                            <small>${message}</small>
                        </div>
                    </div>
                    <button type="button" class="btn-close" data-bs-dismiss="alert"></button>
                </div>
            `;
            
            document.body.insertAdjacentHTML('beforeend', notificationHtml);
            
            // Auto-remove after 5 seconds
            setTimeout(() => {
                const notification = document.getElementById(notificationId);
                if (notification) {
                    notification.remove();
                }
            }, 5000);
        }
        
        // Function to reload config-dependent content on the current page
        function reloadConfigDependentContent() {
            const currentPath = window.location.pathname;
            
            // Page-specific content reloading
            if (currentPath.includes('/scouting/form')) {
                reloadScoutingFormContent();
            } else if (currentPath.includes('/graphs') || currentPath.includes('/analytics')) {
                reloadAnalyticsContent();
            } else if (currentPath.includes('/pit_scouting')) {
                reloadPitScoutingContent();
            } else if (currentPath.includes('/matches')) {
                reloadMatchesContent();
            } else if (currentPath.includes('/alliances')) {
                reloadAlliancesContent();
            }
            
            // Reload any generic config-dependent elements
            reloadGenericConfigElements();
        }
        
        // Page-specific reload functions
        function reloadScoutingFormContent() {
            // Trigger form reload if function exists
            if (typeof window.reloadFormWithNewConfig === 'function') {
                window.reloadFormWithNewConfig();
            }
        }
        
        function reloadAnalyticsContent() {
            // Trigger analytics reload if function exists
            if (typeof window.reloadAnalyticsWithNewConfig === 'function') {
                window.reloadAnalyticsWithNewConfig();
            }
        }
        
        function reloadPitScoutingContent() {
            // Trigger pit scouting reload if function exists
            if (typeof window.reloadPitScoutingWithNewConfig === 'function') {
                window.reloadPitScoutingWithNewConfig();
            }
        }
        
        function reloadMatchesContent() {
            // Trigger matches reload if function exists
            if (typeof window.reloadMatchesWithNewConfig === 'function') {
                window.reloadMatchesWithNewConfig();
            }
        }
        
        function reloadAlliancesContent() {
            // Trigger alliances reload if function exists
            if (typeof window.reloadAlliancesWithNewConfig === 'function') {
                window.reloadAlliancesWithNewConfig();
            }
        }
        
        function reloadGenericConfigElements() {
            // Reload any elements with data-config-dependent attribute
            const configElements = document.querySelectorAll('[data-config-dependent]');
            configElements.forEach(element => {
                const reloadType = element.getAttribute('data-config-dependent');
                if (reloadType === 'game' && window.currentConfig.game_config) {
                    // Trigger custom event for this element
                    element.dispatchEvent(new CustomEvent('configReload', {
                        detail: { config: window.currentConfig.game_config, type: 'game' }
                    }));
                } else if (reloadType === 'pit' && window.currentConfig.pit_config) {
                    element.dispatchEvent(new CustomEvent('configReload', {
                        detail: { config: window.currentConfig.pit_config, type: 'pit' }
                    }));
                }
            });
        }
        
        // Initial config fetch on page load
        fetchCurrentConfig().then(configData => {
            if (configData) {
                triggerConfigUpdate(configData, true); // Mark as initial load
                updateAllianceStatusNav(
                    configData.alliance_status.is_active, 
                    configData.alliance_status.alliance_info
                );
                window.configInitialized = true; // Mark config as initialized
            }
        });
        
        // Navbar improvements
        function initNavbarImprovements() {
            // Sync chat badges between desktop and mobile
            function syncChatBadges() {
                const desktopBadge = document.getElementById('chatUnreadBadge');
                const mobileBadge = document.getElementById('chatUnreadBadgeMobile');
                
                if (desktopBadge && mobileBadge) {
                    // Sync visibility
                    if (desktopBadge.style.display !== 'none') {
                        mobileBadge.style.display = 'inline';
                        mobileBadge.textContent = desktopBadge.textContent;
                    } else {
                        mobileBadge.style.display = 'none';
                    }
                }
            }
            
            // Observe changes to desktop badge
            const desktopBadge = document.getElementById('chatUnreadBadge');
            if (desktopBadge) {
                const observer = new MutationObserver(syncChatBadges);
                observer.observe(desktopBadge, {
                    attributes: true,
                    childList: true,
                    subtree: true
                });
                syncChatBadges(); // Initial sync
            }
            
            // Enhanced dropdown animations
            const dropdowns = document.querySelectorAll('.dropdown-menu-animated');
            dropdowns.forEach(dropdown => {
                const parent = dropdown.closest('.dropdown');
                if (parent) {
                    parent.addEventListener('show.bs.dropdown', function() {
                        dropdown.classList.add('show');
                    });
                    
                    parent.addEventListener('hide.bs.dropdown', function() {
                        dropdown.classList.remove('show');
                    });
                }
            });
            
            // Close mobile menu when clicking outside
            document.addEventListener('click', function(e) {
                const navbarCollapse = document.getElementById('navbarMain');
                const navbarToggler = document.querySelector('.navbar-toggler');
                
                if (navbarCollapse && navbarCollapse.classList.contains('show')) {
                    if (!navbarCollapse.contains(e.target) && !navbarToggler.contains(e.target)) {
                        const collapse = new bootstrap.Collapse(navbarCollapse, {
                            toggle: false
                        });
                        collapse.hide();
                    }
                }
            });
            
            // Smooth scroll for navbar brand
            const navbarBrand = document.querySelector('.navbar-brand');
            if (navbarBrand) {
                navbarBrand.addEventListener('click', function(e) {
                    // Only smooth scroll if we're on the same page
                    const href = this.getAttribute('href');
                    if (href && window.location.pathname === href) {
                        e.preventDefault();
                        try {
                            if (window.safeRestoreScroll && typeof window.safeRestoreScroll === 'function') {
                                // Route through global helper so it coordinates with mobile stabilizer
                                window.safeRestoreScroll(0, { behavior: 'smooth', timeout: 200 });
                            } else {
                                // Fallback for older pages/environments
                                window.scrollTo({ top: 0, behavior: 'smooth' });
                            }
                        } catch (err) {
                            try { window.scrollTo({ top: 0, behavior: 'smooth' }); } catch(e) {}
                        }
                    }
                });
            }
            
            // Active state management for single-page navigation
            function updateActiveNavItem() {
                const currentPath = window.location.pathname;
                const navLinks = document.querySelectorAll('.nav-link, .dropdown-item');
                
                navLinks.forEach(link => {
                    const href = link.getAttribute('href');
                    if (href === currentPath) {
                        link.classList.add('active');
                        
                        // Also activate parent dropdown if this is a dropdown item
                        const parentDropdown = link.closest('.dropdown');
                        if (parentDropdown) {
                            const parentToggle = parentDropdown.querySelector('.dropdown-toggle');
                            if (parentToggle) {
                                parentToggle.classList.add('active');
                            }
                        }
                    }
                });
            }
            
            // Call on initial load
            updateActiveNavItem();
        }
        
        // Initialize navbar improvements
        initNavbarImprovements();

            // Clear unread button (x) handler
            const clearUnreadBtn = document.getElementById('clearUnreadBtn');
            if (clearUnreadBtn) {
                clearUnreadBtn.addEventListener('click', function() {
                    fetch('/chat/reset-unread', { method: 'POST' })
                        .then(r => {
                            if (r.ok) {
                                // hide dot and this button
                                const dot = document.getElementById('userChatDot');
                                if (dot) dot.style.display = 'none';
                                clearUnreadBtn.style.display = 'none';
                                const unreadItem = document.getElementById('userDropdownUnreadItem');
                                if (unreadItem) unreadItem.style.display = 'none';
                                const chatBadge = document.getElementById('chatUnreadBadge');
                                if (chatBadge) { chatBadge.style.display = 'none'; chatBadge.textContent = '' }
                            }
                        }).catch(e => console.warn('Failed to clear unread', e));
                });
            }
        
        // Initialize search functionality
        initSearchFunctionality();
        
        // Reinitialize on window resize (when responsive classes change)
        window.addEventListener('resize', function() {
            clearTimeout(window.searchResizeTimeout);
            window.searchResizeTimeout = setTimeout(initSearchFunctionality, 250);
        });
        
        // Initialize dropdown positioning fix
        initDropdownPositioning();

        // Mobile: ensure touch devices reliably open dropdown toggles
        (function ensureTouchDropdowns(){
            if (!('ontouchstart' in window)) return; // only for touch devices
            document.querySelectorAll('.dropdown-toggle').forEach(btn => {
                // Avoid attaching multiple times
                if (btn.__touchHandlerAttached) return;
                btn.__touchHandlerAttached = true;

                btn.addEventListener('touchend', function(e){
                    // If bootstrap dropdown exists, toggle explicitly — this avoids issues when clicks are swallowed by overlays
                    try {
                        if (window.bootstrap && window.bootstrap.Dropdown) {
                            const inst = window.bootstrap.Dropdown.getOrCreateInstance(btn);
                            // If menu not shown, show it; otherwise let Bootstrap handle hide on outside tap
                            const menu = btn.closest('.dropdown')?.querySelector('.dropdown-menu');
                            if (menu && !menu.classList.contains('show')) {
                                inst.show();
                                e.preventDefault();
                            }
                        }
                    } catch (err) {
                        // Fallback to click to let browser/Bootstrap handle it
                        try { btn.click(); } catch(e){}
                    }
                }, { passive: false });
            });
        })();
        
        // Global fallback for any dropdown that opens in the navbar/topbar
        document.addEventListener('show.bs.dropdown', function(event) {
            const dropdown = event.target.closest('.navbar .dropdown, .topbar .dropdown');
            if (dropdown && window.innerWidth >= 992) {
                const toggle = dropdown.querySelector('.dropdown-toggle');
                const menu = dropdown.querySelector('.dropdown-menu');
                if (toggle && menu) {
                    setTimeout(() => {
                        positionFixedDropdown(toggle, menu);
                    }, 1);
                }
            }
        });

        // Also catch the shown event as a final fallback
        document.addEventListener('shown.bs.dropdown', function(event) {
            const dropdown = event.target.closest('.navbar .dropdown, .topbar .dropdown');
            if (dropdown && window.innerWidth >= 992) {
                const toggle = dropdown.querySelector('.dropdown-toggle');
                const menu = dropdown.querySelector('.dropdown-menu');
                if (toggle && menu) {
                    positionFixedDropdown(toggle, menu);
                }
            }
        });

        // Portal navbar/topbar dropdowns to body so they stay fixed during page scroll (desktop only)
        document.addEventListener('shown.bs.dropdown', function(event) {
            try {
                const dropdown = event.target.closest('.navbar .dropdown, .topbar .dropdown');
                if (!dropdown) return;
                // Only portal dropdowns on desktop where we handle fixed positioning.
                if (window.innerWidth < 992) return;
                const menu = dropdown.querySelector('.dropdown-menu');
                const toggle = dropdown.querySelector('.dropdown-toggle');
                if (!menu || !toggle) return;

                // If already portalled, just reposition
                if (menu.__portalPlaceholder) {
                    positionFixedDropdown(toggle, menu);
                    return;
                }

                // Create placeholder in original location
                const placeholder = document.createComment('dropdown-portal-placeholder');
                menu.parentNode.insertBefore(placeholder, menu);
                // Move menu to body and mark as navbar-glass so it matches topbar surface
                menu.classList.add('navbar-glass');
                document.body.appendChild(menu);
                // Mark placeholder and toggle for restoration/repositioning
                menu.__portalPlaceholder = placeholder;
                // Keep a reference to the toggle so we can reposition on scroll/resize
                menu.__portalToggle = toggle;
                menu.__isPortalled = true;

                // Make it fixed and position it
                menu.style.position = 'fixed';
                menu.style.zIndex = '1060';
                menu.style.willChange = 'transform, top, left';
                positionFixedDropdown(toggle, menu);

                // Destroy Popper instance if Bootstrap created one so it won't overwrite our fixed positioning on scroll
                try {
                    if (window.bootstrap && window.bootstrap.Dropdown) {
                        const bsInstance = window.bootstrap.Dropdown.getInstance(toggle);
                        if (bsInstance && bsInstance._popper) {
                            try { bsInstance._popper.destroy(); } catch(e){}
                            try { bsInstance._popper = null; } catch(e){}
                        }
                    }
                } catch (e) { /* ignore */ }

                // Remove any Popper-applied transform/inset so the menu remains where we placed it
                try {
                    menu.style.removeProperty('transform');
                    menu.style.removeProperty('inset');
                    menu.style.removeProperty('right');
                } catch (e) {}
            } catch (e) {
                // ignore portal errors
                console.warn('Dropdown portal error', e);
            }
        });

        // Restore portalled dropdowns when they hide
        document.addEventListener('hide.bs.dropdown', function(event) {
            try {
                const dropdown = event.target.closest('.navbar .dropdown, .topbar .dropdown');
                if (!dropdown) return;
                // The menu might already be in the dropdown or on body. Prefer any portalled menu (navbar-glass) first.
                const menu = document.querySelector('.dropdown-menu.navbar-glass') || dropdown.querySelector('.dropdown-menu') || document.querySelector('.dropdown-menu[aria-expanded="true"]');
                if (!menu) return;
                const placeholder = menu.__portalPlaceholder;
                if (!placeholder) return;

                // Grab the toggle so we can re-create Popper/Dropdown instances later
                const toggle = dropdown.querySelector('.dropdown-toggle');

                // Restore into original parent before the placeholder
                if (placeholder.parentNode) {
                    placeholder.parentNode.insertBefore(menu, placeholder);
                    placeholder.parentNode.removeChild(placeholder);
                } else {
                    // Fallback: append back to dropdown
                    dropdown.appendChild(menu);
                }

                // Remove glass class when restoring
                menu.classList.remove('navbar-glass');

                // Clean up styles
                menu.style.position = '';
                menu.style.left = '';
                menu.style.top = '';
                menu.style.right = '';
                menu.style.bottom = '';
                menu.style.zIndex = '';
                menu.style.willChange = '';
                // Reinitialize Popper/Dropdown for normal future behavior (if toggle exists)
                try {
                    if (toggle && window.bootstrap && window.bootstrap.Dropdown) {
                        // If there's an existing instance, dispose then re-create
                        const existing = window.bootstrap.Dropdown.getInstance(toggle);
                        if (existing && typeof existing.dispose === 'function') existing.dispose();
                        window.bootstrap.Dropdown.getOrCreateInstance(toggle);
                    }
                } catch (e) { /* ignore */ }

                // Normalize ARIA and classes so toggle and menu remain in a consistent hidden state
                try {
                    if (toggle) {
                        toggle.setAttribute('aria-expanded', 'false');
                        toggle.classList.remove('show');
                    }
                    if (menu) {
                        // Remove visibility classes and any Popper styles that might keep it visible
                        menu.classList.remove('show');
                        menu.style.removeProperty('transform');
                        menu.style.removeProperty('inset');
                        menu.removeAttribute('data-popper-placement');

                        // Clear any sizing/overflow we may have set while positioning
                        menu.style.removeProperty('max-height');
                        menu.style.removeProperty('maxWidth');
                        menu.style.removeProperty('overflow');
                        menu.style.removeProperty('overflow-y');

                        // Ensure it's not forcing display or opacity
                        menu.style.display = '';
                        try { menu.style.opacity = ''; } catch(e){}

                        // mark as just hidden to avoid immediate re-open from stray click events
                        try { menu.__justHidden = Date.now(); } catch(e){}
                    }
                } catch (e) { /* ignore */ }

                // Clean up portalling metadata
                try { delete menu.__portalPlaceholder; } catch(e) {}
                try { delete menu.__portalToggle; } catch(e) {}
                try { delete menu.__isPortalled; } catch(e) {}
            } catch (e) {
                console.warn('Dropdown portal restore error', e);
            }
        });
    });
    
    // Fix dropdown positioning for navbar dropdowns
    function initDropdownPositioning() {
        // Only apply to desktop navbar dropdowns
        function handleDropdownPositioning() {
        if (window.innerWidth >= 992) {
            // Include both .navbar and topbar dropdowns so topbar menus are positioned fixed
            const navbarDropdowns = document.querySelectorAll('.navbar .dropdown, .topbar .dropdown');

            navbarDropdowns.forEach(dropdown => {
                const toggle = dropdown.querySelector('.dropdown-toggle');
                const menu = dropdown.querySelector('.dropdown-menu');
                    
                    if (toggle && menu) {
                        // Remove any existing event listeners to prevent duplicates
                        toggle.removeEventListener('click', handleDropdownClick);
                        dropdown.removeEventListener('show.bs.dropdown', handleDropdownShow);
                        dropdown.removeEventListener('shown.bs.dropdown', handleDropdownShown);
                        
                        // Add event listeners
                        toggle.addEventListener('click', handleDropdownClick);
                        dropdown.addEventListener('show.bs.dropdown', handleDropdownShow);
                        dropdown.addEventListener('shown.bs.dropdown', handleDropdownShown);
                        
                        function handleDropdownClick(e) {
                            // If the menu was just hidden (restored) very recently, ignore this click to
                            // avoid a double-toggle situation caused by reparenting and Popper timing.
                            try {
                                const now = Date.now();
                                if (menu && menu.__justHidden && (now - menu.__justHidden) < 400) {
                                    // Clear the flag and bail
                                    delete menu.__justHidden;
                                    return;
                                }
                            } catch (e) {}

                            setTimeout(() => {
                                if (menu.classList.contains('show')) {
                                    positionFixedDropdown(toggle, menu);
                                }
                            }, 5);
                        }
                        
                        function handleDropdownShow() {
                            setTimeout(() => {
                                if (menu.classList.contains('show')) {
                                    positionFixedDropdown(toggle, menu);
                                }
                            }, 5);
                        }
                        
                        function handleDropdownShown() {
                            positionFixedDropdown(toggle, menu);
                        }
                    }
                });
            } else {
                // Reset any fixed positioning for mobile
                const navbarDropdowns = document.querySelectorAll('.navbar .dropdown-menu, .topbar .dropdown-menu');
                navbarDropdowns.forEach(menu => {
                    menu.style.position = '';
                    menu.style.left = '';
                    menu.style.top = '';
                    menu.style.right = '';
                    menu.style.bottom = '';
                });
            }
        }
        
        handleDropdownPositioning();
        
        // Reposition on window resize
        window.addEventListener('resize', function() {
            handleDropdownPositioning();
            
            if (window.innerWidth >= 992) {
                const visibleDropdowns = document.querySelectorAll('.navbar .dropdown-menu.show');
                visibleDropdowns.forEach(menu => {
                    const toggle = menu.closest('.dropdown').querySelector('.dropdown-toggle');
                    if (toggle) {
                        positionFixedDropdown(toggle, menu);
                    }
                });
            }
        });
    }
    
    function positionFixedDropdown(toggle, menu) {
        if (window.innerWidth < 992) return; // Don't apply to mobile
        
        // Force the menu to be visible but transparent to measure it
        menu.style.opacity = '0';
        menu.style.display = 'block';
        menu.style.position = 'fixed';
        menu.style.zIndex = '1060';
        
        const toggleRect = toggle.getBoundingClientRect();
        const menuRect = menu.getBoundingClientRect();
        const viewportWidth = window.innerWidth;
        const viewportHeight = window.innerHeight;
        
        // More generous edge buffers
        const edgeBuffer = 15;
        const bottomBuffer = 20;
        
        // Calculate initial position
        let left = toggleRect.left;
        let top = toggleRect.bottom + 8; // 8px margin-top
        
        // Check if this is a right-aligned dropdown (like user menu)
        const isRightAligned = menu.classList.contains('dropdown-menu-end');
        
        if (isRightAligned) {
            // For right-aligned dropdowns, align to the right edge of the button
            left = toggleRect.right - menuRect.width;
            
            // Enhanced right edge detection - check if dropdown would go off screen
            if (left + menuRect.width > viewportWidth - edgeBuffer) {
                // Move dropdown further left to stay on screen
                left = viewportWidth - menuRect.width - edgeBuffer;
            }
            
            // Enhanced left edge detection - ensure dropdown doesn't go off left edge
            if (left < edgeBuffer) {
                left = edgeBuffer;
                // If dropdown is still too wide for screen, reduce its width
                if (menuRect.width > viewportWidth - (2 * edgeBuffer)) {
                    menu.style.maxWidth = (viewportWidth - (2 * edgeBuffer)) + 'px';
                    menu.style.overflowY = 'auto';
                }
            }
        } else {
            // For left-aligned dropdowns, check if they extend beyond right edge
            if (left + menuRect.width > viewportWidth - edgeBuffer) {
                // Try aligning to right edge of toggle button first
                let rightAlignedLeft = toggleRect.right - menuRect.width;
                if (rightAlignedLeft >= edgeBuffer) {
                    left = rightAlignedLeft;
                    menu.classList.add('dropdown-menu-end');
                } else {
                    // If that still doesn't work, force it to fit within viewport
                    left = viewportWidth - menuRect.width - edgeBuffer;
                    if (left < edgeBuffer) {
                        left = edgeBuffer;
                        menu.style.maxWidth = (viewportWidth - (2 * edgeBuffer)) + 'px';
                        menu.style.overflowY = 'auto';
                    }
                }
            } else {
                menu.classList.remove('dropdown-menu-end');
            }
            // Ensure left-aligned dropdowns don't go off the left edge
            left = Math.max(edgeBuffer, left);
        }
        
        // Enhanced bottom edge detection
        if (top + menuRect.height > viewportHeight - bottomBuffer) {
            // Try showing above the toggle button
            let newTop = toggleRect.top - menuRect.height - 8;
            if (newTop >= 0) {
                top = newTop;
            } else {
                // If it doesn't fit above either, constrain height and add scroll
                top = edgeBuffer;
                menu.style.maxHeight = (viewportHeight - (2 * edgeBuffer)) + 'px';
                menu.style.overflowY = 'auto';
            }
        }
        
        // Apply positioning with !important to override any conflicting CSS
        menu.style.setProperty('left', left + 'px', 'important');
        menu.style.setProperty('top', top + 'px', 'important');
        menu.style.setProperty('right', 'auto', 'important');
        menu.style.setProperty('bottom', 'auto', 'important');
        menu.style.setProperty('position', 'fixed', 'important');
        menu.style.opacity = '1'; // Make visible again
        
        // Debug logging (can be removed in production)
        if (window.location.hostname === 'localhost' || window.location.hostname === '127.0.0.1') {
            console.log('Dropdown positioned:', {
                toggleRect: toggleRect,
                menuRect: menuRect,
                finalLeft: left,
                finalTop: top,
                viewportWidth: viewportWidth,
                isRightAligned: isRightAligned
            });
        }
    }
    
    // Enhanced Search functionality
    // Global function for hiding suggestions
    window.hideSuggestions = function() {
    // Support multiple suggestion containers: topbar (searchSuggestionsTop), navbar (searchSuggestions),
    // and main search page (suggestions)
    const searchSuggestions = document.getElementById('searchSuggestionsTop') || document.getElementById('searchSuggestions') || document.getElementById('suggestions');
    const searchInput = document.getElementById('quickSearchInputTop') || document.getElementById('quickSearchInput');
        
        if (searchSuggestions) {
            searchSuggestions.classList.remove('show');
            searchSuggestions.style.display = 'none';
            selectedIndex = -1;
            if (searchInput) {
                searchInput.setAttribute('aria-expanded', 'false');
            }
            console.log('Suggestions hidden');
        }
    };

    // Global variables for search functionality
    let searchTimeout;
    let selectedIndex = -1;
    let currentSuggestions = [];
    
    // Global function for selecting suggestions
    window.selectSuggestion = function(text, type, searchQuery) {
        const searchInput = document.getElementById('quickSearchInput');
        const searchSuggestions = document.getElementById('searchSuggestions');
        
        if (searchInput) {
            // Use the provided searchQuery if available, otherwise fall back to extraction logic
            let finalSearchQuery = searchQuery;
            
            if (!finalSearchQuery) {
                // Extract meaningful search terms based on type (fallback)
                if (type === 'team') {
                    // For team suggestions like "Team 5454 - Obsidian", extract the team number
                    const teamNumberMatch = text.match(/Team (\d+)/);
                    if (teamNumberMatch) {
                        finalSearchQuery = teamNumberMatch[1]; // Just the team number (e.g., "5454")
                    } else {
                        // If no team number found, use the full text
                        finalSearchQuery = text;
                    }
                } else if (type === 'user') {
                    // For users, use the username as-is
                    finalSearchQuery = text;
                } else {
                    // For other types, use the full text
                    finalSearchQuery = text;
                }
            }
            
            console.log('Selected suggestion:', text, 'Searching for:', finalSearchQuery);
            
            searchInput.value = finalSearchQuery;
            window.hideSuggestions();
            
            // Navigate to search page with the optimized query
            window.location.href = `/search?q=${encodeURIComponent(finalSearchQuery)}`;
        }
    };

    function initSearchFunctionality() {
        // Check if screen is large enough for desktop search
        if (window.innerWidth < 992) {
            console.log('Screen too small for desktop search, skipping initialization');
            return;
        }
        
    const searchInput = document.getElementById('quickSearchInputTop') || document.getElementById('quickSearchInput');
    const searchSuggestions = document.getElementById('searchSuggestionsTop') || document.getElementById('searchSuggestions');
    const searchClearBtn = document.getElementById('searchClearBtnTop') || document.getElementById('searchClearBtn');
        
        console.log('Search elements found:', {
            searchInput: !!searchInput,
            searchSuggestions: !!searchSuggestions,
            searchClearBtn: !!searchClearBtn
        });
        
        if (!searchInput) {
            console.warn('No search input element found');
            return;
        }
        
        if (!searchSuggestions) {
            console.warn('searchSuggestions element not found');
            return;
        }
        
        // Position search suggestions using absolute positioning
        function positionSearchSuggestions() {
            if (searchSuggestions && searchInput) {
                console.log('Positioning search suggestions');
                
                // Get the search input wrapper position
                const inputWrapper = searchInput.closest('.search-input-wrapper');
                const inputRect = inputWrapper.getBoundingClientRect();
                
                // Position dropdown directly below the search bar
                searchSuggestions.style.cssText = `
                    position: fixed !important;
                    top: ${inputRect.bottom + 8}px !important;
                    left: ${inputRect.left}px !important;
                    width: ${Math.max(inputRect.width, 300)}px !important;
                    z-index: 2147483647 !important;
                    background: var(--bs-body-bg) !important;
                    border: 1px solid var(--bs-border-color) !important;
                    border-radius: 12px !important;
                    box-shadow: 0 8px 32px rgba(0, 0, 0, 0.15) !important;
                    display: block !important;
                    opacity: 1 !important;
                    visibility: visible !important;
                    pointer-events: auto !important;
                    overflow-y: auto !important;
                    max-height: 400px !important;
                    backdrop-filter: blur(10px) !important;
                    -webkit-backdrop-filter: blur(10px) !important;
                `;
                
                console.log('Modern dropdown positioning applied');
            }
        }
        
        // Show loading state
        function showLoading() {
            if (!searchSuggestions) return;
            console.log('Showing loading state');
            searchSuggestions.innerHTML = `
                <div class="search-loading" style="padding: 16px; text-align: center; color: var(--bs-secondary);">
                    <div class="spinner-border spinner-border-sm me-2" role="status" aria-hidden="true"></div>
                    Searching...
                </div>
            `;
            searchSuggestions.classList.add('show');
            positionSearchSuggestions();
        }
        
        // Handle search input with debouncing
        searchInput.addEventListener('input', function(e) {
            clearTimeout(searchTimeout);
            const query = this.value.trim();
            
            console.log('Input event (top/global):', query, 'length:', query.length);
            
            // Show/hide clear button
            if (searchClearBtn) {
                searchClearBtn.style.display = query ? 'flex' : 'none';
            }
            
            // Update ARIA attributes
            searchInput.setAttribute('aria-expanded', query.length >= 2 ? 'true' : 'false');
            
            // Hide suggestions immediately if search is empty
            if (query.length === 0) {
                window.hideSuggestions();
                return;
            }
            
            if (query.length < 2) {
                window.hideSuggestions();
                return;
            }
            
            // Show loading immediately for better UX
            showLoading();
            
            searchTimeout = setTimeout(() => {
                console.log('Fetching suggestions for:', query);
                fetchSuggestions(query);
            }, 300); // Increased delay to reduce API calls
        });
        
        // Clear button functionality
        if (searchClearBtn) {
            searchClearBtn.addEventListener('click', function() {
                searchInput.value = '';
                searchInput.focus();
                window.hideSuggestions();
                this.style.display = 'none';
                searchInput.setAttribute('aria-expanded', 'false');
            });
        }
        
        // Hide suggestions when search input loses focus (with delay for clicks)
        searchInput.addEventListener('blur', function() {
            // Small delay to allow for clicking on suggestions
            setTimeout(() => {
                window.hideSuggestions();
            }, 150);
        });
        
        // Show suggestions when search input gains focus (if there's content)
        searchInput.addEventListener('focus', function() {
            if (this.value.trim().length >= 2 && currentSuggestions.length > 0) {
                searchSuggestions.classList.add('show');
                positionSearchSuggestions();
            }
        });
        
        // Add click event delegation for suggestion items
        if (searchSuggestions) {
            searchSuggestions.addEventListener('click', function(e) {
                const suggestionItem = e.target.closest('.suggestion-item');
                if (suggestionItem) {
                    const url = suggestionItem.getAttribute('data-url');
                    if (url) {
                        window.location.href = url;
                        return;
                    }

                    const text = suggestionItem.getAttribute('data-value');
                    const type = suggestionItem.getAttribute('data-type');
                    const searchQuery = suggestionItem.getAttribute('data-search-query');
                    if (text && type) {
                        window.selectSuggestion(text, type, searchQuery);
                    }
                }
            });
        } else {
            console.warn('searchSuggestions element not found for event delegation');
        }
        
        // Reposition dropdown on window resize
        window.addEventListener('resize', function() {
            if (searchSuggestions && searchSuggestions.classList.contains('show')) {
                positionSearchSuggestions();
            }
        });
        
        // Reposition dropdown on scroll
        window.addEventListener('scroll', function() {
            if (searchSuggestions && searchSuggestions.classList.contains('show')) {
                positionSearchSuggestions();
            }
        });
        
        window.addEventListener('resize', positionSearchSuggestions);
        
        // Enhanced keyboard navigation
        searchInput.addEventListener('keydown', function(e) {
            const suggestions = searchSuggestions?.querySelectorAll('.suggestion-item');
            
            if (!suggestions || suggestions.length === 0) {
                if (e.key === 'Enter') {
                    e.preventDefault();
                    performQuickSearch();
                }
                return;
            }
            
            switch (e.key) {
                case 'ArrowDown':
                    e.preventDefault();
                    selectedIndex = Math.min(selectedIndex + 1, suggestions.length - 1);
                    updateSelectedSuggestion(suggestions);
                    scrollToActiveSuggestion();
                    break;
                case 'ArrowUp':
                    e.preventDefault();
                    selectedIndex = Math.max(selectedIndex - 1, -1);
                    updateSelectedSuggestion(suggestions);
                    scrollToActiveSuggestion();
                    break;
                case 'Enter':
                    e.preventDefault();
                    if (selectedIndex >= 0 && suggestions[selectedIndex]) {
                        const text = suggestions[selectedIndex].getAttribute('data-value');
                        const type = suggestions[selectedIndex].getAttribute('data-type');
                        const searchQuery = suggestions[selectedIndex].getAttribute('data-search-query');
                        if (text && type) {
                            window.selectSuggestion(text, type, searchQuery);
                        }
                    } else {
                        performQuickSearch();
                    }
                    break;
                case 'Escape':
                    window.hideSuggestions();
                    searchInput.blur();
                    break;
                case 'Tab':
                    // Allow tabbing through suggestions
                    if (selectedIndex >= 0 && suggestions[selectedIndex]) {
                        e.preventDefault();
                        const text = suggestions[selectedIndex].getAttribute('data-value');
                        const type = suggestions[selectedIndex].getAttribute('data-type');
                        const searchQuery = suggestions[selectedIndex].getAttribute('data-search-query');
                        if (text && type) {
                            window.selectSuggestion(text, type, searchQuery);
                        }
                    }
                    break;
            }
        });
        
        // Scroll active suggestion into view
        function scrollToActiveSuggestion() {
            const activeSuggestion = searchSuggestions?.querySelector('.suggestion-item.active');
            if (activeSuggestion && searchSuggestions) {
                const containerRect = searchSuggestions.getBoundingClientRect();
                const itemRect = activeSuggestion.getBoundingClientRect();
                
                if (itemRect.bottom > containerRect.bottom) {
                    activeSuggestion.scrollIntoView({ block: 'end', behavior: 'smooth' });
                } else if (itemRect.top < containerRect.top) {
                    activeSuggestion.scrollIntoView({ block: 'start', behavior: 'smooth' });
                }
            }
        }
        
        // Hide suggestions when clicking outside
        document.addEventListener('click', function(e) {
            // Don't hide if clicking on the search input, suggestions dropdown, or clear button
            if (!e.target.closest('.enhanced-search-container') && 
                !e.target.closest('#searchSuggestions') &&
                !e.target.closest('#searchClearBtn')) {
                window.hideSuggestions();
            }
        });
        
        // Prevent suggestions from hiding when clicking inside the dropdown
        if (searchSuggestions) {
            searchSuggestions.addEventListener('mousedown', function(e) {
                // Prevent the blur event from firing when clicking on suggestions
                e.preventDefault();
            });
        }
        
        // Enhanced fetch suggestions with categorization
        function fetchSuggestions(query) {
            console.log('Fetching suggestions for:', query); // Debug log

            // Request all suggestion types including matches and scouting to ensure broad coverage
            const typesParam = 'team,user,match,scouting,page';

            fetch(`/search/api/suggestions?q=${encodeURIComponent(query)}&types=${encodeURIComponent(typesParam)}`)
                .then(response => {
                    console.log('Response received:', response.status); // Debug log
                    return response.json();
                })
                .then(data => {
                    console.log('Data received:', data); // Debug log
                    displaySuggestions(data.suggestions || []);
                })
                .catch(error => {
                    console.error('Error fetching suggestions:', error);
                    showNoResults();
                });
        }
        
        // Enhanced display suggestions with categories and icons
        function displaySuggestions(suggestions) {
            console.log('Displaying suggestions:', suggestions); // Debug log
            
            if (!searchSuggestions) {
                console.log('No searchSuggestions element found'); // Debug log
                return;
            }
            
            if (suggestions.length === 0) {
                console.log('No suggestions to display'); // Debug log
                showNoResults();
                return;
            }
            
            currentSuggestions = suggestions;
            console.log('Building HTML for', suggestions.length, 'suggestions'); // Debug log
            
            // Group suggestions by type
            const grouped = suggestions.reduce((acc, suggestion) => {
                const type = suggestion.type || 'other';
                if (!acc[type]) acc[type] = [];
                acc[type].push(suggestion);
                return acc;
            }, {});
            
            let html = '';
            
            // Define category order and labels
            const categoryOrder = ['team', 'user', 'match', 'scouting'];
            const categoryLabels = {
                'team': 'Teams',
                'user': 'Users',
                'match': 'Matches',
                'scouting': 'Scouting'
            };
            
            // Build HTML with categories
            categoryOrder.forEach(type => {
                if (grouped[type] && grouped[type].length > 0) {
                    if (html) html += ''; // Separator between categories
                    html += `<div class="suggestion-category">${categoryLabels[type]}</div>`;
                    
                    grouped[type].forEach((suggestion, index) => {
                        const iconClass = getIconForType(suggestion.type);
                        const globalIndex = suggestions.indexOf(suggestion);
                        
                        html += `
                            <div class="suggestion-item" 
                                 data-index="${globalIndex}" 
                                 data-type="${suggestion.type}" 
                                 data-value="${escapeHtml(suggestion.text)}"
                                 data-search-query="${escapeHtml(suggestion.search_query || suggestion.text)}"
                                 data-url="${escapeHtml(suggestion.url || '')}"
                                 role="option">
                                <div class="suggestion-icon">
                                    <i class="${iconClass}"></i>
                                </div>
                                <div class="suggestion-content">
                                    <div class="suggestion-title">
                                        ${escapeHtml(suggestion.text)}
                                        ${suggestion.event_name || suggestion.event_code ? `<small class="text-muted ms-2">${escapeHtml((suggestion.event_name && suggestion.event_code) ? `${suggestion.event_name} (${suggestion.event_code})` : (suggestion.event_name || suggestion.event_code))}</small>` : ''}
                                    </div>
                                    <div class="suggestion-type">${suggestion.type}</div>
                                </div>
                            </div>
                        `;
                    });
                }
            });
            
            console.log('Generated HTML:', html.substring(0, 100) + '...'); // Debug log
            
            searchSuggestions.innerHTML = html;
            console.log('HTML set, adding show class');
            searchSuggestions.classList.add('show');
            console.log('Show class added, checking visibility:', getComputedStyle(searchSuggestions).display);
            positionSearchSuggestions();
            selectedIndex = -1;
            // If dark mode is active, enforce dark colors on the suggestion container
            try {
                if (document.documentElement.classList.contains('dark-mode')) {
                    searchSuggestions.style.setProperty('background', '#0b0b0d', 'important');
                    searchSuggestions.style.setProperty('color', '#ffffff', 'important');
                    searchSuggestions.style.setProperty('border-color', 'rgba(255,255,255,0.04)', 'important');
                    // Ensure individual suggestion items inherit readable colors
                    const items = searchSuggestions.querySelectorAll('.suggestion-item');
                    items.forEach(it => {
                        it.style.setProperty('background', 'transparent', 'important');
                        it.style.setProperty('color', '#ffffff', 'important');
                        const title = it.querySelector('.suggestion-title'); if (title) title.style.setProperty('color', '#ffffff', 'important');
                        const st = it.querySelector('.suggestion-type'); if (st) st.style.setProperty('color', '#bfbfbf', 'important');
                    });
                }
            } catch (e) { console && console.debug && console.debug('apply dark suggestion styles error', e); }
            
            // Debug: Check element dimensions and position
            const rect = searchSuggestions.getBoundingClientRect();
            console.log('Dropdown dimensions:', {
                width: rect.width,
                height: rect.height,
                top: rect.top,
                left: rect.left,
                visible: rect.width > 0 && rect.height > 0,
                hasContent: searchSuggestions.innerHTML.length > 0
            });
            
            console.log('Suggestions should now be visible'); // Debug log
            
            // Update ARIA attributes
            searchInput.setAttribute('aria-expanded', 'true');
            searchSuggestions.setAttribute('aria-activedescendant', '');
        }
        
        // Show no results message
        function showNoResults() {
            if (!searchSuggestions) return;
            console.log('Showing no results message'); // Debug log
            searchSuggestions.innerHTML = `
                <div class="no-suggestions">
                    <i class="fas fa-search-minus mb-2"></i><br>
                    No suggestions found
                </div>
            `;
            searchSuggestions.classList.add('show');
            positionSearchSuggestions();
        }
        
        // Update selected suggestion styling
        function updateSelectedSuggestion(suggestions) {
            suggestions.forEach((item, index) => {
                item.classList.toggle('active', index === selectedIndex);
            });
            
            // Update ARIA attributes
            if (selectedIndex >= 0 && suggestions[selectedIndex]) {
                const activeId = `suggestion-${selectedIndex}`;
                suggestions[selectedIndex].id = activeId;
                searchInput.setAttribute('aria-activedescendant', activeId);
            } else {
                searchInput.setAttribute('aria-activedescendant', '');
            }
        }
        
        // Enhanced icon mapping
        function getIconForType(type) {
            const icons = {
                'team': 'fas fa-users',
                'user': 'fas fa-user',
                'event': 'fas fa-calendar',
                'match': 'fas fa-gamepad',
                'scouting': 'fas fa-clipboard-list',
                'scouting_data': 'fas fa-clipboard-list'
            };
            return icons[type] || 'fas fa-search';
        }
        
        // Escape HTML to prevent XSS
        function escapeHtml(text) {
            const div = document.createElement('div');
            div.textContent = text;
            return div.innerHTML;
        }
        
        // Perform quick search
        function performQuickSearch() {
            const query = searchInput.value.trim();
            if (query) {
                // Add a subtle animation before navigation
                searchInput.style.transform = 'scale(0.98)';
                setTimeout(() => {
                    window.location.href = `/search?q=${encodeURIComponent(query)}`;
                }, 100);
            }
        }
    }
    
    // Helper function for performQuickSearch (moved outside initSearchFunctionality)
    function performQuickSearch() {
        const searchInput = document.getElementById('quickSearchInput');
        if (searchInput) {
            const query = searchInput.value.trim();
            if (query) {
                window.location.href = `/search?q=${encodeURIComponent(query)}`;
            }
        }
    }
    </script>
</body>
</html>