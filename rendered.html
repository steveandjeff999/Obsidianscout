<!DOCTYPE html>
<html lang="en" class="h-100">
<head>
    <!-- Early theme detection: apply dark-mode class to <html> before CSS loads to prevent white flash -->
    <script>
        // Server-side indication whether liquid glass buttons are allowed for this team.
        // This is a small, early flag used by client scripts to decide whether to honor
        // per-user 'liquid_glass_buttons' preference stored in localStorage.
        window.__server_liquid_glass_allowed = false;
    </script>
    <script>
        (function(){
            try {
                // Check explicit user preference stored in localStorage (string 'true' / 'false')
                var stored = null;
                try { stored = localStorage.getItem('darkMode'); } catch (e) { stored = null; }
                var prefersDark = false;
                try { prefersDark = window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches; } catch(e) { prefersDark = false; }
                var useDark = null;
                if (stored === 'true') useDark = true;
                else if (stored === 'false') useDark = false;
                else useDark = prefersDark;

                if (useDark) {
                    // Apply to documentElement so early CSS can target html.dark-mode or body.dark-mode
                    document.documentElement.classList.add('dark-mode');
                    // Also set a small inline style to ensure background is dark immediately
                    var css = 'html.dark-mode, html.dark-mode body { background: #0b0b0d; color: #e6e6e6; }';
                    var s = document.createElement('style');
                    s.setAttribute('data-ob-theme','early');
                    s.appendChild(document.createTextNode(css));
                    // Insert before other head children
                    var head = document.getElementsByTagName('head')[0];
                    if (head) head.insertBefore(s, head.firstChild);
                }
            } catch (e) { /* fail silently - don't block page */ }
        })();
    </script>
    <script>
        (function(){
            try {
                // Check explicit user preference stored in localStorage for rounded UI
                var storedRounded = null;
                try { storedRounded = localStorage.getItem('rounded_ui'); } catch (e) { storedRounded = null; }
                // Default to rounded UI (false) when user hasn't set a preference
                var useRounded = null;
                if (storedRounded === 'true') useRounded = true;
                else if (storedRounded === 'false') useRounded = false;
                else useRounded = true; // default: rounded UI enabled for modern look

                if (useRounded) {
                    document.documentElement.classList.add('rounded-ui');
                    // Apply very small inline style to reduce flash and ensure early layout
                        var css = 'html.rounded-ui, body.rounded-ui { --border-radius: 1.25rem; }';
                    var s = document.createElement('style');
                    s.setAttribute('data-ob-rounded','early');
                    s.appendChild(document.createTextNode(css));
                    var headEl = document.getElementsByTagName('head')[0];
                    if (headEl) headEl.insertBefore(s, headEl.firstChild);
                }
                // Apply navbar theme early to avoid flash
                try {
                    var storedNavbar = null;
                    try { storedNavbar = localStorage.getItem('navbar_theme'); } catch(e) { storedNavbar = null; }
                    var themeVal = (storedNavbar !== null) ? storedNavbar : 'neutral';
                    document.documentElement.classList.add('nav-theme-'+themeVal);
                    document.body.classList.add('nav-theme-'+themeVal);
                } catch(e) { /* ignore */ }
                // Button shape customization removed: no early UI-shape class is applied
                // Accent color is removed from per-user settings; rely on theme defaults.

                    var br = null; try { br = localStorage.getItem('border_radius'); } catch(e) { br = null; }
                    if (br) { try { document.documentElement.style.setProperty('--border-radius', br+'px'); document.body.style.setProperty('--border-radius', br+'px'); try{ document.documentElement.style.setProperty('--card-radius', Math.max(parseInt(br,10),4) + 'px'); document.body.style.setProperty('--card-radius', Math.max(parseInt(br,10),4) + 'px'); document.documentElement.style.setProperty('--control-radius', Math.max(parseInt(br,10) - 4,4) + 'px'); document.body.style.setProperty('--control-radius', Math.max(parseInt(br,10) - 4,4) + 'px'); }catch(e){} } catch(e){} }

                    /* Button size customization removed: no early btn-size class applied */

                    var elev = null; try { elev = localStorage.getItem('card_elevation'); } catch(e) { elev = null; }
                    if (elev) { try { document.documentElement.classList.add('card-elevation-'+elev); document.body.classList.add('card-elevation-'+elev); } catch(e) {} }

                    var glass = null; try { glass = localStorage.getItem('glass_effect'); } catch(e) { glass = null; }
                    // Default: glass effects enabled unless user explicitly turns them off.
                    // Treat several legacy 'false' variants as disabled so toggles remain consistent.
                    try {
                        var glassVal = String(glass || '').toLowerCase();
                        var disabled = (glassVal === 'false' || glassVal === '0' || glassVal === 'off' || glassVal === 'disabled');
                        // Debug: log early glass preference state when in development
                        try { if(window && window.console && window.console.debug) console.debug('[early-theme] glass_effect=', glass, ' => disabled?', disabled); } catch(e) {}
                        if (disabled) {
                            document.documentElement.classList.add('glass-off');
                            document.body.classList.add('glass-off');
                        }
                    } catch(e) {}
                
                    // Per-user per-team "liquid glass" buttons preference.
                    // Server controls whether this appearance feature is allowed for the team.
                    // - If the server has enabled the feature for the team, the server's
                    //   default will be used unless the user has an explicit local preference.
                    // - If the server has disabled the feature, user preferences are ignored.
                    // Expose a small helper value (set via Jinja below) so this early script
                    // can decide the initial state and avoid visual flashes.
                    try {
                        var serverAllowsLiquid = (typeof window.__server_liquid_glass_allowed !== 'undefined') ? (window.__server_liquid_glass_allowed === true || window.__server_liquid_glass_allowed === 'true') : false;
                        var storedLiquid = null;
                        try { storedLiquid = localStorage.getItem('liquid_glass_buttons'); } catch(e) { storedLiquid = null; }

                        // Honor explicit per-user preference when present; otherwise fall back to server default.
                        if (storedLiquid === 'true') {
                            try { document.documentElement.classList.add('liquid-glass-buttons'); document.body.classList.add('liquid-glass-buttons'); } catch(e) {}
                        } else if (storedLiquid === 'false') {
                            try { document.documentElement.classList.remove('liquid-glass-buttons'); document.body.classList.remove('liquid-glass-buttons'); } catch(e) {}
                        } else {
                            // No per-user pref: fall back to server allowance/template default.
                            if (!serverAllowsLiquid) {
                                try { document.documentElement.classList.remove('liquid-glass-buttons'); document.body.classList.remove('liquid-glass-buttons'); } catch(e) {}
                            }
                            // else leave server default as rendered by template
                        }
                    } catch(e) { /* non-fatal */ }
            } catch (e) { /* silently ignore */ }
        })();
    </script>
    <script>
    // Ensure suggestion dropdowns use dark background when the app is in dark mode.
    (function(){
        function applyDarkToSuggestions(root){
            try{
                const els = (root || document).querySelectorAll('.enhanced-search-suggestions, .enhanced-search-suggestions-main, #suggestions, #searchSuggestionsTop');
                els.forEach(el => {
                    // Use setProperty with priority 'important' to overwrite inline !important styles
                    el.style.setProperty('background', '#0b0b0d', 'important');
                    el.style.setProperty('color', '#ffffff', 'important');
                    el.style.setProperty('border-color', 'rgba(255,255,255,0.04)', 'important');
                });
            }catch(e){console && console.warn && console.warn('applyDarkToSuggestions error', e);}    
        }

        function init() {
            if (document.documentElement.classList.contains('dark-mode')) {
                applyDarkToSuggestions(document);

                // Watch for new suggestion elements being added dynamically
                const bodyObs = new MutationObserver(mutations => {
                    mutations.forEach(m => {
                        m.addedNodes && m.addedNodes.forEach(node => {
                            if (node.nodeType === 1) {
                                if (node.matches && (node.matches('.enhanced-search-suggestions') || node.matches('.enhanced-search-suggestions-main') || node.id === 'searchSuggestionsTop' || node.id === 'suggestions')) {
                                    applyDarkToSuggestions(node.parentNode || document);
                                }
                            }
                        });
                    });
                });
                bodyObs.observe(document.body, { childList: true, subtree: true });

                // Also observe html element class changes (theme toggles)
                const htmlObs = new MutationObserver(mutations => {
                    mutations.forEach(m => {
                        if (m.attributeName === 'class') {
                            if (document.documentElement.classList.contains('dark-mode')) applyDarkToSuggestions(document);
                        }
                    });
                });
                htmlObs.observe(document.documentElement, { attributes: true });
            }
        }

        if (document.readyState === 'loading') document.addEventListener('DOMContentLoaded', init); else init();
    })();
    </script>
    <script>
    // Aggressive short-duration re-apply to catch suggestion elements created very early
    (function(){
        function reapplyDark() {
            try {
                if (!document.documentElement.classList.contains('dark-mode')) return;
                const sel = ['.enhanced-search-suggestions', '.enhanced-search-suggestions-main', '#suggestions', '#searchSuggestionsTop'];
                sel.forEach(s => {
                    document.querySelectorAll(s).forEach(el => {
                        el.style.setProperty('background', '#0b0b0d', 'important');
                        el.style.setProperty('color', '#ffffff', 'important');
                        el.style.setProperty('border-color', 'rgba(255,255,255,0.04)', 'important');
                        el.querySelectorAll('.suggestion-item').forEach(it => {
                            it.style.setProperty('background', 'transparent', 'important');
                            it.style.setProperty('color', '#ffffff', 'important');
                        });
                    });
                });
            } catch (e) { console && console.debug && console.debug('reapplyDark error', e); }
        }

        if (document.readyState === 'complete' || document.readyState === 'interactive') {
            // Run immediately and schedule short repeated attempts
            reapplyDark();
        } else {
            document.addEventListener('DOMContentLoaded', reapplyDark);
        }

        // Run repeatedly for a short window to catch dynamically added inline-styled elements
        let tries = 0;
        const id = setInterval(() => {
            reapplyDark();
            tries += 1;
            if (tries > 20) clearInterval(id); // ~2 seconds at 100ms intervals
        }, 100);
    })();
    </script>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover, shrink-to-fit=no">
    <meta name="csrf-token" content="">
    <title>Scouting Form</title>
    
    
    
    <link href="/static/css/vendor/bootstrap.min.css" rel="stylesheet">
    
    <link href="/static/css/vendor/fontawesome-all.min.css" rel="stylesheet">
    <!-- Preload FontAwesome webfonts to avoid icons briefly missing while fonts load -->
    <link rel="preload" href="/static/css/vendor/webfonts/fa-solid-900.woff2" as="font" type="font/woff2" crossorigin>
    <link rel="preload" href="/static/css/vendor/webfonts/fa-regular-400.woff2" as="font" type="font/woff2" crossorigin>
    <link rel="preload" href="/static/css/vendor/webfonts/fa-brands-400.woff2" as="font" type="font/woff2" crossorigin>

    <!-- Modern fonts: Inter for UI + Poppins for headings -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;600;700&family=Poppins:wght@400;600;700&display=swap" rel="stylesheet">
    
    
    <style>body{font-family: Roboto, Montserrat, system-ui, -apple-system, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif;}</style>
    
    <link href="/static/css/vendor/select2.min.css" rel="stylesheet">
    <link href="/static/css/vendor/select2-bootstrap-5-theme.min.css" rel="stylesheet">
    
    <link rel="stylesheet" href="/static/css/styles.css">
    <script>
        // Apply the current theme as an early-class to avoid visual flash (class added server-side variable)
        (function(){ try { document.documentElement.classList.add('theme-' + 'light'); } catch(e) {} })();
    </script>
    <link rel="stylesheet" href="/static/css/theme-overrides.css">
    <link rel="stylesheet" href="/static/css/modal-fix.css">
    <link rel="stylesheet" href="/static/css/navbar-improvements.css">
    <link rel="stylesheet" href="/static/css/topbar-notifications.css">
    <link rel="stylesheet" href="/static/css/search-enhancements.css">
    <link rel="stylesheet" href="/static/css/sidebar.css">
    <link rel="stylesheet" href="/static/css/modern-ui.css">
    <link rel="stylesheet" href="/static/css/dark-mode-force.css">
    <!-- Modern dark theme additions (more refined surfaces, softened shadows, updated accents) -->
    <link rel="stylesheet" href="/static/css/dark-theme-modern.css">
    <link rel="stylesheet" href="/static/css/glass-theme.css">
    <link rel="stylesheet" href="/static/css/new-glass-theme.css">
    
    <!-- Button shape customization removed: ui-rounded styles no longer included -->
    <link rel="stylesheet" href="/static/css/mobile-fixes.css">
    <!-- Use UMD build of Chart.js for compatibility with non-module script loading -->
    <script src="/static/js/vendor/chart.umd.min.js"></script>
    
    <!-- Dynamic Theme CSS Variables -->
    
    <style>
        /* Ensure card-bg variable uses the neutral, non-blue glass color in dark mode */
        body.dark-mode, body.modern-layout.dark-mode {
            --card-bg: rgba(24,24,26,0.78) !important;
            --glass-bg: rgba(22,22,24,0.70) !important;
            --glass-border: rgba(255,255,255,0.035) !important;
        }
        /* Force nested cards and small panels to match the neutral card background in dark mode.
           This duplicate inline rule helps in cases where external CSS is loaded before our override
           and prevents visual mismatches on initial render. */
        body.dark-mode .card .card,
        body.modern-layout.dark-mode .card .card,
        body.dark-mode .stat-card,
        body.modern-layout.dark-mode .stat-card,
        body.dark-mode .dashboard-card,
        body.modern-layout.dark-mode .dashboard-card {
            background: var(--card-bg) !important;
            background-color: var(--card-bg) !important;
            border: 1px solid rgba(0,0,0,0.45) !important;
            box-shadow: 0 2px 6px rgba(0,0,0,0.45) !important;
            color: var(--bs-body-color) !important;
            background-clip: padding-box !important;
            overflow: hidden !important;
        }
    </style>
    
    <link rel="manifest" href="/static/manifest.json">
    <link rel="icon" type="image/png" sizes="192x192" href="/static/obsidian-192.png">
    <link rel="apple-touch-icon" href="/static/obsidian-192.png">
    <meta name="theme-color" content="#1976d2">
    
    <style>
        .form-switch .form-check-input {
            height: 1.2rem;
            width: 2.2rem;
            cursor: pointer;
        }
        .form-check-label {
            cursor: pointer;
        }
        .dark-mode #darkModeIcon {
            color: #ffc107 !important;
        }
        .dark-mode #darkModeLabel {
            color: #e6e6e6;
        }
        .obsidian-gradient {
            background: linear-gradient(90deg, #7065a2 0%, #625591 100%);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            text-fill-color: transparent;
        }
        /* Small red dot used on user dropdown to indicate unread chat */
        .user-chat-dot {
            display: inline-block;
            width: 10px;
            height: 10px;
            border-radius: 50%;
            background: #dc3545; /* bootstrap danger */
            margin-left: 6px;
            vertical-align: middle;
        }
        
        /* Enhanced Search Component Styles */
        .search-wrapper {
            position: relative;
            flex: 1;
            max-width: 320px;
            min-width: 200px;
        }
        
        .enhanced-search-container {
            position: relative;
            width: 100%;
        }
        
        .search-input-wrapper {
            position: relative;
            display: flex;
            align-items: center;
            background: var(--bs-body-bg);
            border: 2px solid var(--bs-border-color);
            border-radius: 25px;
            transition: all 0.3s ease;
            overflow: hidden;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.08);
        }
        
        .search-input-wrapper:hover {
            border-color: var(--bs-primary);
            box-shadow: 0 4px 12px rgba(var(--bs-primary-rgb), 0.15);
        }
        
        .search-input-wrapper:focus-within {
            border-color: var(--bs-primary);
            box-shadow: 0 0 0 0.2rem rgba(var(--bs-primary-rgb), 0.25);
        }
        
        .search-icon {
            position: absolute;
            left: 14px;
            color: var(--bs-secondary);
            font-size: 0.9rem;
            z-index: 2;
            transition: color 0.3s ease;
        }
        
        .search-input-wrapper:focus-within .search-icon {
            color: var(--bs-primary);
        }
        
        .enhanced-search-input {
            flex: 1;
            border: none !important;
            outline: none !important;
            background: transparent !important;
            padding: 10px 45px 10px 40px !important;
            font-size: 0.9rem;
            color: var(--bs-body-color);
            box-shadow: none !important;
            border-radius: 0;
        }
        
        .enhanced-search-input::placeholder {
            color: var(--bs-secondary);
            font-style: italic;
        }
        
        .search-clear-btn {
            position: absolute;
            right: 45px;
            background: none;
            border: none;
            color: var(--bs-secondary);
            padding: 4px;
            border-radius: 50%;
            width: 20px;
            height: 20px;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            transition: all 0.2s ease;
            z-index: 2;
        }
        
        .search-clear-btn:hover {
            background: var(--bs-secondary-bg);
            color: var(--bs-danger);
        }
        
        .search-submit-btn {
            position: absolute;
            right: 4px;
            background: var(--bs-primary);
            border: none;
            color: white;
            padding: 8px;
            border-radius: 50%;
            width: 34px;
            height: 34px;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            transition: all 0.2s ease;
            z-index: 2;
        }
        
        .search-submit-btn:hover {
            background: var(--bs-primary);
            filter: brightness(110%);
            transform: scale(1.05);
        }
        
        .search-submit-btn:active {
            transform: scale(0.95);
        }

        /* Dark-mode overrides for navbar/main search so input is dark and text is white */
        body.dark-mode .search-input-wrapper,
        body.dark-mode .enhanced-search-input,
        body.dark-mode .search-input-wrapper .enhanced-search-input {
            background: #121212 !important;
            border-color: rgba(255,255,255,0.06) !important;
            color: #ffffff !important;
        }

        body.dark-mode .search-input-wrapper .search-icon,
        body.dark-mode .search-input-wrapper .search-clear-btn,
        body.dark-mode .search-input-wrapper .search-submit-btn {
            color: #ececec !important;
        }

        body.dark-mode .enhanced-search-input::placeholder {
            color: #bfbfbf !important;
            opacity: 1;
        }

        /* Make suggestions dropdown dark as well in dark mode */
        html.dark-mode .enhanced-search-suggestions,
        html.dark-mode .enhanced-search-suggestions.show,
        html.dark-mode .enhanced-search-suggestions-main,
        html.dark-mode .enhanced-search-suggestions-main.show,
        html.dark-mode #suggestions,
        body.dark-mode .enhanced-search-suggestions,
        body.dark-mode .enhanced-search-suggestions.show,
        body.dark-mode .enhanced-search-suggestions-main,
        body.dark-mode .enhanced-search-suggestions-main.show,
        body.dark-mode #suggestions {
            background: #0b0b0d !important;
            color: #ffffff !important;
            border-color: rgba(255,255,255,0.04) !important;
        }
        
        /* Enhanced Search Suggestions */
        .enhanced-search-suggestions {
            display: none !important;
        }
        
        .enhanced-search-suggestions.show {
            display: block !important;
            z-index: 9999 !important;
        }
        
        @keyframes searchFadeIn {
            from {
                opacity: 0;
                transform: translateY(-10px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }
        
        .suggestion-item {
            display: flex;
            align-items: center;
            padding: 12px 16px;
            cursor: pointer;
            border-bottom: 1px solid var(--bs-border-color);
            transition: all 0.2s ease;
            position: relative;
        }
        
        .suggestion-item:last-child {
            border-bottom: none;
        }
        
        .suggestion-item:hover,
        .suggestion-item.active {
            background: linear-gradient(135deg, rgba(var(--bs-primary-rgb), 0.1), rgba(var(--bs-primary-rgb), 0.05));
            transform: translateX(4px);
        }
        
        .suggestion-item.active::before {
            content: '';
            position: absolute;
            left: 0;
            top: 0;
            bottom: 0;
            width: 3px;
            background: var(--bs-primary);
            border-radius: 0 2px 2px 0;
        }
        
        .suggestion-icon {
            width: 20px;
            height: 20px;
            display: flex;
            align-items: center;
            justify-content: center;
            margin-right: 12px;
            background: rgba(var(--bs-primary-rgb), 0.1);
            border-radius: 6px;
            color: var(--bs-primary);
            font-size: 0.8rem;
            flex-shrink: 0;
        }
        
        .suggestion-content {
            flex: 1;
            min-width: 0;
        }
        
        .suggestion-title {
            font-weight: 600;
            color: var(--bs-body-color);
            margin-bottom: 2px;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
        }
        
        .suggestion-type {
            font-size: 0.75rem;
            color: var(--bs-secondary);
            text-transform: uppercase;
            letter-spacing: 0.5px;
            font-weight: 500;
        }
        
        .suggestion-category {
            padding: 8px 16px;
            background: var(--bs-secondary-bg);
            color: var(--bs-secondary);
            font-size: 0.75rem;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            border-bottom: 1px solid var(--bs-border-color);
            position: sticky;
            top: 0;
            z-index: 1;
        }
        
        .search-loading {
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 20px;
            color: var(--bs-secondary);
        }
        
        .search-loading-spinner {
            width: 16px;
            height: 16px;
            border: 2px solid var(--bs-secondary-bg);
            border-top: 2px solid var(--bs-primary);
            border-radius: 50%;
            animation: spin 1s linear infinite;
            margin-right: 8px;
        }
        
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
        
        .no-suggestions {
            padding: 20px;
            text-align: center;
            color: var(--bs-secondary);
            font-style: italic;
        }
        
        /* Mobile Search Button Enhancement */
        .modern-search-mobile {
            border-radius: 12px !important;
            background: var(--bs-primary) !important;
            border-color: var(--bs-primary) !important;
            color: white !important;
            transition: all 0.2s ease;
        }
        
        .modern-search-mobile:hover {
            background: var(--bs-primary) !important;
            border-color: var(--bs-primary) !important;
            color: white !important;
            transform: scale(1.05);
            filter: brightness(110%);
        }
        
        /* Responsive Design */
        @media (max-width: 1400px) {
            .search-wrapper {
                max-width: 280px;
                min-width: 180px;
            }
        }
        
        @media (max-width: 1200px) {
            .search-wrapper {
                max-width: 240px;
                min-width: 160px;
            }
            
            .enhanced-search-input {
                font-size: 0.85rem;
                padding: 9px 42px 9px 38px !important;
            }
            
            .search-icon {
                left: 12px;
                font-size: 0.85rem;
            }
            
            .search-submit-btn {
                width: 30px;
                height: 30px;
                right: 3px;
            }
        }
        
        @media (max-width: 992px) {
            .search-wrapper {
                max-width: 200px;
                min-width: 140px;
            }
        }
        
        @media (max-width: 768px) {
            .search-wrapper {
                max-width: auto;
                min-width: auto;
                flex: 0 0 auto;
            }
        }
        
        /* Dark Mode Support */
        .dark-mode .search-input-wrapper {
            background: var(--card-bg);
            border-color: rgba(255, 255, 255, 0.2);
        }
        
        .dark-mode .search-input-wrapper:hover {
            border-color: var(--bs-primary);
        }
        
        .dark-mode .enhanced-search-suggestions {
            background: var(--card-bg);
            border-color: rgba(255, 255, 255, 0.1);
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3);
        }
        
        .dark-mode .suggestion-item {
            border-bottom-color: rgba(255, 255, 255, 0.1);
        }
        
        .dark-mode .suggestion-item:hover,
        .dark-mode .suggestion-item.active {
            background: linear-gradient(135deg, rgba(var(--bs-primary-rgb), 0.2), rgba(var(--bs-primary-rgb), 0.1));
        }
        
        .dark-mode .suggestion-category {
            background: rgba(255, 255, 255, 0.05);
            border-bottom-color: rgba(255, 255, 255, 0.1);
        }
        
        /* Search functionality styles */
        .search-wrapper {
            position: relative;
            flex: 1;
            max-width: 280px;
            min-width: 160px;
        }
        
        /* Mobile Touch and Input Stability Fixes */
        @media (max-width: 768px) {
            /* Prevent iOS zoom on input focus */
            input, textarea, select, .form-control, .form-select {
                font-size: 16px !important;
                transform: translateZ(0);
                -webkit-transform: translateZ(0);
                -webkit-appearance: none;
                border-radius: 4px;
            }
            
            /* Prevent focus outline from causing scroll */
            input:focus, textarea:focus, select:focus, .form-control:focus, .form-select:focus {
                scroll-margin: 0 !important;
                scroll-behavior: auto !important;
                outline: 2px solid var(--bs-primary);
                outline-offset: -2px;
            }
            
            /* Stabilize form containers */
            .form-group, .input-group, .form-floating, .tab-content {
                contain: layout;
                transform: translateZ(0);
                -webkit-transform: translateZ(0);
            }
            
            /* Force hardware acceleration on interactive elements */
            button, .btn, [role="button"], .dropdown-toggle, .nav-link {
                transform: translateZ(0);
                -webkit-transform: translateZ(0);
                -webkit-tap-highlight-color: transparent;
            }
            
            /* Prevent dropdown and modal scroll issues */
            .dropdown-menu, .modal-dialog {
                transform: translateZ(0);
                -webkit-transform: translateZ(0);
            }
            
            /* Prevent body overflow during modal/dropdown interactions */
            body.modal-open, body.dropdown-open {
                overflow: hidden;
                position: fixed;
                width: 100%;
            }
        }
        
        /* Enhanced Mobile Click Protection */
        @media (max-width: 900px) {
            /* Prevent unwanted scroll during interactions */
            * {
                -webkit-overflow-scrolling: touch;
                touch-action: manipulation;
            }
            
            /* Specific protection for common culprits */
            a[href="#"], a[href=""], a[href="javascript:void(0)"] {
                touch-action: none !important;
            }
            
            /* Stable positioning for fixed elements */
            .topbar, .sidebar, .navbar-fixed-top {
                transform: translateZ(0);
                -webkit-transform: translateZ(0);
            }
        }
        
        @media (max-width: 1400px) {
            .search-wrapper {
                max-width: 220px;
                min-width: 140px;
            }
        }
        
        @media (max-width: 1200px) {
            .search-wrapper {
                max-width: 180px;
                min-width: 120px;
            }
        }
        
        @media (max-width: 992px) {
            .search-wrapper {
                max-width: 140px;
                min-width: 100px;
            }
        }
        
        @media (max-width: 768px) {
            .search-wrapper {
                max-width: auto;
                min-width: auto;
                flex: 0 0 auto;
            }
        }
        
        /* Make the navbar more responsive */
        .navbar-actions {
            flex-wrap: nowrap;
            align-items: center;
        }
        
        .navbar-actions > * {
            flex-shrink: 0;
        }
        
        /* Adjust button sizes for mobile */
        @media (max-width: 768px) {
            .btn-sm {
                padding: 0.25rem 0.5rem;
                font-size: 0.775rem;
            }
            
            .dropdown-toggle::after {
                margin-left: 0.255rem;
            }
        }
        
        .search-wrapper .form-control {
            transition: width 0.3s ease;
        }
        
        .search-wrapper .form-control:focus {
            width: 100%;
        }
        
        #searchSuggestions {
            position: absolute;
            top: 100%;
            left: 0;
            right: 0;
            background: var(--bs-body-bg);
            border: 1px solid var(--bs-border-color);
            border-radius: 0.375rem;
            box-shadow: 0 0.5rem 1rem rgba(0, 0, 0, 0.15);
            z-index: 1060; /* Higher than navbar dropdowns */
            max-height: 300px;
            overflow-y: auto;
            display: none;
        }
        
        .suggestion-item {
            cursor: pointer;
            border-bottom: 1px solid var(--bs-border-color);
            transition: background-color 0.15s ease-in-out;
        }
        
        .suggestion-item:last-child {
            border-bottom: none;
        }
        
        .suggestion-item:hover,
        .suggestion-item.active {
            background-color: var(--bs-secondary-bg);
        }
        
        .search-mobile-btn {
            border: none;
            background: none;
            color: var(--bs-nav-link-color);
            padding: 0.5rem;
            border-radius: 0.375rem;
            transition: background-color 0.15s ease-in-out;
        }
        
        .search-mobile-btn:hover {
            background-color: var(--bs-secondary-bg);
            color: var(--bs-nav-link-hover-color);
        }
    </style>
    
    <!-- Global dark-mode background fix: ensure a single uniform page background and
         make page-level layout containers transparent so the body background shows
         through. This prevents multi-band background artifacts when dark-mode is active. -->
    <style id="dark-mode-global-fix">
        /* Force a single solid background color for dark mode (applies early via inline style) */
        html.dark-mode, body.dark-mode {
            background-color: #0b0b0d !important;
            background-image: none !important;
            color: #e6e6e6 !important;
        }

        /* Allow page content containers to be transparent so the body background is visible
           (preserve topbar and sidebar glass surfaces so they keep their intended appearance). */
        html.dark-mode main,
        html.dark-mode footer,
        html.dark-mode .container,
        html.dark-mode .with-sidebar .container {
            background: transparent !important;
            background-image: none !important;
        }

        /* If any stylesheet injected a full-width background gradient on body > * elements,
           make them transparent in dark mode to avoid stacked bands. */
        html.dark-mode > body > *,
        body.dark-mode > * {
            background-image: none !important;
        }

        /* Tweak sidebar active indicator for dark mode: use a subtle neutral tint instead of vivid primary
           so the thin left bar doesn't appear as a harsh blue. Also hide the left bar when the sidebar is
           collapsed (it overlaps centered icons). */
        .dark-mode .sidebar .nav-link.active::before {
            background: rgba(255,255,255,0.10) !important;
            box-shadow: none !important;
        }

        /* When the sidebar is collapsed, remove the left indicator and center icons to avoid overlap */
        body.with-sidebar.sidebar-collapsed .sidebar .nav-link.active::before {
            display: none !important;
        }

        /* Ensure icon-only links are centered when collapsed and maintain a consistent icon width */
        body.with-sidebar.sidebar-collapsed .sidebar .nav-link {
            justify-content: center !important;
            padding-left: 0.25rem !important;
            padding-right: 0.25rem !important;
        }

        body.with-sidebar.sidebar-collapsed .sidebar .nav-link i {
            width: 28px !important;
            text-align: center !important;
            display: inline-block !important;
        }

        /* Center collapsed icons and the brand tile reliably.
           Instead of nudging individual icons, make the brand anchor a full-width
           flex container and center its contents; remove transforms so icon centering
           is predictable across browsers. */
        body.with-sidebar.sidebar-collapsed .sidebar .nav-link {
            justify-content: center !important;
            padding-left: 0.15rem !important;
            padding-right: 0.15rem !important;
        }

        body.with-sidebar.sidebar-collapsed .sidebar .nav-link i {
            width: 28px !important;
            text-align: center !important;
            display: inline-block !important;
            transform: none !important;
            margin: 0 !important;
        }

        /* Make the brand/anchor span the full width and center the brand-logo tile */
        body.with-sidebar.sidebar-collapsed .sidebar .sidebar-header .brand,
        body.with-sidebar.sidebar-collapsed .sidebar .brand {
            width: 100% !important;
            display: flex !important;
            justify-content: center !important;
            align-items: center !important;
            padding-left: 0 !important;
            padding-right: 0 !important;
        }

        body.with-sidebar.sidebar-collapsed .sidebar .brand-logo,
        body.with-sidebar.sidebar-collapsed .sidebar .sidebar-header .brand-logo {
            margin: 0 !important;
            width: 44px !important;
            height: 44px !important;
            padding: 4px !important;
            display: flex !important;
            align-items: center !important;
            justify-content: center !important;
        }

        body.with-sidebar.sidebar-collapsed .sidebar .brand-logo .brand-icon {
            font-size: 1.15rem !important;
            line-height: 1 !important;
        }

        /* Hide brand text and sub-labels when collapsed so only the icon shows */
        body.with-sidebar.sidebar-collapsed .sidebar .brand-info,
        body.with-sidebar.sidebar-collapsed .sidebar .brand-text,
        body.with-sidebar.sidebar-collapsed .sidebar .brand-sub {
            display: none !important;
        }

        /* Ensure nav link text is hidden and icons are perfectly centered in collapsed state */
        body.with-sidebar.sidebar-collapsed .sidebar .nav-link span,
        body.with-sidebar.sidebar-collapsed .sidebar .nav-link .nav-label {
            display: none !important;
            width: 0 !important;
            opacity: 0 !important;
        }

        body.with-sidebar.sidebar-collapsed .sidebar .nav-link {
            justify-content: center !important;
            padding-top: .5rem !important;
            padding-bottom: .5rem !important;
            padding-left: 0 !important;
            padding-right: 0 !important;
        }

        body.with-sidebar.sidebar-collapsed .sidebar .nav-link i {
            margin: 0 auto !important;
            display: inline-block !important;
            transform: none !important;
            left: auto !important;
        }

        /* Remove browser/blue focus ring on nav links and use a very subtle visible focus state for keyboard users */
        .sidebar .nav-link:focus { outline: none !important; box-shadow: none !important; }
        .sidebar .nav-link:focus-visible { outline: 2px solid rgba(255,255,255,0.06) !important; outline-offset: 2px !important; }
    </style>

    
</head>

<body class="d-flex flex-column h-100 modern-layout with-sidebar topbar-fixed  ">
    <!-- Global Top Bar (search + user) -->
    <div class="topbar glass navbar-glass d-flex align-items-center gap-2 px-3 py-2 shadow-sm" role="banner">
        <div class="d-flex align-items-center gap-2 flex-shrink-0">
            <button id="sidebarToggle" class="btn btn-outline-primary btn-sm rounded-pill-soft" aria-label="Toggle navigation"><i class="fas fa-bars"></i></button>
        </div>
        
        <!-- User dropdown and notifications -->
        <div class="ms-auto d-flex align-items-center flex-shrink-0 navbar-actions">
            
            <a href="/auth/login" class="btn btn-primary btn-sm">Login</a>
            
        </div>
    </div>

    <!-- Sidebar -->
    <aside id="appSidebar" class="sidebar glass" role="navigation" aria-label="Main sidebar">
        <div class="sidebar-header d-flex align-items-center justify-content-between">
            <a class="brand d-flex align-items-center text-decoration-none" href="/">
                <div class="brand-logo d-flex align-items-center justify-content-center me-2" role="img" aria-label="ObsidianScout logo" tabindex="0">
                    <!-- Use the same image thatâ€™s used for the favicon/tab icon -->
                    <img src="/static/obsidian-192.png" class="brand-svg" aria-hidden="true" alt="">
                </div>
                <div class="brand-info d-flex flex-column">
                    <span class="brand-text fw-bold"><span class="obsidian-gradient">Obsidian</span>Scout</span>
                    <small class="brand-sub text-muted">Modern FRC Scouting</small>
                </div>
            </a>
            <button id="sidebarClose" class="btn btn-outline-secondary btn-close-sidebar text-muted d-lg-none" aria-label="Close sidebar">
                <i class="fas fa-times" aria-hidden="true"></i>
                <span class="visually-hidden">Close sidebar</span>
            </button>
        </div>
    
        <nav class="sidebar-nav flex-grow-1" aria-label="Main navigation">
            
        </nav>
        
    </aside>

    <script>
    // Sidebar toggle logic (mobile overlay + desktop collapse)
    (function(){
        const sidebar = document.getElementById('appSidebar');
        const toggle = document.getElementById('sidebarToggle');
        const closeBtn = document.getElementById('sidebarClose');
        const body = document.body;
        let _scrollPosition = 0;

        // Use an overlay to absorb touch/scroll events when sidebar is open on mobile.
        // This avoids fixing body position which on some devices can clip fixed children.
            function lockBodyScroll(){
                _scrollPosition = window.scrollY || document.documentElement.scrollTop || 0;

                // Prevent background scrolling while sidebar is open
                document.documentElement.style.overflow = 'hidden';
                document.body.style.overflow = 'hidden';

                // Add a transparent overlay that captures touch and click events outside the sidebar
                let overlay = document.getElementById('sidebarBackdropOverlay');
                if(!overlay){
                    overlay = document.createElement('div');
                    overlay.id = 'sidebarBackdropOverlay';
                    overlay.style.position = 'fixed';
                    overlay.style.inset = '0';
                    overlay.style.zIndex = '1035';
                    overlay.style.background = 'transparent';
                    overlay.style.touchAction = 'none';
                    overlay.addEventListener('touchmove', function(e){ e.preventDefault(); }, { passive: false });
                    overlay.addEventListener('click', function(){ closeSidebar(); });
                    document.body.appendChild(overlay);
                }

                // Ensure sidebar can scroll smoothly on iOS
                if(sidebar) {
                    sidebar.style['-webkit-overflow-scrolling'] = 'touch';
                }
            }
        function unlockBodyScroll(){
                const overlay = document.getElementById('sidebarBackdropOverlay');
                if(overlay && overlay.parentNode) overlay.parentNode.removeChild(overlay);

                document.documentElement.style.overflow = '';
                document.body.style.overflow = '';
                // Restore scroll position (use safe helper to cooperate with stabilizer)
                try {
                    if (typeof window.safeRestoreScroll === 'function') {
                        window.safeRestoreScroll(_scrollPosition || 0, { behavior: 'auto', timeout: 350 });
                    } else {
                        try { if (window.safeRestoreScroll && typeof window.safeRestoreScroll === 'function') { window.safeRestoreScroll(_scrollPosition || 0, { behavior: 'auto', timeout: 300 }); } else { window.scrollTo(0, _scrollPosition || 0); } } catch(e) {}
                    }
                } catch (e) { /* ignore */ }
            }

        // Sidebar open/close with localStorage persistence for desktop
        const SIDEBAR_STORAGE_KEY = 'obsidian_sidebar_collapsed';

        function isDesktop() { return window.innerWidth >= 992; }

        function setSidebarCollapsed(collapsed) {
            if (collapsed) {
                document.body.classList.add('sidebar-collapsed');
            } else {
                document.body.classList.remove('sidebar-collapsed');
            }
            try { localStorage.setItem(SIDEBAR_STORAGE_KEY, collapsed ? '1' : '0'); } catch(e){}

            // Notify other parts of the UI and force layout recalculation.
            try { document.dispatchEvent(new CustomEvent('obsidian:sidebar:toggled')); } catch (e) {}

            // Attempt immediate recalculation (RAF) and trigger a resize event so
            // third-party widgets that listen for resize update their layout.
            try {
                window.requestAnimationFrame(function(){
                    try { if (window.applySidebarMargin) window.applySidebarMargin(); } catch(e){}
                    try { window.dispatchEvent(new Event('resize')); } catch(e){}
                });
                // Fallback after transition end
                window.setTimeout(function(){ try { if (window.applySidebarMargin) window.applySidebarMargin(); window.dispatchEvent(new Event('resize')); } catch(e){} }, 360);
            } catch (e) { /* ignore */ }
        }

        function getStoredSidebarCollapsed() {
            try { return localStorage.getItem(SIDEBAR_STORAGE_KEY) === '1'; } catch(e){ return null; }
        }

        function openSidebar(){
            if(!isDesktop()){
                sidebar.classList.add('open');
                body.classList.add('sidebar-open');
                lockBodyScroll();
                try {
                    document.dispatchEvent(new CustomEvent('obsidian:sidebar:toggled'));
                    window.requestAnimationFrame(function(){ try{ if(window.applySidebarMargin) window.applySidebarMargin(); window.dispatchEvent(new Event('resize')); }catch(e){} });
                    window.setTimeout(function(){ try{ if(window.applySidebarMargin) window.applySidebarMargin(); window.dispatchEvent(new Event('resize')); }catch(e){} }, 360);
                } catch(e) {}
            } else {
                setSidebarCollapsed(false);
            }
            if(toggle) toggle.setAttribute('aria-expanded','true');
        }

        function closeSidebar(){
            if(!isDesktop()){
                sidebar.classList.remove('open');
                body.classList.remove('sidebar-open');
                try { unlockBodyScroll(); } catch(e){}
                try {
                    document.dispatchEvent(new CustomEvent('obsidian:sidebar:toggled'));
                    window.requestAnimationFrame(function(){ try{ if(window.applySidebarMargin) window.applySidebarMargin(); window.dispatchEvent(new Event('resize')); }catch(e){} });
                    window.setTimeout(function(){ try{ if(window.applySidebarMargin) window.applySidebarMargin(); window.dispatchEvent(new Event('resize')); }catch(e){} }, 360);
                } catch(e) {}
            } else {
                setSidebarCollapsed(true);
            }
            if(toggle) toggle.setAttribute('aria-expanded','false');
        }

        function toggleSidebar(){
            if(!isDesktop()){
                if(sidebar.classList.contains('open')){ closeSidebar(); } else { openSidebar(); }
            } else {
                // desktop: toggle collapse state
                const collapsed = document.body.classList.contains('sidebar-collapsed');
                setSidebarCollapsed(!collapsed);
            }
        }

        if(toggle){
            toggle.setAttribute('aria-controls','appSidebar');
            toggle.setAttribute('aria-expanded','true');
            toggle.addEventListener('click', (e)=>{ e.preventDefault(); toggleSidebar(); });
        }

        // Apply stored state on load (desktop only)
        (function applyStoredSidebarState(){
            const stored = getStoredSidebarCollapsed();
            if (stored === null) return; // no preference stored
            if (isDesktop()) {
                setSidebarCollapsed(stored);
            } else {
                // if mobile, ensure collapsed flag is reflected but don't force open/close overlay
                if (stored) document.body.classList.add('sidebar-collapsed');
            }
        })();

        if(closeBtn){ closeBtn.addEventListener('click', (e)=>{ e.preventDefault(); closeSidebar(); }); }

        // Nav link click (mobile)
        if (sidebar) {
            sidebar.querySelectorAll('a.nav-link').forEach(a=>{
                a.addEventListener('click', ()=>{ if(window.innerWidth < 992) closeSidebar(); });
            });
        }

        // Outside click (mobile)
        document.addEventListener('click', (e)=>{
            if(window.innerWidth >= 992) return;
            if(!sidebar.contains(e.target) && !(toggle && toggle.contains(e.target))) closeSidebar();
        });

        // Esc key
        document.addEventListener('keydown', (e)=>{ if(e.key==='Escape'){ if(window.innerWidth < 992 && sidebar.classList.contains('open')) closeSidebar(); }});

        // Initialize desktop state: respect stored preference if present
        if (window.innerWidth >= 992) {
            try {
                const stored = getStoredSidebarCollapsed();
                if (stored === null) {
                    // No preference stored: default to expanded
                    body.classList.remove('sidebar-collapsed');
                } else {
                    // Apply stored preference
                    setSidebarCollapsed(stored);
                }
            } catch (e) {
                // Fallback: ensure sidebar is expanded
                body.classList.remove('sidebar-collapsed');
            }
        }

        window.addEventListener('resize', ()=>{
            if(window.innerWidth >= 992){
                sidebar.classList.remove('open');
                body.classList.remove('sidebar-open');
                try { unlockBodyScroll(); } catch(e){}
            } else {
                body.classList.remove('sidebar-collapsed');
            }
        });

        // Re-apply stored sidebar state when resizing across breakpoint
        let lastWasDesktop = window.innerWidth >= 992;
        window.addEventListener('resize', function() {
            const nowDesktop = window.innerWidth >= 992;
            if (nowDesktop !== lastWasDesktop) {
                // crossed breakpoint
                const stored = getStoredSidebarCollapsed();
                if (stored !== null) {
                    if (nowDesktop) setSidebarCollapsed(stored);
                    else document.body.classList.remove('sidebar-collapsed');
                }
            }
            lastWasDesktop = nowDesktop;
        });

        // Safety: Ensure the sidebar remains scrollable on desktop. In some
        // edge cases (for example after an overlay was added on mobile or if
        // an exception prevented cleanup) the global overflow style can be
        // left set to 'hidden', which hides scrollbars and prevents reaching
        // footer controls. Clear any stale overflow and remove leftover
        // mobile overlay when on desktop viewports.
        (function ensureSidebarScrollOnDesktop(){
            function ensure(){
                try {
                    if (window.innerWidth >= 992) {
                        // Remove any accidental global overflow that prevents page or
                        // sidebar scrolling.
                        if (document.documentElement.style.overflow === 'hidden' || document.body.style.overflow === 'hidden'){
                            document.documentElement.style.overflow = '';
                            document.body.style.overflow = '';
                        }
                        // Remove the mobile backdrop overlay if it was left behind
                        var overlay = document.getElementById('sidebarBackdropOverlay');
                        if (overlay && overlay.parentNode) overlay.parentNode.removeChild(overlay);
                        // Ensure sidebar has native scrolling enabled
                        var sb = document.getElementById('appSidebar');
                        if (sb) sb.style.overflowY = 'auto';
                    }
                } catch(e){ /* non-fatal */ }
            }
            if (document.readyState === 'loading') document.addEventListener('DOMContentLoaded', ensure); else ensure();
            window.addEventListener('resize', function(){ try{ ensure(); } catch(e){} });
        })();

        // Avoid repositioning fixed dropdowns while page scrolls; only reposition if user opens a dropdown or resizes
        let lastScrollY = window.scrollY;
        window.addEventListener('scroll', function() {
            // If any topbar dropdown menu is positioned fixed, don't adjust its position on scroll
            const fixedMenus = document.querySelectorAll('.topbar .dropdown-menu');
            let hasFixed = false;
            fixedMenus.forEach(menu => {
                if (getComputedStyle(menu).position === 'fixed' && menu.classList.contains('show')) hasFixed = true;
            });
            if (hasFixed) {
                // nothing to do while scrolling
                lastScrollY = window.scrollY;
                return;
            }

            // If no fixed menus, allow repositioning logic for dropdowns that rely on normal flow
            // (for example on desktop navbar dropdowns not positioned fixed)
            lastScrollY = window.scrollY;
        });
    })();
    </script>
    <script>
    // Populate data-label attributes on sidebar nav links for collapsed hover tooltips
    (function(){
        const sidebar = document.getElementById('appSidebar');
        function setNavLabels(){
            if(!sidebar) return;
            const links = sidebar.querySelectorAll('a.nav-link');
            links.forEach(a=>{
                const label = a.querySelector('span') ? a.querySelector('span').textContent.trim() : a.textContent.trim();
                if(label) a.setAttribute('data-label', label);
            });
        }
        setNavLabels();
        // Update labels if window resizes or user toggles sidebar
        window.addEventListener('resize', setNavLabels);
        document.addEventListener('obsidian:sidebar:toggled', setNavLabels);
        // Also hook into existing toggle button to dispatch an event for other listeners
        const toggle = document.getElementById('sidebarToggle');
        if(toggle) toggle.addEventListener('click', ()=>{ setTimeout(()=>{ document.dispatchEvent(new CustomEvent('obsidian:sidebar:toggled')); }, 250); });
    })();
    </script>
    <style>
    /* Tooltip-like labels when sidebar is collapsed (lightweight, non-JS fallback via title is also applied) */
    .sidebar-collapsed .sidebar-nav a.nav-link {
        position: relative;
        padding-left: 0.75rem; /* compact spacing when collapsed */
    }
    .sidebar-collapsed .sidebar-nav a.nav-link::after {
        content: attr(data-label);
        position: absolute;
        left: 100%;
        margin-left: 8px;
        top: 50%;
        transform: translateY(-50%);
        background: var(--bs-body-bg);
        border: 1px solid var(--bs-border-color);
        padding: 6px 8px;
        border-radius: 6px;
        white-space: nowrap;
        box-shadow: 0 2px 8px rgba(0,0,0,0.12);
        display: none;
        z-index: 2000;
        font-size: 0.85rem;
    }
    .sidebar-collapsed .sidebar-nav a.nav-link:hover::after,
    .sidebar-collapsed .sidebar-nav a.nav-link:focus::after {
        display: block;
    }
    /* Slightly emphasize active link for better contrast */
    .sidebar .nav-link.active {
        background: linear-gradient(90deg, rgba(var(--bs-primary-rgb),0.06), transparent);
        border-radius: 6px;
    }

    /* Help icon styling (small question-mark icon used site-wide for contextual help) */
    .help-icon {
        color: var(--bs-primary);
        cursor: pointer;
        display: inline-flex;
        align-items: center;
        justify-content: center;
        font-size: 0.95rem;
        line-height: 1;
    }
    .help-icon:focus { outline: none; box-shadow: 0 0 0 3px rgba(var(--bs-primary-rgb),0.12); border-radius: 6px; }
    .help-icon .fa-question-circle { font-size: 0.95rem; }

    /* When users choose to hide inline help icons, toggle this class on the <html> or <body> element */
    .hide-help-icons .help-icon { display: none !important; }

    </style>

    <!-- Apply show_help_icons preference as early as possible so hiding is effective site-wide -->
    <script>(function(){try{var v=localStorage.getItem('show_help_icons'); if(v === 'false'){ document.documentElement.classList.add('hide-help-icons'); document.body.classList.add('hide-help-icons'); } }catch(e){/* ignore */}})();</script>

    <script>
    // Accessibility helpers for sidebar: set aria-current on active links,
    // provide title attributes and keep the toggle button's pressed state in sync.
    document.addEventListener('DOMContentLoaded', function(){
        const sidebar = document.getElementById('appSidebar');
        const toggle = document.getElementById('sidebarToggle');

        function refreshSidebarA11y(){
            if(!sidebar) return;
            const collapsed = document.body.classList.contains('sidebar-collapsed');

            // Update toggle pressed/expanded states
            if(toggle){
                try{ toggle.setAttribute('aria-pressed', collapsed ? 'true' : 'false'); }catch(e){}
                try{ toggle.setAttribute('aria-expanded', (!collapsed && window.innerWidth >= 992) ? 'true' : 'false'); }catch(e){}
            }

            // Update links: aria-current for screen readers and title for hover fallback
            sidebar.querySelectorAll('a.nav-link').forEach(a=>{
                if(a.classList.contains('active')){
                    a.setAttribute('aria-current','page');
                } else {
                    a.removeAttribute('aria-current');
                }
                // Keep a pragmatic title attribute so tooltip works on platforms without CSS support
                const lbl = a.getAttribute('data-label');
                if(lbl) a.setAttribute('title', lbl);
            });
        }

        refreshSidebarA11y();
        document.addEventListener('obsidian:sidebar:toggled', refreshSidebarA11y);
        window.addEventListener('resize', refreshSidebarA11y);
    });
    </script>
    <script>
    // Sidebar nav-group collapse/expand behavior with simple persistence
    (function(){
        const GROUP_KEY = 'obsidian_sidebar_groups';
        function loadState(){ try{ const v = localStorage.getItem(GROUP_KEY); return v ? JSON.parse(v) : {}; }catch(e){ return {}; } }
        function saveState(state){ try{ localStorage.setItem(GROUP_KEY, JSON.stringify(state)); }catch(e){} }

        const state = loadState();
        document.querySelectorAll('.btn-toggle[data-group]').forEach(btn=>{
            const group = btn.getAttribute('data-group');
            const items = document.getElementById(group + '-items');
            if(!items) return;
            // initialize from state
            const open = (state[group] === undefined) ? true : !!state[group];
            btn.setAttribute('aria-expanded', open? 'true' : 'false');
            if(!open) items.classList.add('collapsed');

            btn.addEventListener('click', ()=>{
                const expanded = btn.getAttribute('aria-expanded') === 'true';
                btn.setAttribute('aria-expanded', expanded ? 'false' : 'true');
                items.classList.toggle('collapsed');
                state[group] = !expanded;
                saveState(state);
            });

            // keyboard accessibility: toggle on Enter/Space
            btn.addEventListener('keydown', (e)=>{
                if(e.key === 'Enter' || e.key === ' ') { e.preventDefault(); btn.click(); }
            });
        });
    })();
    </script>
    
    



    
    


    
    


    
    

    <div class="toast-container position-fixed top-0 end-0 p-3">
        
            
        
    </div>

    <script>
    // Initialize site-wide popovers used by help icons (hover on desktop, tap/click usable on mobile)
    document.addEventListener('DOMContentLoaded', function(){
        try {
            const popTriggers = [].slice.call(document.querySelectorAll('[data-bs-toggle="popover"]'));
            popTriggers.forEach(function(el){
                // Avoid double-init
                if (el._bsPopover) return;
                const trigger = el.getAttribute('data-bs-trigger') || 'hover focus click';
                try { new bootstrap.Popover(el, { trigger: trigger, html: true, sanitize: true, container: 'body', boundary: 'viewport' }); } catch(e) { /* non-fatal */ }
            });
        } catch(e) { /* ignore */ }
    });
    </script>

    

    <main class="flex-shrink-0 py-4">
        <div class="container">
            
<div class="row">
    <div class="col-md-12">
    <!-- Team and Match Selection -->
    <div class="card mb-4 navbar-glass">
            <div class="card-header bg-primary text-white">
                <h5 class="mb-0">Select Team and Match</h5>
            </div>
            <div class="card-body">
                <form id="team-match-form" aria-label="Team and Match selection">
                    <div class="row">
                        <div class="col-md-6 mb-2">
                            <label for="match-selector" class="form-label">Select Match</label>
                            <!-- Search input for matches -->
                            <div class="input-group mb-1">
                                <span class="input-group-text"><i class="fas fa-search"></i></span>
                                <input type="search" id="match-search" class="form-control form-control-sm" placeholder="Search matches by type or number" aria-label="Search matches">
                            </div>
                            <select class="form-select" id="match-selector" name="match_id" required aria-required="true" aria-label="Match selector">
                                <option value="">-- Select Match --</option>
                                
                            </select>
                            <!-- Match navigation (+ / -) -->
                            <div class="mt-2 d-flex gap-2" aria-hidden="false">
                                <button type="button" id="match-decrement" class="btn btn-outline-secondary btn-sm" title="Previous match" aria-label="Previous match">&minus;</button>
                                <button type="button" id="match-increment" class="btn btn-outline-secondary btn-sm" title="Next match" aria-label="Next match">+</button>
                            </div>
                        </div>
                        <div class="col-md-6 mb-2">
                            <label for="team-selector" class="form-label">Select Team</label>
                            <!-- Search input for teams -->
                            <div class="input-group mb-1">
                                <span class="input-group-text"><i class="fas fa-search"></i></span>
                                <input type="search" id="team-search" class="form-control form-control-sm" placeholder="Search teams by number or name" aria-label="Search teams">
                            </div>
                            <select class="form-select" id="team-selector" name="team_id" required aria-label="Team selector">
                                <option value="">-- Select Team --</option>
                                
                            </select>
                        </div>
                        <!-- Quick prediction UI removed -->
                    </div>
                </form>
            </div>
        </div>

        <!-- Form Content Container -->
        <div id="form-content">
            
            <!-- Empty Form State -->
            <div class="alert alert-info text-center py-4">
                <i class="fas fa-info-circle fa-3x mb-3"></i>
                <h4>Please select a team and match above</h4>
                <p class="mb-0">The form will automatically update when both are selected.</p>
            </div>
            
        </div>
    </div>
</div>

<!-- QR Code Container (initially hidden) -->
<div class="modal fade" id="qrModal" tabindex="-1" aria-hidden="true">
    <div class="modal-dialog modal-dialog-centered modal-fullscreen-sm-down">
        <div class="modal-content">
            <div class="modal-header">
                <h5 class="modal-title">
                    <i class="fas fa-qrcode me-2"></i> QR Code for Match Data
                </h5>
                <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
            </div>
            <div class="modal-body qr-modal-body">
                <div class="qr-container">
                    <div id="qrcode"></div>
                    <div id="qrDownloadContainer" class="text-center d-none">
                        <button type="button" class="btn btn-primary">
                            <i class="fas fa-download me-2"></i> Download QR Code
                        </button>
                    </div>
                </div>
            </div>
        </div>
    </div>
</div>

<!-- Status Toast Container -->
<div class="toast-container position-fixed bottom-0 end-0 p-3">
  <!-- Toasts will be inserted here dynamically -->
</div>

        </div>
    </main>

    <footer class="footer mt-auto py-3">
        <div class="container">
            <div class="row align-items-center g-2">
                
                <div class="col-md-6 text-center text-md-start">
                    <div class="d-flex align-items-center justify-content-center justify-content-md-start">
                        <img src="/static/obsidian-192.png" class="brand-svg me-2 text-primary" aria-hidden="true" alt="" style="width:24px;height:24px;">
                        <span class="fw-bold">ObsidianScout</span>
                        
                        
                        <span class="text-muted mx-2">â€¢</span>
                        <span class="small text-muted">ObsidianScout</span>
                        
                    </div>
                </div>

                
                <div class="col-md-6 text-center text-md-end">
                    <div class="small text-muted">
                        
                        <span>No active configuration</span>
                        
                    </div>
                <!--<div class="mt-2">
                        <a href="https://www.paypal.com" target="_blank" rel="noopener" class="btn btn-sm btn-warning d-inline-flex align-items-center">
                            <i class="fas fa-heart me-1"></i> Donate(Not yet available)
                        </a>
                    </div> -->
                </div>
                
            </div>
        </div>
    </footer>

    <div id="loading-overlay" class="d-none">
        <div class="spinner-container">
            <div class="spinner-border text-primary" role="status">
                <span class="visually-hidden">Loading...</span>
            </div>
            <div class="mt-2">Loading...</div>
        </div>
    </div>

    <script src="/static/js/vendor/jquery-3.7.1.min.js"></script>
    <script>
        // Enhanced jQuery loading check with timeout
        (function() {
            let retryCount = 0;
            const maxRetries = 5;
            const checkInterval = 100; // 100ms
            
            function checkJQuery() {
                if (typeof jQuery !== 'undefined' && typeof $ !== 'undefined') {
                    console.log('jQuery loaded successfully');
                    return true;
                }
                
                retryCount++;
                if (retryCount < maxRetries) {
                    setTimeout(checkJQuery, checkInterval);
                } else {
                    // Final fallback - load jQuery synchronously
                    console.warn('jQuery failed to load from CDNs, loading local fallback');
                    const script = document.createElement('script');
                    // Fallback now points to local vendor file for offline use
                    script.src = '/static/js/vendor/jquery-3.7.1.min.js';
                    script.integrity = 'sha384-1H217gwSVyLSIfaLxHbE7dRb3v4mYCKbpQvzx0cegeju1MVsGrX5xXxAvs/HgeFs';
                    script.crossOrigin = 'anonymous';
                    document.head.appendChild(script);
                    
                    script.onload = function() {
                        console.log('jQuery loaded from fallback CDN');
                    };
                    
                    script.onerror = function() {
                        console.error('All jQuery CDNs failed to load');
                        alert('jQuery failed to load from all sources. Please check your internet connection and refresh the page.');
                    };
                }
                return false;
            }
            
            // Start checking after a short delay
            setTimeout(checkJQuery, 50);
        })();
    </script>
    
    <script src="/static/js/vendor/bootstrap.bundle.min.js"></script>
    
    <script src="/static/js/vendor/select2.min.js"></script>
    
    <script src="/static/js/select2-mobile-fix.js"></script>
    
    <script src="/static/js/vendor/plotly-latest.min.js"></script>
    
    <script src="/static/js/vendor/socket.io.js"></script>
    
    <script src="/static/js/qrcode.min.js"></script>
    
    <!-- Gentle Mobile Scroll Protection -->
    <script>
    (function() {
        'use strict';
        
    // Treat narrow screens and tall portrait screens (height > width and tall) as "mobile-like"
    const isMobile = window.innerWidth <= 768 || /Android|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
    const isPortraitTall = (window.innerHeight > window.innerWidth) && (window.innerHeight >= 900);

    // If not mobile and not a tall portrait device, skip this gentle protection.
    if (!isMobile && !isPortraitTall) return;
        
        console.log('Gentle mobile scroll protection active');
        
        let isInteracting = false;
        let lastScrollY = 0;
        
        // Track scroll position when not interacting
        function updateScrollPosition() {
            if (!isInteracting) {
                lastScrollY = window.pageYOffset || document.documentElement.scrollTop || 0;
            }
        }
        
        // Gentle protection only for obvious scroll-to-top jumps
        function preventScrollToTop() {
            const currentScrollY = window.pageYOffset || document.documentElement.scrollTop || 0;
            
            // Only intervene if scroll jumped to exactly 0 from a significant position
            if (currentScrollY === 0 && lastScrollY > 100) {
                console.log('Preventing scroll-to-top jump');
                // Use smooth scroll to restore position
                window.scrollTo({
                    top: lastScrollY,
                    behavior: 'smooth'
                });
            }
        }
        
        // Very gentle click protection
        function handleInteraction(e) {
            // Only protect problematic elements
            const problematic = e.target.matches('a[href="#"], a[href=""], button[type="button"]:not([data-bs-toggle])');
            
            if (problematic) {
                isInteracting = true;
                
                // Single check after a short delay
                setTimeout(() => {
                    preventScrollToTop();
                    isInteracting = false;
                    updateScrollPosition();
                }, 50);
            }
        }
        
        // Add minimal event listeners
        document.addEventListener('click', handleInteraction, { passive: true });
        window.addEventListener('scroll', updateScrollPosition, { passive: true });
        
        // Initialize
        updateScrollPosition();
        
    })();
    </script>
    
    <script src="/static/js/scripts.js"></script>
    <script src="/static/js/topbar-notifications.js"></script>
    
    <script>
        document.addEventListener('DOMContentLoaded', function() {
            // Global helper: perform a scroll restore while cooperating with the
            // mobile viewport stabilizer. This sets the stabilizer suppression
            // flag briefly so the stabilizer doesn't fight legitimate restores.
            window.safeRestoreScroll = function(y, opts) {
                try { if (!opts) opts = {}; } catch(e) { opts = {}; }
                try { window.__suppressMobileScrollJumps = true; } catch (e) {}
                const behavior = opts.behavior || 'auto';
                // Use requestAnimationFrame so layout has settled before scrolling
                window.requestAnimationFrame(() => {
                    try {
                        window.scrollTo({ top: (y || 0), behavior: behavior });
                    } catch (err) {
                        try { if (window.safeRestoreScroll && typeof window.safeRestoreScroll === 'function') { window.safeRestoreScroll((y || 0), { behavior: 'auto', timeout: 350 }); } else { window.scrollTo(0, (y || 0)); } } catch(e) {}
                    }
                    // Remove suppression after a short timeout; caller may override
                    setTimeout(() => { try { window.__suppressMobileScrollJumps = false; } catch(e) {} }, opts.timeout || 350);
                });
            };
            
            // Initialize mobile protection (guard in case the function isn't present)
            if (typeof initializeMobileScrollProtection === 'function') {
                initializeMobileScrollProtection();
            }
            
            // ===============================
            // GLOBAL SELECT2 MOBILE ENHANCEMENT
            // ===============================
            
            // Apply mobile fixes to any existing Select2 dropdowns
            setTimeout(() => {
                if (typeof window.initSelect2Mobile === 'function') {
                    // Re-initialize any existing Select2 instances with mobile fixes
                    $('.select2-hidden-accessible').each(function() {
                        const $this = $(this);
                        const currentOptions = $this.data('select2') ? $this.data('select2').options.options : {};
                        
                        // Get existing configuration
                        const existingConfig = {
                            placeholder: currentOptions.placeholder || 'Select...',
                            allowClear: currentOptions.allowClear || false,
                            closeOnSelect: currentOptions.closeOnSelect !== false,
                            theme: currentOptions.theme || 'bootstrap-5',
                            width: currentOptions.width || '100%'
                        };
                        
                        // Only re-initialize if on mobile and not already mobile-enhanced
                        if (window.innerWidth <= 900 && !$this.hasClass('mobile-enhanced')) {
                            try {
                                $this.addClass('mobile-enhanced');
                                window.initSelect2Mobile($this, existingConfig);
                                console.log('Enhanced Select2 dropdown for mobile:', $this.attr('id') || $this.attr('name'));
                            } catch (e) {
                                console.warn('Failed to enhance Select2 for mobile:', e);
                            }
                        }
                    });
                }
            }, 200);
            
            // Dark mode button logic
            const darkModeBtn = document.getElementById('darkModeButton');
            const body = document.body;
            const prefersDarkMode = window.matchMedia('(prefers-color-scheme: dark)').matches;
            const storedPreference = localStorage.getItem('darkMode');
            const darkModeIcon = document.getElementById('darkModeIcon');
            const darkModeLabel = document.getElementById('darkModeLabel');
            const isDarkMode = storedPreference !== null ? storedPreference === 'true' : prefersDarkMode;
            function applyState(on){
                try {
                    const htmlEl = document.documentElement;
                    if (on) {
                        body.classList.add('dark-mode');
                        htmlEl.classList.add('dark-mode');
                        if(darkModeIcon){darkModeIcon.classList.remove('fa-moon');darkModeIcon.classList.add('fa-sun');}
                        if(darkModeLabel){darkModeLabel.textContent='Light Mode';}
                    } else {
                        body.classList.remove('dark-mode');
                        htmlEl.classList.remove('dark-mode');
                        if(darkModeIcon){darkModeIcon.classList.remove('fa-sun');darkModeIcon.classList.add('fa-moon');}
                        if(darkModeLabel){darkModeLabel.textContent='Dark Mode';}
                    }
                } catch (e) {
                    // Keep this non-fatal - don't block page if DOM is unusual
                    try { if (on) body.classList.add('dark-mode'); else body.classList.remove('dark-mode'); } catch(e2){}
                }
            }
            applyState(isDarkMode);

            // Apply rounded UI preference
            try {
                const roundedStored = localStorage.getItem('rounded_ui');
                const isRounded = roundedStored !== null ? roundedStored === 'true' : false; // default to disabled
                if (isRounded) { document.body.classList.add('rounded-ui'); document.documentElement.classList.add('rounded-ui'); }
                else { document.body.classList.remove('rounded-ui'); document.documentElement.classList.remove('rounded-ui'); }
            } catch(e) { /* ignore */ }
            // Also apply navbar theme stored preference
            try{
                const navbarStored = localStorage.getItem('navbar_theme');
                const navVal = navbarStored !== null ? navbarStored : 'neutral';
                document.body.classList.remove('nav-theme-primary','nav-theme-neutral','nav-theme-indigo','nav-theme-green');
                document.documentElement.classList.remove('nav-theme-primary','nav-theme-neutral','nav-theme-indigo','nav-theme-green');
                document.body.classList.add('nav-theme-' + navVal);
                document.documentElement.classList.add('nav-theme-' + navVal);
            }catch(e){}
            
            // Server-side theme management was removed; rely on client preference (localStorage) only.
            
            if(darkModeBtn){
                darkModeBtn.addEventListener('click', ()=>{
                    const now = !body.classList.contains('dark-mode');
                    localStorage.setItem('darkMode', now ? 'true':'false');
                    // Keep both html and body in sync so early loaded scripts and observers react
                    try { if (now) { document.documentElement.classList.add('dark-mode'); } else { document.documentElement.classList.remove('dark-mode'); } } catch(e) {}
                    applyState(now);

                    // Persist only locally; no server-side theme endpoints are available.
                });
            }
            // System preference changes only if user hasn't chosen
            window.matchMedia('(prefers-color-scheme: dark)').addEventListener('change', e => {
                if (localStorage.getItem('darkMode') === null) {
                    applyState(e.matches);
                }
            });

            // Keep liquid glass per-user preference in sync across tabs
            window.addEventListener('storage', function(e){
                try {
                    if (e.key !== 'liquid_glass_buttons') return;
                    if (e.newValue === 'true') {
                        document.documentElement.classList.add('liquid-glass-buttons');
                        document.body.classList.add('liquid-glass-buttons');
                        return;
                    }
                    if (e.newValue === 'false') {
                        document.documentElement.classList.remove('liquid-glass-buttons');
                        document.body.classList.remove('liquid-glass-buttons');
                        return;
                    }
                    // e.newValue === null (preference removed): fall back to server default
                    var serverAllowsFallback = (window.__server_liquid_glass_allowed === true || window.__server_liquid_glass_allowed === 'true');
                    if (!serverAllowsFallback) {
                        document.documentElement.classList.remove('liquid-glass-buttons');
                        document.body.classList.remove('liquid-glass-buttons');
                    }
                } catch (err) { /* ignore storage sync errors */ }
            });
            
            // Initialize toasts
            var toastElList = document.querySelectorAll('.toast');
            Array.from(toastElList).map(function (toastEl) {
                return new bootstrap.Toast(toastEl, {
                    autohide: true,
                    delay: 5000
                });
            });
        });
    </script>
    
    <!-- Dark mode handlers -->
    <script src="/static/js/dark-mode-handlers.js"></script>
    
    <!-- Team-number display preference helper (client-side, per-user) -->
    <script>
    (function(){
        // Expose a global helper to apply the user's display preference.
        // Preference key: 'display_offseason_preference' -> '99xx' | 'letter'
        // Enhancements:
        // - Cache remap per-session
        // - Immediately apply numeric->numeric restore without needing fetch
        // - Observe DOM mutations so dynamically inserted elements are handled
        // - Provide a setter helper to change the preference and apply immediately

        window._teamRemapCache = window._teamRemapCache || {};

        async function fetchRemap(eventKey){
            if(!eventKey) return {};
            if(window._teamRemapCache[eventKey]) return window._teamRemapCache[eventKey];
            try{
                // Normalize to a TBA event key (year + code) if caller passed only an event code
                let tbaKey = String(eventKey || '').trim();
                if(!/^\d{4}/.test(tbaKey)){
                    // Try to get year from GAME_CONFIG (season or year), otherwise use current year
                    const year = (window.GAME_CONFIG && (window.GAME_CONFIG.season || window.GAME_CONFIG.year)) ? (window.GAME_CONFIG.season || window.GAME_CONFIG.year) : (new Date()).getFullYear();
                    tbaKey = String(year) + tbaKey.toLowerCase();
                }

                // Try localStorage first (persisted remaps)
                try{
                    const lsKey = 'team_remap_' + tbaKey;
                    const rawLs = localStorage.getItem(lsKey);
                    if(rawLs){
                        try{
                            const parsed = JSON.parse(rawLs);
                            if(parsed && typeof parsed === 'object'){
                                window._teamRemapCache[eventKey] = parsed;
                                if(tbaKey !== eventKey) window._teamRemapCache[tbaKey] = parsed;
                                return parsed;
                            }
                        }catch(e){}
                    }
                }catch(e){}

                const resp = await fetch('/api/event-remap/' + encodeURIComponent(tbaKey), { credentials: 'same-origin' });
                if(!resp.ok) return {};
                const data = await resp.json();
                const raw = (data && data.remap) ? data.remap : {};
                // Server returns mapping letter->numeric (e.g., {'581B': 9989}). Invert to numeric->letter for fast lookup.
                const map = {};
                try{
                    Object.keys(raw).forEach(k => {
                        try{
                            const v = raw[k];
                            if(v !== null && v !== undefined){
                                map[String(v)] = String(k).toUpperCase();
                            }
                        }catch(e){}
                    });
                }catch(e){}

                // Cache in-memory
                window._teamRemapCache[eventKey] = map;
                if(tbaKey !== eventKey) window._teamRemapCache[tbaKey] = map;
                // Persist to localStorage for offline/reload use
                try{
                    const lsKeyOut = 'team_remap_' + tbaKey;
                    localStorage.setItem(lsKeyOut, JSON.stringify(map));
                }catch(e){/* ignore storage errors */}
                return map;
            }catch(e){
                console.warn('fetchRemap failed', e);
                return {};
            }
        }

        async function applyPreferenceToElement(el, map, pref){
            try{
                const num = el.getAttribute('data-team-num') || (el.textContent && el.textContent.trim());
                if(!num) return;

                const key = String(num);
                const letter = (map && map[key]) ? map[key] : null;

                if(pref === 'letter'){
                    // show letter if available, else numeric
                    el.textContent = letter || num;
                    return;
                }

                if(pref === 'both'){
                    // show numeric and parenthesized letter if available
                    if(letter){
                        el.textContent = `${num} (${letter})`;
                    } else {
                        el.textContent = num;
                    }
                    return;
                }

                // default: '99xx' or unknown -> numeric only
                el.textContent = num;
            }catch(e){ /* ignore per-element errors */ }
        }

        async function applyTeamNumberDisplayPreferenceImpl(){
            try{
                let pref = '99xx';
                try{ pref = localStorage.getItem('display_offseason_preference') || '99xx'; }catch(e){ pref = '99xx'; }

                const eventKey = (window.GAME_CONFIG && window.GAME_CONFIG.current_event_code) ? window.GAME_CONFIG.current_event_code : null;
                let map = {};
                // fetch remap when user asked for letter-style or 'both' display
                if((pref === 'letter' || pref === 'both') && eventKey){
                    map = await fetchRemap(eventKey);
                }

                // Always update existing elements immediately
                const els = Array.from(document.querySelectorAll('.team-number'));
                // For each element, determine the eventKey (per-element overrides global)
                await Promise.all(els.map(async (el) => {
                    try{
                        // Only use an explicit per-element data-event-key; do NOT fall back to global eventKey.
                        const localEventKey = el.getAttribute('data-event-key') || null;
                        let localMap = {};
                        if((pref === 'letter' || pref === 'both') && localEventKey){
                            localMap = await fetchRemap(localEventKey);
                        }
                        await applyPreferenceToElement(el, localMap, pref);
                    }catch(e){ /* ignore per-element errors */ }
                }));

                // Update native <select> option labels for team-selects so pickers show the chosen format
                try{
                    const selects = Array.from(document.querySelectorAll('select'));
                    await Promise.all(selects.map(async (sel) => {
                        try{
                            // Determine if select looks like a team select: option dataset.teamNumber or select name/id
                            let looksLikeTeam = false;
                            for(let i=0;i<sel.options.length;i++){
                                const o = sel.options[i];
                                if(o && o.dataset && o.dataset.teamNumber){ looksLikeTeam = true; break; }
                            }
                            const nm = (sel.name||'').toLowerCase(); const id = (sel.id||'').toLowerCase();
                            if(!looksLikeTeam && !(nm.includes('team') || id.includes('team'))) return;

                            // Only use an explicit per-select data-event-key; do NOT fall back to global eventKey.
                            const localEventKey = sel.getAttribute('data-event-key') || null;
                            let localMap = {};
                            if((pref === 'letter' || pref === 'both') && localEventKey){
                                localMap = await fetchRemap(localEventKey);
                            }

                            // Update each option's visible text
                            for(let i=0;i<sel.options.length;i++){
                                try{
                                    const opt = sel.options[i];
                                    const num = opt.dataset && opt.dataset.teamNumber ? String(opt.dataset.teamNumber) : (opt.textContent||'').trim().split(' ')[0];
                                    const name = opt.dataset && opt.dataset.teamName ? opt.dataset.teamName : (opt.textContent||'').split('-').slice(1).join('-').trim();
                                    let letter = (localMap && localMap[num]) ? localMap[num] : null;
                                    // Only fall back to any cached remaps if we have an explicit event context
                                    // for this select/option (localEventKey). This prevents previously-fetched
                                    // remaps from leaking into unrelated team dropdowns on other pages.
                                    if(!letter && localEventKey){
                                        try{
                                            const cache = window._teamRemapCache || {};
                                            for(const k in cache){
                                                if(cache[k] && cache[k][num]){ letter = cache[k][num]; break; }
                                            }
                                        }catch(e){}
                                    }
                                    // Last-resort: check persisted localStorage remaps, but only when we
                                    // have localEventKey (avoid global leakage to unrelated dropdowns)
                                    if(!letter && localEventKey){
                                        try{
                                            for(let i=0;i<localStorage.length;i++){
                                                const key = localStorage.key(i);
                                                if(!key || !key.startsWith('team_remap_')) continue;
                                                try{
                                                    const parsed = JSON.parse(localStorage.getItem(key));
                                                    if(parsed && parsed[num]){ letter = parsed[num]; break; }
                                                }catch(e){}
                                            }
                                        }catch(e){}
                                    }

                                    if(pref === 'letter'){
                                        if(num){ opt.textContent = (letter || num) + (name ? (' - ' + name) : ''); }
                                        else { /* leave */ }
                                    } else if(pref === 'both'){
                                        if(num){ opt.textContent = num + (letter ? (' ('+letter+')') : '') + (name ? (' - ' + name) : ''); }
                                    } else {
                                        if(num){ opt.textContent = num + (name ? (' - ' + name) : ''); }
                                    }
                                }catch(e){}
                            }

                        }catch(e){}
                    }));
                }catch(e){/* ignore select label updates on old browsers */}
            }catch(e){ console.warn('applyTeamNumberDisplayPreference error', e); }
        }

        // Public API
        window.applyTeamNumberDisplayPreference = applyTeamNumberDisplayPreferenceImpl;

        // Setter to update preference and apply immediately without reload or resync
        window.setTeamNumberDisplayPreference = function(pref){
            try{
                // Accept explicit values: '99xx', 'letter', 'both'
                if(!['99xx','letter','both'].includes(pref)) pref = '99xx';
                localStorage.setItem('display_offseason_preference', pref);
                // apply locally immediately
                try{ if (typeof window.applyTeamNumberDisplayPreference === 'function') window.applyTeamNumberDisplayPreference(); } catch(e){}
                // Also broadcast storage event for other tabs
                try{ window.dispatchEvent(new StorageEvent('storage', { key: 'display_offseason_preference', newValue: pref })); } catch(e){ /* some browsers restrict constructing StorageEvent; fallback */
                    try{ localStorage.setItem('display_offseason_preference', pref); }catch(e){}
                }
            }catch(e){ console.warn('setTeamNumberDisplayPreference error', e); }
        };

        // Apply on DOM ready
        if(document.readyState === 'loading') document.addEventListener('DOMContentLoaded', function(){ window.applyTeamNumberDisplayPreference(); }); else window.applyTeamNumberDisplayPreference();

        // React to storage changes (other tabs)
        window.addEventListener('storage', function(e){
            if(e.key === 'display_offseason_preference') window.applyTeamNumberDisplayPreference();
        });

        // Observe DOM for new elements with class .team-number so dynamically added content updates
        const observer = new MutationObserver((mutations) => {
            let found = false;
            mutations.forEach(m => {
                m.addedNodes && m.addedNodes.forEach(node => {
                    if(node.nodeType !== 1) return;
                    if(node.classList && node.classList.contains('team-number')) found = true;
                    else if(node.querySelector && node.querySelector('.team-number')) found = true;
                });
            });
            if(found){
                // Re-apply; small debounce
                if(window._applyTeamNumberDebounce) clearTimeout(window._applyTeamNumberDebounce);
                window._applyTeamNumberDebounce = setTimeout(() => { try{ window.applyTeamNumberDisplayPreference(); }catch(e){} }, 60);
            }
        });
        try{ observer.observe(document.body, { childList: true, subtree: true }); }catch(e){ /* ignore if body not available */ }

    })();
    </script>

        <!-- Select mapping helper: add adjacent mapped display for native <select> elements with team options -->
        <script>
        (function(){
            // Debounce helper
            function debounce(fn, wait){ let t; return function(){ clearTimeout(t); t = setTimeout(() => fn.apply(this, arguments), wait); }; }

            function isTeamSelect(sel){
                try{
                    // Heuristic: any option with data-team-number attribute
                    for(let i=0;i<sel.options.length;i++){
                        if(sel.options[i].dataset && sel.options[i].dataset.teamNumber) return true;
                    }
                    // fallback: name or id contains 'team' or 'team_id'
                    const nm = (sel.name||'').toLowerCase();
                    const id = (sel.id||'').toLowerCase();
                    if(nm.includes('team') || id.includes('team')) return true;
                }catch(e){}
                return false;
            }

            function createOrGetMappedDisplay(sel){
                // Prefer a sibling element with class select-mapped-display
                let container = sel.parentNode;
                if(!container) return null;
                let span = container.querySelector('.select-mapped-display');
                if(span) return span;

                span = document.createElement('div');
                span.className = 'select-mapped-display team-number';
                // Keep it inline and visually adjacent by default; templates may override with CSS
                span.style.display = 'inline-block';
                span.style.marginLeft = '0.5rem';
                // Insert after the select
                if(sel.nextSibling) container.insertBefore(span, sel.nextSibling); else container.appendChild(span);
                return span;
            }

            function updateMappedDisplayForSelect(sel){
                try{
                    const span = createOrGetMappedDisplay(sel);
                    if(!span) return;
                    const opt = sel.options[sel.selectedIndex] || null;
                    let num = '';
                    if(opt){
                        num = opt.dataset && opt.dataset.teamNumber ? opt.dataset.teamNumber : (opt.textContent || '').trim().split(' ')[0];
                    }
                    if(!num) { span.textContent = ''; span.removeAttribute('data-team-num'); return; }
                    span.setAttribute('data-team-num', String(num));
                    // Let the central mapper apply formatting for consistency
                    if(typeof window.applyTeamNumberDisplayPreference === 'function'){
                        // apply to this single element by calling the global re-apply (debounced)
                        window.applyTeamNumberDisplayPreference();
                    }
                }catch(e){ /* ignore */ }
            }

            function attachToSelect(sel){
                try{
                    if(sel.__mappedDisplayAttached) return;
                    sel.addEventListener('change', function(){ updateMappedDisplayForSelect(sel); });
                    // initialize now
                    updateMappedDisplayForSelect(sel);
                    sel.__mappedDisplayAttached = true;
                }catch(e){ /* ignore */ }
            }

            function scanAndAttach(){
                try{
                    document.querySelectorAll('select').forEach(sel => {
                        try{
                            if(isTeamSelect(sel)) attachToSelect(sel);
                        }catch(e){}
                    });
                }catch(e){}
            }

            // Initial scan on DOM ready
            if(document.readyState === 'loading') document.addEventListener('DOMContentLoaded', scanAndAttach); else scanAndAttach();

            // Observe additions to attach to dynamically inserted selects
            const selObserver = new MutationObserver(debounce((mutations) => {
                let found = false;
                mutations.forEach(m => {
                    m.addedNodes && m.addedNodes.forEach(node => {
                        if(node.nodeType !== 1) return;
                        if(node.tagName === 'SELECT') { found = true; attachToSelect(node); }
                        else if(node.querySelector && node.querySelector('select')) { found = true; scanAndAttach(); }
                    });
                });
                if(found){ try{ if(window._applyTeamNumberDebounce) clearTimeout(window._applyTeamNumberDebounce); window._applyTeamNumberDebounce = setTimeout(() => { try{ window.applyTeamNumberDisplayPreference(); }catch(e){} }, 60); }catch(e){}
            }, 60));

            try{ selObserver.observe(document.body, { childList: true, subtree: true }); }catch(e){}

            // Also re-run when preference changes (storage event will trigger global mapper, but ensure our selects have spans)
            window.addEventListener('storage', function(e){ if(e.key === 'display_offseason_preference') scanAndAttach(); });
        })();
        </script>

    
    
    
<!-- Cache bust: 2026-02-01-v4 -->
<!-- Inject game config into page for offline use -->
<script>;
(function(){
    // FORCE CACHE CLEAR - Remove old broken cached templates
    try {
        const oldVersion = localStorage.getItem('form_template_version');
        if (oldVersion !== 'v4-2026-02-01') {
            console.log('[Cache Clear] Clearing old cached form template');
            localStorage.removeItem('scouting_form_html_template');
            localStorage.setItem('form_template_version', 'v4-2026-02-01');
        }
    } catch (e) { console.warn('Could not clear cache:', e); }
})();

window.gameConfig = {};
</script>

<!-- Offline scouting form manager -->
<script src="/static/js/scouting_form_offline.js"></script>

<script>
    document.addEventListener('DOMContentLoaded', function() {
        // Load form offline using cached data
        function loadFormOffline(offlineData, savedScrollY, savedActiveId) {
            console.log('[Offline Mode] Loading form from cached data...');
            
            const formContent = document.getElementById('form-content');
            const { team, match, html, cached, needsReset } = offlineData;
            
            // Update subheading (guarded)
            try {
                const _sub = document.getElementById('form-subheading');
                if (_sub) {
                    _sub.textContent = `${team.team_number} - ${team.team_name} | ${match.match_type} ${match.match_number}`;
                }
            } catch (e) { /* ignore if DOM not ready */ }
            
            let formHTML;
            
            // If we have cached server-rendered HTML, use it directly
            if (cached && html) {
                console.log('[Offline Mode] Using cached universal form template');
                
                // Add offline indicator banner
                const offlineBanner = `
                    <div class="alert alert-info alert-dismissible fade show mb-3">
                        <i class="fas fa-wifi-slash me-2"></i>
                        <strong>Offline Mode</strong> - Form loaded from cache. 
                        Data will be saved locally and synced when connection is restored.
                        <button type="button" class="btn-close" data-bs-dismiss="alert" aria-label="Close"></button>
                    </div>
                `;
                
                formHTML = offlineBanner + html;
            } else {
                // Fallback: generate form from game config
                console.log('[Offline Mode] Generating form from game config');
                formHTML = generateOfflineFormHTML(team, match, offlineData.gameConfig);
            }
            
            // Preserve current auto timer toggle state (if user toggled before load) so it isn't lost when we overwrite the form
            try {
                const existingToggle = document.getElementById('auto_period_timer_enabled');
                if (existingToggle) {
                    // Use the same key as the main scripts to keep behavior consistent
                    localStorage.setItem('auto_period_timer_enabled', existingToggle.checked ? 'true' : 'false');
                    console.log('[Offline Mode] Preserved existing auto timer toggle state before injecting form HTML');
                }
            } catch (e) {
                // ignore
            }

            // Preserve spinning counter toggle state as well (if present)
            try {
                const existingSpinToggle = document.getElementById('spinningCountersToggle');
                if (existingSpinToggle) {
                    localStorage.setItem('spinning_counters_enabled', existingSpinToggle.checked ? 'true' : 'false');
                    console.log('[Offline Mode] Preserved existing spinning counter toggle state before injecting form HTML');
                }
            } catch (e) {
                // ignore
            }

            formContent.innerHTML = formHTML;
            
            // Debug: Check if rating containers exist in DOM
            const ratingContainersInDOM = document.querySelectorAll('.rating-container');
            console.log('[After HTML Injection] Rating containers in DOM:', ratingContainersInDOM.length);
            if (ratingContainersInDOM.length > 0) {
                ratingContainersInDOM.forEach((container, idx) => {
                    console.log(`[Rating Container ${idx}]`, {
                        elementId: container.dataset.elementId,
                        starCount: container.querySelectorAll('.rating-star').length,
                        html: container.innerHTML.substring(0, 200)
                    });
                });
            }
            
            // Determine alliance color from match schedule
            const alliance = determineAlliance(team.team_number, match);
            console.log('[Offline Mode] Determined alliance:', alliance);
            
            // Update alliance indicator
            updateAllianceIndicator(alliance, team, match);
            
            // Update hidden fields with correct team/match data
            const scoutingForm = document.getElementById('scouting-form');
            if (scoutingForm) {
                scoutingForm.dataset.offline = 'true';
                
                // Update or create hidden fields
                updateOrCreateHiddenField(scoutingForm, 'team_id', team.id);
                updateOrCreateHiddenField(scoutingForm, 'match_id', match.id);
                updateOrCreateHiddenField(scoutingForm, 'team_number', team.team_number);
                updateOrCreateHiddenField(scoutingForm, 'match_number', match.match_number);
                updateOrCreateHiddenField(scoutingForm, 'match_type', match.match_type);
                updateOrCreateHiddenField(scoutingForm, 'alliance', alliance);
            }
            
            // Initialize form components immediately after DOM update
            setTimeout(() => {
                initializeFormComponents();

                // once components are ready attach autosave handlers and rehydrate draft
                try { setupAutosave(); } catch (e) { console.warn('[Offline Mode] setupAutosave failed', e); }
                try { loadAutosaveData(); } catch (e) { console.warn('[Offline Mode] loadAutosaveData failed', e); }

                // reset values to defaults when using cached template
                if (needsReset) {
                    console.log('[Offline Mode] Resetting form values to defaults');
                    resetFormToDefaults();
                }

                // wire up autosave so that offline users also benefit from live caching
                try { setupAutosave(); } catch (e) { /* ignore */ }
                try { loadAutosaveData(); } catch (e) { /* ignore */ }

                // Ensure the auto-period-timer toggle is restored and persists across loads
                try {
                    setupAutoTimerTogglePersistence();
                } catch (e) {
                    console.warn('Could not setup auto timer toggle persistence', e);
                }

                // Ensure spinning counters toggle is present and persists across loads
                try {
                    setupSpinningCountersTogglePersistence();
                } catch (e) {
                    console.warn('Could not setup spinning counters toggle persistence', e);
                }

                // Enable save button in offline mode
                const saveBtn = document.getElementById('save-button');
                if (saveBtn) {
                    saveBtn.disabled = false;
                }

                // Restore scroll and focus
                try {
                    if (typeof window.safeRestoreScroll === 'function') {
                        window.safeRestoreScroll(savedScrollY, { behavior: 'auto', timeout: 300 });
                    }
                } catch (e) {
                    console.warn('Could not restore scroll position', e);
                }

                if (savedActiveId) {
                    try {
                        const prev = document.getElementById(savedActiveId);
                        if (prev && typeof prev.focus === 'function') {
                            prev.focus({ preventScroll: true });
                        }
                    } catch (e) {
                        // ignore
                    }
                }
            }, 50);
        }
        
        // Helper function to update or create hidden field
        function updateOrCreateHiddenField(form, name, value) {
            let field = form.querySelector(`input[name="${name}"]`);
            if (!field) {
                field = document.createElement('input');
                field.type = 'hidden';
                field.name = name;
                form.appendChild(field);
            }
            field.value = value;
        }
        
        // Determine alliance color from match schedule data
        function determineAlliance(teamNumber, match) {
            const teamNumStr = String(teamNumber);
            
            // Check red alliance
            if (match.red_alliance) {
                const redTeams = match.red_alliance.split(',').map(t => t.trim());
                if (redTeams.includes(teamNumStr)) {
                    return 'red';
                }
            }
            
            // Check blue alliance
            if (match.blue_alliance) {
                const blueTeams = match.blue_alliance.split(',').map(t => t.trim());
                if (blueTeams.includes(teamNumStr)) {
                    return 'blue';
                }
            }
            
            return 'unknown';
        }
        
        // Update the alliance indicator UI
        function updateAllianceIndicator(alliance, team, match) {
            const indicator = document.querySelector('.alliance-indicator');
            if (!indicator) return;
            
            // Remove existing alliance classes
            indicator.classList.remove('bg-danger', 'bg-primary', 'bg-warning', 'alliance-unknown');
            
            // Set alliance-specific styling
            if (alliance === 'red') {
                indicator.classList.add('bg-danger');
                indicator.querySelector('.alliance-icon i')?.classList.remove('fa-tint');
                indicator.querySelector('.alliance-icon i')?.classList.add('fa-fire');
                const _h_red = indicator.querySelector('.alliance-details h4');
                if (_h_red) _h_red.textContent = 'Red Alliance';
                
                // Update text colors for red alliance
                const h4_red = indicator.querySelector('.alliance-details h4');
                const teamDiv_red = indicator.querySelector('.alliance-details > div:last-child');
                if (h4_red) h4_red.classList.add('text-white');
                if (teamDiv_red) {
                    teamDiv_red.classList.remove('text-muted', 'text-dark');
                    teamDiv_red.classList.add('text-white-50');
                }
                indicator.querySelector('.alliance-icon i')?.classList.add('text-white');
            } else if (alliance === 'blue') {
                indicator.classList.add('bg-primary');
                indicator.querySelector('.alliance-icon i')?.classList.remove('fa-fire');
                indicator.querySelector('.alliance-icon i')?.classList.add('fa-tint');
                const _h_blue = indicator.querySelector('.alliance-details h4');
                if (_h_blue) _h_blue.textContent = 'Blue Alliance';
                
                // Update text colors for blue alliance
                const h4_blue = indicator.querySelector('.alliance-details h4');
                const teamDiv_blue = indicator.querySelector('.alliance-details > div:last-child');
                if (h4_blue) h4_blue.classList.add('text-white');
                if (teamDiv_blue) {
                    teamDiv_blue.classList.remove('text-muted', 'text-dark');
                    teamDiv_blue.classList.add('text-white-50');
                }
                indicator.querySelector('.alliance-icon i')?.classList.add('text-white');
            } else {
                indicator.classList.add('bg-warning', 'alliance-unknown');
                indicator.querySelector('.alliance-icon i')?.classList.remove('fa-fire');
                indicator.querySelector('.alliance-icon i')?.classList.add('fa-tint');
                const _h_unknown = indicator.querySelector('.alliance-details h4');
                if (_h_unknown) _h_unknown.textContent = 'Unknown Alliance';
                
                // Update text colors for unknown alliance
                const h4_unknown = indicator.querySelector('.alliance-details h4');
                const teamDiv_unknown = indicator.querySelector('.alliance-details > div:last-child');
                if (h4_unknown) h4_unknown.classList.add('text-dark');
                if (teamDiv_unknown) {
                    teamDiv_unknown.classList.remove('text-white-50');
                    teamDiv_unknown.classList.add('text-muted');
                }
                indicator.querySelector('.alliance-icon i')?.classList.add('text-dark');
            }
            
            // Update team info
                const teamInfoDiv = indicator.querySelector('.alliance-details > div:last-child');
                if (teamInfoDiv) {
                    teamInfoDiv.innerHTML = `Team <span class="team-number" data-team-num="${team.team_number}">${team.team_number}</span> - ${team.team_name}`;
                }
            
            console.log('[Offline Mode] Alliance indicator updated to:', alliance);
        }

        // Ensure auto-period-timer toggle state persists across form injections
        function setupAutoTimerTogglePersistence() {
            const toggle = document.getElementById('auto_period_timer_enabled');
            if (!toggle) return;

            // Restore state from localStorage if present (use same key as scripts.js)
            const saved = localStorage.getItem('auto_period_timer_enabled');
            if (saved !== null) {
                toggle.checked = (saved === 'true');
            }

            // Attach listener to persist user changes if scripts.js didn't already; avoid duplicates
            if (!toggle._scoutingAutoTimerListenerAttached) {
                toggle.addEventListener('change', function() {
                    try {
                        localStorage.setItem('auto_period_timer_enabled', toggle.checked ? 'true' : 'false');
                        console.log('[Offline Mode] Auto timer toggle state saved:', toggle.checked);
                    } catch (e) {
                        console.warn('Could not persist auto timer toggle state', e);
                    }
                });
                toggle._scoutingAutoTimerListenerAttached = true;
            }
        }

        // Ensure spinning counters toggle state persists across form injections
        function setupSpinningCountersTogglePersistence() {
            const toggle = document.getElementById('spinningCountersToggle');
            if (!toggle) return;

            // Restore state from localStorage if present (use same key as settings.js); default to true to match Settings
            const saved = localStorage.getItem('spinning_counters_enabled');
            if (saved === null) {
                // Default to enabled (same UX as settings page default)
                toggle.checked = true;
                try { initializeSpinningCounters(); } catch (e) { console.warn('Could not initialize spinning counters on load', e); }
            } else {
                toggle.checked = (saved === 'true' || saved === '1');
                // Apply saved preference immediately so UI reflects the setting right away
                if (toggle.checked) {
                    try { initializeSpinningCounters(); } catch (e) { console.warn('Could not initialize spinning counters on load', e); }
                } else {
                    try { teardownSpinningCounters(); } catch (e) { console.warn('Could not teardown spinning counters on load', e); }
                }
            }

            // Attach listener to persist user changes and trigger init/teardown
            if (!toggle._scoutingSpinListenerAttached) {
                toggle.addEventListener('change', function() {
                    try {
                        localStorage.setItem('spinning_counters_enabled', toggle.checked ? 'true' : 'false');
                        console.log('[Offline Mode] Spinning counters preference saved:', toggle.checked);
                        if (toggle.checked) {
                            try { initializeSpinningCounters(); } catch (e) { console.warn('Could not initialize spinning counters', e); }
                        } else {
                            try { teardownSpinningCounters(); } catch (e) { console.warn('Could not teardown spinning counters', e); }
                        }
                    } catch (e) {
                        console.warn('Could not persist spinning counters preference', e);
                    }
                });
                toggle._scoutingSpinListenerAttached = true;
            }
        }
        
        // Reset form to default values
        function resetFormToDefaults() {
            const form = document.getElementById('scouting-form');
            if (!form) return;
            
            // Read saved auto timer state from localStorage (use same key as scripts.js)
            const savedAutoTimerState = (localStorage.getItem('auto_period_timer_enabled') === 'true');
            
            // Reset all inputs to their default values
            const inputs = form.querySelectorAll('input:not([type="hidden"]), select, textarea');
            inputs.forEach(input => {
                // Skip the auto period timer toggle
                if (input.id === 'auto_period_timer_enabled') {
                    return;
                }
                
                if (input.type === 'checkbox' || input.type === 'radio') {
                    input.checked = false;
                } else if (input.type === 'number' || input.classList.contains('counter-input')) {
                    input.value = 0;
                } else if (input.tagName === 'SELECT') {
                    input.selectedIndex = 0;
                } else {
                    input.value = '';
                }
            });
            
            // Restore the auto period timer toggle state
            const autoTimerToggle = document.getElementById('auto_period_timer_enabled');
            if (autoTimerToggle) {
                autoTimerToggle.checked = savedAutoTimerState;
            }

            // Restore spinning counters toggle state
            try {
                const savedSpinState = (localStorage.getItem('spinning_counters_enabled') === 'true');
                const spinToggle = document.getElementById('spinningCountersToggle');
                if (spinToggle) {
                    spinToggle.checked = savedSpinState;
                    // Initialize or teardown based on saved state
                    if (savedSpinState) {
                        try { initializeSpinningCounters(); } catch(e) { console.warn('Error initializing spinning counters on reset', e); }
                    } else {
                        try { teardownSpinningCounters(); } catch(e) { console.warn('Error tearing down spinning counters on reset', e); }
                    }
                }
            } catch (e) {}


            
            // Update points displays to 0
            const pointsDisplays = form.querySelectorAll('.points-display .points-value');
            pointsDisplays.forEach(display => {
                display.textContent = '0';
            });
            
            // Clear scout name but keep it enabled
            const scoutNameInput = form.querySelector('#scout_name, input[name="scout_name"]');
            if (scoutNameInput) {
                scoutNameInput.value = '';
            }
            
            console.log('[Offline Mode] Form reset to default values (auto timer toggle preserved)');
        }
        
        // Generate complete offline form HTML matching online structure
        function generateOfflineFormHTML(team, match, gameConfig) {
            let html = '';
            html += '<!-- Offline Mode Indicator -->';
            html += '<div class="alert alert-info alert-dismissible fade show mb-3">';
            html += '<i class="fas fa-wifi-slash me-2"></i>';
            html += '<strong>Offline Mode</strong> - Form loaded from cached data. ';
            html += 'Data will be saved locally and synced when connection is restored.';
            html += '<button type="button" class="btn-close" data-bs-dismiss="alert" aria-label="Close"></button>';
            html += '</div>';
            html += '<!-- Scouting Form -->';
            html += '<form id="scouting-form" class="scouting-form" data-offline="true">';
            html += `<input type="hidden" name="team_id" value="${team.id}">`;
            html += `<input type="hidden" name="match_id" value="${match.id}">`;
            html += `<input type="hidden" name="team_number" value="${team.team_number}">`;
            html += `<input type="hidden" name="match_number" value="${match.match_number}">`;
            html += `<input type="hidden" name="match_type" value="${match.match_type}">`;
            html += generateFormFieldsFromConfig(gameConfig);
            html += '<div class="form-check form-switch mt-2">';
            html += '<input class="form-check-input" type="checkbox" id="spinningCountersToggle" role="switch" aria-label="Enable spinning counters (per-device)">';
            html += '<label class="form-check-label" for="spinningCountersToggle">';
            html += 'Enable spinning counters (per-device) <i class="fas fa-question-circle ms-2"';
            html += ' title="Enable the spinning counter UI on this device. Each 0.125 rotation (45Â°) increments the count by one. This preference is stored locally and does not require admin approval."></i>';
            html += '</label>';
            html += '</div>';
            html += '<!-- Action Buttons -->';
            html += '<div class="form-section mb-4">';
            html += '<div class="d-grid gap-2">';
            html += '<button type="button" id="save-button" class="btn btn-primary btn-lg">';
            html += '<i class="fas fa-save me-2"></i>Save Offline';
            html += '</button>';
            html += '<button type="button" id="generateQR" class="btn btn-success btn-lg">';
            html += '<i class="fas fa-qrcode me-2"></i>Generate QR Code';
            html += '</button>';
            html += '<button type="button" id="export-json-button" class="btn btn-info btn-lg">';
            html += '<i class="fas fa-file-export me-2"></i>Export JSON';
            html += '</button>';
            html += '<button type="button" id="reset-form" class="btn btn-outline-secondary">';
            html += '<i class="fas fa-redo me-2"></i>Reset Form';
            html += '</button>';
            html += '</div>';
            html += '<div class="mt-2 text-center small text-muted">';
            html += '<i class="fas fa-info-circle me-1"></i>';
            html += 'Offline mode: Data will be saved locally';
            html += '</div>';
            html += '</div>';
            html += '</form>';
            return html;
        }
        
        // Generate form fields from game config - matches online structure
        function generateFormFieldsFromConfig(config) {
            if (!config) return '<div class="alert alert-warning">No game configuration available</div>';
            
            let html = '';
            
            // Scout info section
            html += `
                <div class="card mb-3 navbar-glass">
                    <div class="card-header bg-primary text-white">
                        <h5 class="mb-0">Scout Information</h5>
                    </div>
                    <div class="card-body">
                        <div class="mb-3">
                            <label for="scout_name" class="form-label">Scout Name</label>
                            <input type="text" class="form-control" id="scout_name" name="scout_name" 
                                   placeholder="Enter your name" required>
                        </div>
                    </div>
                </div>
            `;
            
            // Generate match period tabs
            const periods = [
                { key: 'auto_period', icon: 'robot', color: 'primary' },
                { key: 'teleop_period', icon: 'gamepad', color: 'success' },
                { key: 'endgame_period', icon: 'flag-checkered', color: 'warning' }
            ];
            
            const availablePeriods = periods.filter(p => config[p.key] && config[p.key].scoring_elements && config[p.key].scoring_elements.length > 0);
            
            if (availablePeriods.length > 0) {
                // Tab navigation
                html += `
                    <ul class="nav nav-tabs mb-3" role="tablist">
                `;
                
                availablePeriods.forEach((period, index) => {
                    const periodData = config[period.key];
                    const periodName = periodData.name || period.key.replace('_period', '').replace('_', ' ');
                    const isActive = index === 0 ? 'active' : '';
                    
                    html += `
                        <li class="nav-item" role="presentation">
                            <button class="nav-link ${isActive}" id="${period.key}-tab" data-bs-toggle="tab" 
                                    data-bs-target="#${period.key}" type="button" role="tab">
                                <i class="fas fa-${period.icon} me-2"></i>${periodName}
                            </button>
                        </li>
                    `;
                });
                
                html += `</ul>`;
                
                // Tab content
                html += `<div class="tab-content">`;
                
                availablePeriods.forEach((period, index) => {
                    const periodData = config[period.key];
                    const isActive = index === 0 ? 'show active' : '';
                    
                    html += `
                        <div class="tab-pane fade ${isActive}" id="${period.key}" role="tabpanel">
                            <div class="card mb-3 navbar-glass">
                                <div class="card-body">
                    `;
                    
                    // Generate scoring elements for this period
                    if (periodData.scoring_elements && periodData.scoring_elements.length > 0) {
                        periodData.scoring_elements.forEach(element => {
                            html += generateFormElement(element, period.key);
                        });
                    }
                    
                    html += `
                                </div>
                            </div>
                        </div>
                    `;
                });
                
                html += `</div>`;
            }
            
            // Post-match section
            if (config.post_match) {
                html += `
                    <div class="card mb-3 navbar-glass">
                        <div class="card-header bg-secondary text-white">
                            <h5 class="mb-0"><i class="fas fa-clipboard-check me-2"></i>Post-Match</h5>
                        </div>
                        <div class="card-body">
                `;
                
                // Rating elements
                if (config.post_match.rating_elements && config.post_match.rating_elements.length > 0) {
                    config.post_match.rating_elements.forEach(element => {
                        html += generateFormElement(element, 'post_match');
                    });
                }
                
                // Text elements
                if (config.post_match.text_elements && config.post_match.text_elements.length > 0) {
                    config.post_match.text_elements.forEach(element => {
                        html += generateFormElement(element, 'post_match');
                    });
                }
                
                // Boolean elements
                if (config.post_match.boolean_elements && config.post_match.boolean_elements.length > 0) {
                    config.post_match.boolean_elements.forEach(element => {
                        html += generateFormElement(element, 'post_match');
                    });
                }
                
                html += `
                        </div>
                    </div>
                `;
            }
            
            return html;
        }
        
        // Generate individual form element matching online styling
        function generateFormElement(element, periodKey) {
            console.log('[Generate Element]', { id: element.id, type: element.type, periodKey: periodKey });
            
            const id = element.id || element.name || 'element_' + Math.random();
            const label = element.name || element.label || id;
            const type = element.type || 'text';
            const defaultValue = element.default !== undefined ? element.default : '';
            const description = element.description || '';
            
            let html = `<div class="mb-4 form-element" data-element-type="${type}" data-period="${periodKey}">`;
            
            switch (type) {
                case 'counter': {
                    const pointsValue = element.points_value || 0;
                    html += `
                        <label class="form-label fw-bold">${label}</label>
                        ${description ? `<div class="form-text mb-2">${description}</div>` : ''}
                        <div class="input-group counter-control">
                            <button type="button" class="btn btn-outline-danger counter-btn" data-action="decrement" data-target="${id}">
                                <i class="fas fa-minus"></i>
                            </button>
                            <input type="number" class="form-control counter-input text-center fs-4 fw-bold" 
                                   id="${id}" name="${id}" value="${defaultValue}" min="0" 
                                   data-points="${pointsValue}">
                            <button type="button" class="btn btn-outline-success counter-btn" data-action="increment" data-target="${id}">
                                <i class="fas fa-plus"></i>
                            </button>
                        </div>
                    `;
                    if (pointsValue > 0) {
                        html += `
                            <div class="points-display mt-2 text-end small text-muted" data-metric-id="${id}">
                                <span class="points-value">0</span> points (${pointsValue} each)
                            </div>
                        `;
                    }
                    break;
                }
                    
                case 'boolean':
                case 'checkbox':
                    html += `
                        <div class="form-check form-switch">
                            <input type="checkbox" class="form-check-input" id="${id}" name="${id}" 
                                   role="switch" ${defaultValue ? 'checked' : ''}>
                            <label class="form-check-label fw-bold" for="${id}">${label}</label>
                            ${description ? `<div class="form-text">${description}</div>` : ''}
                        </div>
                    `;
                    break;
                    
                case 'select':
                case 'dropdown':
                    html += `
                        <label for="${id}" class="form-label fw-bold">${label}</label>
                        ${description ? `<div class="form-text mb-2">${description}</div>` : ''}
                        <select class="form-select" id="${id}" name="${id}">
                    `;
                    if (element.options && element.options.length > 0) {
                        element.options.forEach(option => {
                            const value = typeof option === 'object' ? (option.value || option) : option;
                            const optionLabel = typeof option === 'object' ? (option.label || value) : option;
                            html += `<option value="${value}" ${value == defaultValue ? 'selected' : ''}>${optionLabel}</option>`;
                        });
                    }
                    html += `</select>`;
                    break;
                    
                case 'rating': {
                    // Generate stars based on min/max values, default to 1-5 if not specified
                    const minRating = element.min || 1;
                    const maxRating = element.max || 5;
                    const currentRating = parseInt(defaultValue) || minRating;
                    
                    console.log('[Rating HTML Gen]', {
                        id: id,
                        label: label,
                        minRating: minRating,
                        maxRating: maxRating,
                        currentRating: currentRating
                    });
                    
                    html += `
                        <div class="card mb-3">
                            <div class="card-body text-center">
                                <label class="form-label fw-bold">${label}</label>
                                ${description ? `<div class="form-text mb-3">${description}</div>` : ''}
                                <div class="rating-container mb-2" data-element-id="${id}">
                    `;
                    
                    for (let i = minRating; i <= maxRating; i++) {
                        const isActive = i <= currentRating ? 'active' : '';
                        html += `<i class="rating-star fas fa-star ${isActive}" data-value="${i}" data-rating-id="${id}" role="button" tabindex="0" aria-label="Rate ${i}"></i>`;
                    }
                    html += `
                                </div>
                                <input type="hidden" name="${id}" id="${id}" value="${currentRating}">
                                <div class="small text-muted mt-2">Click a star to rate (${minRating}-${maxRating})</div>
                            </div>
                        </div>
                    `;
                    break;
                }
                    
                case 'textarea':
                    html += `
                        <label for="${id}" class="form-label fw-bold">${label}</label>
                        ${description ? `<div class="form-text mb-2">${description}</div>` : ''}
                        <textarea class="form-control" id="${id}" name="${id}" rows="3">${defaultValue}</textarea>
                    `;
                    break;
                    
                case 'text':
                default:
                    html += `
                        <label for="${id}" class="form-label fw-bold">${label}</label>
                        ${description ? `<div class="form-text mb-2">${description}</div>` : ''}
                        <input type="text" class="form-control" id="${id}" name="${id}" value="${defaultValue}">
                    `;
                    break;
            }
            
            html += `</div>`;
            return html;
        }

        // Initialize form components in one place for easier updates
        function initializeFormComponents() {
            // wire up autosave listeners and restore any saved draft immediately
            try { setupAutosave(); } catch (e) { console.warn('setupAutosave failed', e); }
            try { loadAutosaveData(); } catch (e) { console.warn('loadAutosaveData failed', e); }

            // Show QR code in modal when generated
            const generateQRButton = document.getElementById('generateQR');
            if (generateQRButton) {
                const qrModalElement = document.getElementById('qrModal');
                if (qrModalElement) {
                    const qrModal = new bootstrap.Modal(qrModalElement);
                    
                    // Remove any existing event listener first
                    generateQRButton.removeEventListener('click', showQRModal);
                    
                    // Add new event listener
                    generateQRButton.addEventListener('click', showQRModal);
                    
                    function showQRModal() {
                        try {
                            // Show modal first, then generate QR code
                            qrModal.show();
                            if (typeof generateQRCode === 'function') {
                                generateQRCode(); // This function is defined in scripts.js
                            }
                        } catch (error) {
                            console.error('Error showing QR modal:', error);
                        }
                    }
                } else {
                    console.warn('QR Modal element not found');
                }
            } else {
                console.warn('Generate QR Button not found');
            }
            
            // Initialize counters (needed for points calculation)
            initializeCounters();
            
            // Initialize star rating system
            initializeRatings();
            
            // Initialize match period tabs
            initializeMatchPeriodTabs();
            
            // Initialize auto period timer
            initializeAutoPeriodTimer();
            
            // Initialize points calculation
            initializePointsCalculation();

            // Form reset button
            initializeResetButton();

            // Setup save button with enhanced functionality
            setupSaveButton();
            
            // Setup export JSON button
            setupExportJsonButton();

            // Setup save locally handler (if scripts.js provided it)
            if (typeof setupSaveLocally === 'function') {
                try { setupSaveLocally(); } catch (e) { /* ignore */ }
            }

            // Make sure points are calculated on page load
            updatePointsCalculation();
        }
        
        // Function to show toast notifications
        function showToast(message, type = 'info') {
            const toastContainer = document.querySelector('.toast-container');
            if (!toastContainer) return;
            
            const toast = document.createElement('div');
            toast.classList.add('toast', 'align-items-center', 'border-0');
            toast.classList.add(`bg-${type === 'error' ? 'danger' : type}`);
            if (type === 'error' || type === 'success') {
                toast.classList.add('text-white');
            }
            toast.setAttribute('role', 'alert');
            toast.setAttribute('aria-live', 'assertive');
            toast.setAttribute('aria-atomic', 'true');
            
            toast.innerHTML = `
                <div class="d-flex">
                    <div class="toast-body">
                        <i class="fas fa-${type === 'success' ? 'check-circle' : type === 'error' ? 'exclamation-circle' : 'info-circle'} me-2"></i>
                        ${message}
                    </div>
                    <button type="button" class="btn-close btn-close-white me-2 m-auto" data-bs-dismiss="toast" aria-label="Close"></button>
                </div>
            `;
            
            toastContainer.appendChild(toast);
            
            const bsToast = new bootstrap.Toast(toast, {
                delay: 5000
            });
            
            bsToast.show();
            
            // Remove toast from DOM after it's been hidden
            toast.addEventListener('hidden.bs.toast', function() {
                if (toast.parentNode) {
                    toast.parentNode.removeChild(toast);
                }
            });
        }
        
        // Set up Save button handler
        function setupSaveButton() {
            const saveBtn = document.getElementById('save-button');
            if (!saveBtn) return;
            
            saveBtn.addEventListener('click', function(e) {
                e.preventDefault();
                
                const form = document.getElementById('scouting-form');
                if (!form) return;
                
                // Validate form
                if (!validateForm(form)) {
                    showToast('Please fill in all required fields', 'error');
                    return;
                }
                
                // Visual feedback - change button state
                const originalText = saveBtn.innerHTML;
                saveBtn.disabled = true;
                
                // Check if we're in offline mode
                const isOfflineForm = form.dataset.offline === 'true';
                const isOffline = !navigator.onLine;
                
                if (isOffline || isOfflineForm) {
                    // Save offline
                    saveBtn.innerHTML = '<span class="spinner-border spinner-border-sm me-2" role="status"></span>Saving Offline...';
                    
                    try {
                        // Collect form data
                        const formData = new FormData(form);
                        const formObj = {};
                        
                        formData.forEach((value, key) => {
                            const element = form.elements[key];
                            
                            // Handle checkboxes
                            if (element && element.type === 'checkbox') {
                                formObj[key] = element.checked;
                                return;
                            }
                            
                            // Handle numbers
                            if (element && (element.type === 'number' || element.classList.contains('counter-input'))) {
                                formObj[key] = value === '' ? 0 : Number(value);
                                return;
                            }
                            
                            // Handle everything else
                            formObj[key] = value;
                        });
                        
                        // Add timestamp
                        formObj.timestamp = new Date().toISOString();
                        formObj.offline = true;
                        
                        // Save using offline manager
                        if (window.ScoutingOfflineManager) {
                            const saved = window.ScoutingOfflineManager.saveFormOffline(formObj);
                            
                            if (saved) {
                                saveBtn.disabled = false;
                                saveBtn.innerHTML = originalText;
                                
                                showToast('Data saved offline successfully! Will sync when connection is restored. You can also manage unsynced entries on the Offline Data page.', 'success');
                                // clear any autosaved draft now that we have persisted
                                try { clearAutosaveForForm(); } catch (e) {}
                                
                                // Add save indicator
                                const saveTimeIndicator = document.createElement('div');
                                saveTimeIndicator.className = 'save-indicator';
                                saveTimeIndicator.innerHTML = `
                                    <div class="small text-success mt-2 text-end">
                                        <i class="fas fa-check-circle me-1"></i>
                                        Saved offline at ${new Date().toLocaleTimeString()}
                                    </div>
                                `;
                                
                                const existingIndicator = document.querySelector('.save-indicator');
                                if (existingIndicator) {
                                    existingIndicator.replaceWith(saveTimeIndicator);
                                } else {
                                    const buttonContainer = saveBtn.closest('.form-section');
                                    if (buttonContainer) {
                                        buttonContainer.appendChild(saveTimeIndicator);
                                    }
                                }
                            } else {
                                throw new Error('Failed to save offline');
                            }
                        } else {
                            throw new Error('Offline manager not available');
                        }
                    } catch (error) {
                        console.error('Error saving offline:', error);
                        saveBtn.disabled = false;
                        saveBtn.innerHTML = originalText;
                        showToast('Error saving offline. Try generating a QR code instead.', 'error');
                    }
                    
                    return;
                }
                
                // Online save
                saveBtn.innerHTML = '<span class="spinner-border spinner-border-sm me-2" role="status"></span>Saving...';
                
                // Get the form data
                const formData = new FormData(form);
                
                // Submit form via AJAX
                fetch('/scouting/api_save', {
                    method: 'POST',
                    body: formData,
                    headers: {
                        'X-Requested-With': 'XMLHttpRequest'
                    }
                })
                .then(response => {
                    if (!response.ok) {
                        throw new Error('Network response was not ok: ' + response.statusText);
                    }
                    return response.json();
                })
                .then(data => {
                    console.log('Save response:', data);
                    
                    // Reset button state
                    saveBtn.disabled = false;
                    saveBtn.innerHTML = originalText;
                    
                    if (data.success) {
                        // clear any autosaved draft since server has stored the submission
                        try { clearAutosaveForForm(); } catch (e) {}
                        // Show success message with some feedback about what was saved
                        showToast(`Data for Team ${data.team_number} in ${data.match_type} ${data.match_number} ${data.action} successfully!`, 'success');
                        
                        // Instead of redirecting, show a success indicator on the form
                        const formContainer = document.querySelector('.scouting-form');
                        if (formContainer) {
                            // Add visual success indicator to the form
                            formContainer.classList.add('form-saved');
                            setTimeout(() => {
                                formContainer.classList.remove('form-saved');
                            }, 2000);
                        }
                        
                        // Add a small badge showing when saved
                        const saveTimeIndicator = document.createElement('div');
                        saveTimeIndicator.className = 'save-indicator';
                        saveTimeIndicator.innerHTML = `
                            <div class="small text-success mt-2 text-end">
                                <i class="fas fa-check-circle me-1"></i>
                                Last saved at ${data.timestamp}
                            </div>
                        `;
                        
                        // Replace existing indicator or add new one
                        const existingIndicator = document.querySelector('.save-indicator');
                        if (existingIndicator) {
                            existingIndicator.replaceWith(saveTimeIndicator);
                        } else {
                            const buttonContainer = saveBtn.closest('.form-section');
                            if (buttonContainer) {
                                buttonContainer.appendChild(saveTimeIndicator);
                            }
                        }
                    } else {
                        showToast('Error: ' + (data.message || 'Unknown error'), 'error');
                    }
                })
                .catch(error => {
                    console.error('Error saving data:', error);
                    
                    // If it's a network error, save offline instead
                    if (error.message.includes('Network') || error.message.includes('Failed to fetch')) {
                        console.log('Network error, falling back to offline save...');
                        
                        // Reset button and try offline save
                        saveBtn.disabled = false;
                        saveBtn.innerHTML = originalText;
                        
                        // Mark form as offline and trigger save again
                        form.dataset.offline = 'true';
                        saveBtn.click();
                        return;
                    }
                    
                    // Reset button state
                    saveBtn.disabled = false;
                    saveBtn.innerHTML = originalText;
                    
                    // Handle error
                    showToast('Error saving data. Please try again or generate a QR code instead.', 'error');
                    
                    // If offline or connection error, suggest QR code
                    if (!navigator.onLine) {
                        showToast('You appear to be offline. Try generating a QR code instead.', 'info');
                    }
                });
            });
        }
        
        // Set up Export JSON button handler
        function setupExportJsonButton() {
            const exportBtn = document.getElementById('export-json-button');
            if (!exportBtn) return;
            
            exportBtn.addEventListener('click', function(e) {
                e.preventDefault();
                
                const form = document.getElementById('scouting-form');
                if (!form) return;
                
                // Visual feedback - change button state
                const originalText = exportBtn.innerHTML;
                exportBtn.disabled = true;
                exportBtn.innerHTML = '<span class="spinner-border spinner-border-sm me-2" role="status"></span>Exporting...';
                
                try {
                    // Build the same flat JSON object as used for QR codes
                    const formData = new FormData(form);
                    const jsonObj = {};

                    // Process form entries preserving booleans and numbers
                    formData.forEach((value, key) => {
                        const element = form.elements[key];

                        // Handle checkboxes (use checked boolean)
                        if (element && element.type === 'checkbox') {
                            jsonObj[key] = element.checked;
                            return;
                        }

                        // If the element is a number input, convert to Number
                        if (element && element.type === 'number') {
                            jsonObj[key] = value === '' ? 0 : Number(value);
                            return;
                        }

                        // If value looks numeric, convert to Number
                        if (value !== '' && !isNaN(value)) {
                            // But preserve arrays and multiple-valued inputs below
                            jsonObj[key] = Number(value);
                            return;
                        }

                        // Handle multiple values (checkbox groups, multi-selects)
                        if (jsonObj.hasOwnProperty(key)) {
                            if (Array.isArray(jsonObj[key])) jsonObj[key].push(value);
                            else jsonObj[key] = [jsonObj[key], value];
                        } else {
                            jsonObj[key] = value;
                        }
                    });

                    // Ensure unchecked checkboxes are present with false (use id if available)
                    const allCheckboxes = form.querySelectorAll('input[type="checkbox"]');
                    allCheckboxes.forEach(cb => {
                        const key = cb.name || cb.id || null;
                        if (!key) return;
                        if (!jsonObj.hasOwnProperty(key)) {
                            jsonObj[key] = false;
                        }
                    });

                    // Add calculated points similar to QR logic
                    const pointsElements = document.querySelectorAll('.points-display');
                    pointsElements.forEach(element => {
                        const metricId = element.dataset.metricId;
                        if (metricId) {
                            const pointsValue = element.querySelector('.points-value');
                            if (pointsValue) {
                                jsonObj[metricId + '_points'] = parseInt(pointsValue.textContent || '0');
                            }
                        }
                    });

                    // Ensure scout_name fallback
                    try {
                        const scoutField = form.elements['scout_name'] || document.getElementById('scout_name');
                        const fallbackScout = (scoutField && scoutField.placeholder) ? scoutField.placeholder : (scoutField && scoutField.value) ? scoutField.value : 'unknown';
                        if (!jsonObj.scout_name || (typeof jsonObj.scout_name === 'string' && jsonObj.scout_name.trim() === '')) {
                            jsonObj.scout_name = fallbackScout;
                        }
                    } catch (e) { /* ignore */ }

                    // Add generated_at and offline_generated to match QR payload
                    jsonObj.generated_at = new Date().toISOString();
                    jsonObj.offline_generated = true;

                    // Create and download flat JSON file
                    const jsonString = JSON.stringify(jsonObj, null, 2);
                    const blob = new Blob([jsonString], { type: 'application/json' });
                    const url = URL.createObjectURL(blob);

                    const a = document.createElement('a');
                    a.href = url;
                    const timestamp = new Date().toISOString().replace(/[:.]/g, '-').split('.')[0];
                    const teamPart = (jsonObj.team_id || jsonObj.team_number || 'unknown');
                    const matchPart = (jsonObj.match_id || jsonObj.match_number || 'unknown');
                    a.download = `scouting-data-team-${teamPart}-match-${matchPart}-${timestamp}.json`;
                    document.body.appendChild(a);
                    a.click();
                    document.body.removeChild(a);
                    URL.revokeObjectURL(url);

                    // Reset button state
                    exportBtn.disabled = false;
                    exportBtn.innerHTML = originalText;

                    showToast('Scouting data exported successfully!', 'success');

                } catch (error) {
                    console.error('Error exporting data:', error);

                    // Reset button state
                    exportBtn.disabled = false;
                    exportBtn.innerHTML = originalText;

                    showToast('Error exporting data. Please try again.', 'error');
                }
            });
        }
        
        // Form validation helper
        function validateForm(form) {
            const requiredFields = form.querySelectorAll('[required]');
            let valid = true;
            
            requiredFields.forEach(field => {
                if (!field.value) {
                    field.classList.add('is-invalid');
                    valid = false;
                    
                    // Focus first invalid field
                    if (valid === false && field === requiredFields[0]) {
                        field.focus();
                    }
                } else {
                    field.classList.remove('is-invalid');
                }
            });
            
            return valid;
        }
        
        // Initialize form reset button
        function initializeResetButton() {
            const resetBtn = document.getElementById('reset-form');
            if (resetBtn) {
                resetBtn.addEventListener('click', function() {
                    if (confirm('Are you sure you want to reset all form fields?')) {
                        const formInputs = document.querySelectorAll('#scouting-form input:not([type="hidden"]), #scouting-form select, #scouting-form textarea');
                        formInputs.forEach(input => {
                            if (input.type === 'checkbox') {
                                input.checked = false;
                            } else if (input.tagName === 'SELECT') {
                                input.selectedIndex = 0;
                            } else if (input.type === 'number' || input.classList.contains('counter-input')) {
                                // Reset numeric counters to 0 (not empty). Empty/null breaks arithmetic with +/- handlers.
                                try { input.value = 0; } catch (e) { input.value = '0'; }
                            } else {
                                input.value = '';
                            }
                        });
                        
                        // Update points after resetting form
                        updatePointsCalculation();
                        // clear any saved draft because the user intentionally reset
                        try { clearAutosaveForForm(); } catch (e) {}
                    }
                });
            }
        }
        
        // Team and Match selection enhancements with auto-submit
        const teamSelector = document.getElementById('team-selector');
        const matchSelector = document.getElementById('match-selector');
        const teamMatchForm = document.getElementById('team-match-form');
        
        if (teamSelector && matchSelector && teamMatchForm) {
            // New: search inputs for filtering options
            const teamSearch = document.getElementById('team-search');
            const matchSearch = document.getElementById('match-search');

            // Helper to normalize strings for comparison
            function normalizeString(s) {
                return (s || '').toString().toLowerCase().trim();
            }

            // Filter team options by team number or name
            function filterTeamOptions() {
                const query = normalizeString(teamSearch.value);
                const options = Array.from(teamSelector.querySelectorAll('option'));

                // Keep the empty placeholder visible
                options.forEach(opt => {
                    if (!opt.value) return; // placeholder

                    const teamNumber = normalizeString(opt.getAttribute('data-team-number'));
                    const teamName = normalizeString(opt.getAttribute('data-team-name'));
                    const text = normalizeString(opt.textContent || opt.innerText);
                    const match = !query || teamNumber.includes(query) || teamName.includes(query) || text.includes(query);

                    opt.hidden = !match;
                    opt.style.display = match ? '' : 'none';
                });

                // If the currently selected option is hidden by filter, reset selection to placeholder
                const current = teamSelector.options[teamSelector.selectedIndex];
                if (current && current.hidden) {
                    teamSelector.value = '';
                }

                // Auto-select if there's exactly one visible non-placeholder option
                const visibleOptions = options.filter(opt => opt.value && !opt.hidden);
                if (visibleOptions.length === 1) {
                    const only = visibleOptions[0];

                    // For teams: prefer exact team number match OR if query-empty but only one option
                    const teamNumberAttr = normalizeString(only.getAttribute('data-team-number'));
                    const exactNumberMatch = query && teamNumberAttr === query;

                    if (exactNumberMatch || query === '' || query.length > 0 && exactNumberMatch) {
                        // Programmatically select and dispatch change
                        teamSelector.value = only.value;
                        teamSelector.dispatchEvent(new Event('change', { bubbles: true }));
                    }
                }
                // Sync any custom select UI visibility if present
                try { syncCustomSelectVisibility(teamSelector); } catch (e) { /* ignore if not present */ }
            }

            // Filter match options by match type or number, with shorthand parsing
            function filterMatchOptions() {
                const raw = normalizeString(matchSearch.value);
                const options = Array.from(matchSelector.querySelectorAll('option'));

                // Parse query into alpha and numeric parts (e.g., 'sf1' -> letters: 'sf', number: '1')
                function parseMatchQuery(q) {
                    if (!q) return { letters: '', number: '' };
                    // remove extra spaces
                    const compact = q.replace(/\s+/g, '');
                    const numMatch = compact.match(/(\d+)/);
                    const number = numMatch ? numMatch[1] : '';
                    const letters = compact.replace(/\d+/g, '');
                    return { letters: letters, number: number };
                }

                const q = parseMatchQuery(raw);

                // Aliases for canonical match type words
                const aliases = {
                    qualification: ['q','qu','qual','qualification','qualif','qualifcation','qualifc'],
                    practice: ['p','pr','practice','prac','pract','pm','pm1'],
                    quarter: ['qf','quarter','quarterfinal','quarterfinals','quarter-final','quarter-finals','quarterfinals','qtr'],
                    semi: ['sf','sem','semi','semifinal','semifinals','sf1','smf','smf1','semifinalmatch'],
                    final: ['f','fin','final','finals','f1'],
                    playoff: ['playoff','po','playoffs','pm','pm1']
                };

                // Determine which canonical types the letters token maps to
                function candidateTypesFromLetters(letters) {
                    if (!letters) return [];
                    const res = [];
                    for (const [canon, arr] of Object.entries(aliases)) {
                        for (const a of arr) {
                            if (letters === a || letters.startsWith(a) || a.startsWith(letters)) {
                                res.push(canon);
                                break;
                            }
                        }
                    }
                    return res;
                }

                const candidateTypes = candidateTypesFromLetters(q.letters);

                // We'll compute a score for each option and use that to determine visibility and best match
                const scored = [];
                options.forEach(opt => {
                    if (!opt.value) return; // placeholder

                    const matchType = normalizeString(opt.getAttribute('data-match-type') || '');
                    const matchNumber = normalizeString(opt.getAttribute('data-match-number') || '');
                    const text = normalizeString(opt.textContent || opt.innerText || '');

                    let score = 0;

                    // Strong boost for exact number match
                    if (q.number && matchNumber === q.number) score += 60;

                    // Good boost if text contains the number
                    if (q.number && text.includes(q.number)) score += 20;

                    // Letters/type matching via canonical candidates
                    if (q.letters && candidateTypes.length > 0) {
                        for (const ct of candidateTypes) {
                            if (matchType.includes(ct)) score += 40;
                            if (text.includes(ct)) score += 25;
                            if (ct.startsWith(q.letters) || q.letters.startsWith(ct)) score += 10;
                        }
                    }

                    // Loose letter match against the displayed text
                    if (q.letters && text.includes(q.letters)) score += 10;

                    // Small boosts for startsWith matches
                    if (raw && text.startsWith(raw)) score += 8;
                    if (raw && matchType.startsWith(raw)) score += 6;

                    // If no query, give minimal score so everything remains visible
                    if (!q.letters && !q.number) score += 1;

                    // Record
                    scored.push({ opt, score, matchType, matchNumber, text });
                });

                // Decide visibility: show items with score > 0 (or all if query empty)
                scored.forEach(s => {
                    const visible = s.score > 0;
                    s.opt.hidden = !visible;
                    s.opt.style.display = visible ? '' : 'none';
                });

                // Find best-scoring candidate
                scored.sort((a, b) => b.score - a.score);
                const best = scored[0];
                const second = scored[1];

                // Selection logic: choose best if it's reasonably strong and unambiguous
                if (best && best.score > 0) {
                    const threshold = 40; // minimum score to consider auto-select
                    const gap = (second ? best.score - second.score : best.score);

                    if (best.score >= threshold && gap >= 20) {
                        // auto-select best candidate
                        matchSelector.value = best.opt.value;
                        matchSelector.dispatchEvent(new Event('change', { bubbles: true }));
                    }
                }

                const current = matchSelector.options[matchSelector.selectedIndex];
                if (current && current.hidden) {
                    matchSelector.value = '';
                }

                // Auto-select if there's exactly one visible non-placeholder match option
                const visibleMatchOptions = options.filter(opt => opt.value && !opt.hidden);
                if (visibleMatchOptions.length === 1) {
                    const only = visibleMatchOptions[0];
                    matchSelector.value = only.value;
                    matchSelector.dispatchEvent(new Event('change', { bubbles: true }));
                }
                // Sync any custom select UI visibility if present
                try { syncCustomSelectVisibility(matchSelector); } catch (e) { /* ignore if not present */ }
            }

            // Attach input listeners with debounce to avoid overfiring
            function debounce(func, wait) {
                let timeout;
                return function(...args) {
                    clearTimeout(timeout);
                    timeout = setTimeout(() => func.apply(this, args), wait);
                };
            }

            if (teamSearch) teamSearch.addEventListener('input', debounce(filterTeamOptions, 150));
            if (matchSearch) matchSearch.addEventListener('input', debounce(filterMatchOptions, 150));

            // Ensure filters run on initial load (e.g., when localStorage preselects values)
            try { filterTeamOptions(); filterMatchOptions(); } catch (e) { /* ignore */ }
            // Style match type dropdown options
            const matchOptions = matchSelector.querySelectorAll('option');
            matchOptions.forEach(option => {
                if (option.value) {
                    const matchType = option.getAttribute('data-match-type');
                    let textClass = '';
                    
                    if (matchType === 'Qualification') {
                        textClass = 'text-primary';
                    } else if (matchType === 'Playoff') {
                        textClass = 'text-danger';
                    } else if (matchType === 'Practice') {
                        textClass = 'text-success';
                    }
                    
                    if (textClass) {
                        option.classList.add(textClass, 'fw-bold');
                    }
                }
            });
            
            // Save form data for offline use (legacy)
            function saveFormDataOffline(teamId, matchId) {
                try {
                    localStorage.setItem('last_team_id', teamId);
                    localStorage.setItem('last_match_id', matchId);
                } catch (e) {
                    console.warn("Unable to save to localStorage:", e);
                }
            }

            /**
             * Autosave helpers - persist form contents periodically so a refresh
             * does not wipe the work in progress. Keys are scoped by team/match so
             * different entries do not collide.
             */
            function getAutosaveKey(teamId, matchId) {
                return `scouting_autosave_${teamId}_${matchId}`;
            }

            function saveAutosaveData() {
                try {
                    const form = document.getElementById('scouting-form');
                    if (!form) return;
                    const teamId = form.elements['team_id'] && form.elements['team_id'].value;
                    const matchId = form.elements['match_id'] && form.elements['match_id'].value;
                    if (!teamId || !matchId) return;

                    const formData = new FormData(form);
                    const obj = {};
                    formData.forEach((value, key) => {
                        const element = form.elements[key];
                        if (element && element.type === 'checkbox') {
                            obj[key] = element.checked;
                        } else if (element && element.type === 'radio') {
                            obj[key] = value; // FormData already gives selected value
                        } else if (element && element.type === 'number') {
                            obj[key] = value === '' ? 0 : Number(value);
                        } else {
                            obj[key] = value;
                        }
                    });

                    localStorage.setItem(getAutosaveKey(teamId, matchId), JSON.stringify(obj));
                    console.log('[Autosave] saved data for', teamId, matchId);
                } catch (e) {
                    console.warn('[Autosave] error saving data', e);
                }
            }

            function loadAutosaveData() {
                try {
                    const form = document.getElementById('scouting-form');
                    if (!form) return;
                    const teamId = form.elements['team_id'] && form.elements['team_id'].value;
                    const matchId = form.elements['match_id'] && form.elements['match_id'].value;
                console.log('[Autosave] attempting restore, teamId:', teamId, 'matchId:', matchId);
                if (!teamId || !matchId) {
                    console.log('[Autosave] cannot restore, missing team or match id');
                    return;
                }

                const key = getAutosaveKey(teamId, matchId);
                const saved = localStorage.getItem(key);
                if (!saved) {
                    console.log('[Autosave] no saved data for key', key);
                    return;
                }
                        if (el.type === 'checkbox') {
                            el.checked = data[k];
                            restored = true;
                        } else if (el.type === 'radio') {
                            const radios = form.querySelectorAll(`input[name="${k}"]`);
                            radios.forEach(r => { if (r.value == data[k]) r.checked = true; });
                            restored = true;
                        } else {
                            el.value = data[k];
                            restored = true;
                        }
                    });
                    if (restored) {
                        console.log('[Autosave] restored data for', teamId, matchId);
                        showToast('Restored unsaved form data from previous session', 'info');
                        // recalc points if any
                        try { updatePointsCalculation(); } catch (e) {}

                        // refresh components so values become visible immediately
                        try { initializeRatings(); } catch(e) {}
                        try { initializeCounters(); } catch(e) {}
                        form.querySelectorAll('select').forEach(el => el.dispatchEvent(new Event('change')));
                        // recalc once more now that widgets are set
                        try { updatePointsCalculation(); } catch(e) {}
                    }
                } catch (e) {
                    console.warn('[Autosave] error loading data', e);
                }
            }

            function clearAutosaveForForm() {
                try {
                    const form = document.getElementById('scouting-form');
                    if (!form) return;
                    const teamId = form.elements['team_id'] && form.elements['team_id'].value;
                    const matchId = form.elements['match_id'] && form.elements['match_id'].value;
                    if (!teamId || !matchId) return;
                    localStorage.removeItem(getAutosaveKey(teamId, matchId));
                } catch (e) { }
            }

            // Wire up autosave listeners on the currently loaded form
            function setupAutosave() {
                const form = document.getElementById('scouting-form');
                if (!form) return;
                const debounced = debounce(saveAutosaveData, 500);
                form.addEventListener('input', debounced);
                form.addEventListener('change', debounced);
            }

            // if the form already exists (server-side render) make sure it's initialized and autosaved
            try {
                const existingForm = document.getElementById('scouting-form');
                if (existingForm) {
                    console.log('[Init] existing form present on load, initializing components and autosave');
                    initializeFormComponents();
                    try { setupAutosave(); } catch(e) { console.warn('setupAutosave initial load failed', e); }
                    try { loadAutosaveData(); } catch(e) { console.warn('loadAutosaveData initial load failed', e); }
                }
            } catch(e) { /* ignore */ }

            // Manual index helper used by offline manager if automatic sync fails
            function saveToManualIndex(formData) {
                try {
                    const timestamp = new Date().toISOString();
                    const storageKey = `offline_scouting_${Date.now()}`;
                    localStorage.setItem(storageKey, JSON.stringify(formData));

                    const teamNumber = formData.team_number || formData.team_id || '';
                    const matchNumber = formData.match_number || formData.match_id || '';
                    let index = JSON.parse(localStorage.getItem('offline_scouting_index') || '[]');
                    index.push({
                        storage_key: storageKey,
                        team_number: teamNumber,
                        match_number: matchNumber,
                        timestamp: timestamp
                    });
                    localStorage.setItem('offline_scouting_index', JSON.stringify(index));
                } catch (e) {
                    console.warn('[Offline Manager] failed saving to manual index', e);
                }
            }
            
            // Load form when team and match are selected
            function loadForm() {
                const teamId = document.getElementById('team-selector').value;
                const matchId = document.getElementById('match-selector').value;
                
                if (!teamId || !matchId) return;
                
                // Show loading indicator
                const formContent = document.getElementById('form-content');
                formContent.innerHTML = `
                    <div class="text-center py-5">
                        <div class="spinner-border text-primary" role="status">
                            <span class="visually-hidden">Loading...</span>
                        </div>
                        <p class="mt-3">Loading scouting form...</p>
                    </div>
                `;
                
                // Save selected values in localStorage for offline use
                try {
                    localStorage.setItem('last_team_id', teamId);
                    localStorage.setItem('last_match_id', matchId);
                } catch (e) {
                    console.warn("Unable to save to localStorage:", e);
                }
                
                // Capture scroll/focus state before AJAX request so we can restore after DOM replacement
                const __savedScrollY = window.scrollY || 0;
                const __savedActiveId = (document.activeElement && document.activeElement.id) ? document.activeElement.id : null;

                // Check if we're offline and should use cached data
                if (!navigator.onLine && window.ScoutingOfflineManager) {
                    console.log('[Offline Mode] Loading form from cache...');
                    const offlineData = window.ScoutingOfflineManager.generateFormOffline(teamId, matchId);
                    
                    if (offlineData) {
                        // Generate form using cached data
                        loadFormOffline(offlineData, __savedScrollY, __savedActiveId);
                        return;
                    } else {
                        formContent.innerHTML = `
                            <div class="alert alert-warning">
                                <i class="fas fa-wifi-slash me-2"></i>
                                <strong>Offline Mode</strong><br>
                                Unable to load form - no cached data available.
                                Please connect to the internet to load the form for the first time.
                            </div>
                        `;
                        return;
                    }
                }

                // Create form data for the AJAX request
                const formData = new FormData();
                formData.append('team_id', teamId);
                formData.append('match_id', matchId);

                // Make AJAX request
                fetch('/scouting/form', {
                    method: 'POST',
                    body: formData,
                    headers: {
                        'X-Requested-With': 'XMLHttpRequest'
                    }
                })
                .then(response => {
                    // Check if response is OK
                    if (!response.ok) {
                        throw new Error(`HTTP ${response.status}: ${response.statusText}`);
                    }
                    
                    // Check if response is JSON
                    const contentType = response.headers.get('content-type');
                    if (!contentType || !contentType.includes('application/json')) {
                        throw new Error('Server returned non-JSON response');
                    }
                    
                    return response.json();
                })
                .then(data => {
                    if (data.success) {
                        // Update form content
                        formContent.innerHTML = data.html;
                        
                        // Cache this rendered HTML for offline use
                        if (window._scoutingFormLoadHandler && typeof window._scoutingFormLoadHandler === 'function') {
                            window._scoutingFormLoadHandler(data.team_id, data.match_id, data.html);
                        }

                        // Show warning if there was data corruption
                        if (data.warning) {
                            const warningAlert = document.createElement('div');
                            warningAlert.className = 'alert alert-warning alert-dismissible fade show mb-3';
                            warningAlert.innerHTML = `
                                <i class="fas fa-exclamation-triangle me-2"></i>
                                ${data.warning}
                                <button type="button" class="btn-close" data-bs-dismiss="alert" aria-label="Close"></button>
                            `;
                            formContent.insertBefore(warningAlert, formContent.firstChild);
                        }

                        // Update subheading (guarded)
                        try {
                            const _sub = document.getElementById('form-subheading');
                            if (_sub) {
                                _sub.textContent = `${data.team_number} - ${data.team_name} | ${data.match_type} ${data.match_number}`;
                            }
                        } catch (e) { /* ignore if DOM not ready */ }

                        // Initialize form components AFTER the form is loaded and restore previous scroll/focus
                        setTimeout(() => {
                            initializeFormComponents();

                                // wire up autosave listeners and restore any saved draft
                                try { setupAutosave(); } catch (e) { /* ignore */ }
                                try { loadAutosaveData(); } catch (e) { /* ignore */ }

                                // Ensure team-number display preference is applied after we inject/init the offline form
                                try {
                                    if (typeof window.applyTeamNumberDisplayPreference === 'function') {
                                        window.applyTeamNumberDisplayPreference();
                                    }
                                } catch (e) { /* ignore */ }

                            // final points recalculation to catch any restored values
                            try { updatePointsCalculation(); } catch (e) { /* ignore */ }

                            // Copy quick prediction (if set) into loaded form's predicted_winner input
                            try {
                                const quick = document.querySelector('input[name="predicted_winner_select"]:checked');
                                if (quick) {
                                    const val = quick.value;
                                    // Find target radios in loaded form and set
                                    const target = document.querySelector('#form-content input[name="predicted_winner"]');
                                    if (target) {
                                        // If the loaded form uses radios, set the matching one
                                        const radios = document.querySelectorAll('#form-content input[name="predicted_winner"]');
                                        radios.forEach(r => { r.checked = (r.value === val); });
                                    }
                                }
                            } catch (e) { console.warn('Could not copy quick prediction into loaded form', e); }

                            // Restore scroll position
                                try {
                                    if (typeof window.safeRestoreScroll === 'function') {
                                        window.safeRestoreScroll(__savedScrollY, { behavior: 'auto', timeout: 300 });
                                    } else {
                                        // Fallback already handled; no-op here to avoid double-restores
                                    }
                                } catch (e) {
                                    console.warn('Could not restore scroll position', e);
                                }

                            // Restore focus to previously focused element if it still exists
                            if (__savedActiveId) {
                                try {
                                    const prev = document.getElementById(__savedActiveId);
                                    if (prev && typeof prev.focus === 'function') {
                                        prev.focus({ preventScroll: true });
                                    }
                                } catch (e) {
                                    // ignore
                                }
                            }
                        }, 100);
                    } else {
                        formContent.innerHTML = `
                            <div class="alert alert-danger">
                                <i class="fas fa-exclamation-circle me-2"></i>
                                ${data.message || 'An error occurred while loading the form.'}
                            </div>
                        `;
                    }
                })
                .catch(error => {
                    console.error('Error loading form:', error);
                    
                    // If offline or network error, try to load from cache
                    if (!navigator.onLine || error.message.includes('Network') || error.message.includes('Failed to fetch')) {
                        console.log('[Offline Mode] Network error, attempting to load from cache...');
                        
                        if (window.ScoutingOfflineManager) {
                            const offlineData = window.ScoutingOfflineManager.generateFormOffline(teamId, matchId);
                            
                            if (offlineData) {
                                loadFormOffline(offlineData, __savedScrollY, __savedActiveId);
                                return;
                            }
                        }
                        
                        formContent.innerHTML = `
                            <div class="alert alert-warning">
                                <i class="fas fa-wifi-slash me-2"></i>
                                <strong>Offline Mode</strong><br>
                                Unable to connect to server and no cached data available.
                                Please connect to the internet or wait for the connection to be restored.
                            </div>
                        `;
                        return;
                    }
                    
                    let errorMessage = 'Error loading form. Please try again.';
                    
                    if (error.message.includes('HTTP 500')) {
                        errorMessage = 'Server error occurred. Please check the server logs or try again later.';
                    } else if (error.message.includes('non-JSON response')) {
                        errorMessage = 'Server returned an unexpected response. There may be a server error.';
                    }
                    
                    formContent.innerHTML = `
                        <div class="alert alert-danger">
                            <i class="fas fa-exclamation-circle me-2"></i>
                            ${errorMessage}
                            <div class="mt-2 small text-muted">
                                Technical details: ${error.message}
                            </div>
                        </div>
                    `;
                });
            }
            
            // Auto-submit when both selections are made
            function checkSelections() {
                const teamId = teamSelector.value;
                const matchId = matchSelector.value;
                
                if (teamId && matchId) {
                    // Visual feedback
                    teamSelector.classList.add('border-success');
                    matchSelector.classList.add('border-success');
                    
                    loadForm();
                } else {
                    teamSelector.classList.remove('border-success');
                    matchSelector.classList.remove('border-success');
                }
            }
            
            // Initialize from localStorage if available
            try {
                const lastTeamId = localStorage.getItem('last_team_id');
                const lastMatchId = localStorage.getItem('last_match_id');
                
                // If we have stored values and no current selection, use them
                if (lastTeamId && lastMatchId && !teamSelector.value && !matchSelector.value) {
                    teamSelector.value = lastTeamId;
                    matchSelector.value = lastMatchId;
                    if (teamSelector.value && matchSelector.value) {
                        checkSelections();
                    }
                }
            } catch (e) {
                console.warn("Unable to retrieve from localStorage:", e);
            }
            
            // Attach event listeners
            teamSelector.addEventListener('change', checkSelections);
            matchSelector.addEventListener('change', checkSelections);

            // Create custom dropdown wrappers for better styling and consistent appearance
            function createCustomSelects() {
                [teamSelector, matchSelector].forEach(function(sel) {
                    if (!sel) return;

                    // Avoid creating twice
                    if (sel.dataset.custom === '1') return;
                    sel.dataset.custom = '1';

                    // Hide native select but keep it in DOM for form submission
                    sel.style.display = 'none';

                    // Create wrapper
                    const wrapper = document.createElement('div');
                    wrapper.className = 'custom-select-wrapper';
                    wrapper.dataset.for = sel.id;

                    const toggle = document.createElement('button');
                    toggle.type = 'button';
                    toggle.className = 'custom-select-toggle btn btn-outline-secondary w-100 text-start';
                    toggle.setAttribute('aria-haspopup', 'listbox');
                    toggle.setAttribute('aria-expanded', 'false');
                    toggle.innerHTML = `<span class="custom-select-value">${sel.options[sel.selectedIndex] ? sel.options[sel.selectedIndex].text : sel.querySelector('option')?.textContent}</span><span class="chev float-end">â–¾</span>`;

                    const menu = document.createElement('div');
                    menu.className = 'custom-select-menu shadow-sm';
                    menu.setAttribute('role', 'listbox');
                    menu.style.maxHeight = '40vh';
                    menu.style.overflow = 'auto';
                    menu.style.display = 'none';

                    // Populate items and mark selected
                    Array.from(sel.options).forEach(function(opt) {
                        const item = document.createElement('div');
                        item.className = 'custom-select-item p-2';
                        item.setAttribute('role', 'option');
                        item.dataset.value = opt.value;
                        item.textContent = opt.textContent;
                        if (opt.disabled) item.classList.add('disabled');
                        if (opt.hidden) item.style.display = 'none';
                        if (!opt.value) item.classList.add('placeholder');
                        if (opt.selected) item.classList.add('selected');
                        menu.appendChild(item);
                    });

                    // Insert wrapper before native select
                    sel.parentNode.insertBefore(wrapper, sel);
                    wrapper.appendChild(toggle);
                    wrapper.appendChild(menu);

                    // Toggle menu
                    toggle.addEventListener('click', function(e) {
                        e.stopPropagation();
                        const open = menu.style.display !== 'none';
                        // close any other menus
                        document.querySelectorAll('.custom-select-menu').forEach(m => { if (m !== menu) m.style.display = 'none'; m.previousSibling && m.previousSibling.setAttribute('aria-expanded','false'); });
                        menu.style.display = open ? 'none' : 'block';
                        toggle.setAttribute('aria-expanded', (!open).toString());
                        // add open class to wrapper for styling
                        if (!open) wrapper.classList.add('open'); else wrapper.classList.remove('open');
                    });

                    // Item click
                    menu.addEventListener('click', function(e) {
                        const it = e.target.closest('.custom-select-item');
                        if (!it) return;
                        if (it.classList.contains('disabled')) return;
                        const value = it.dataset.value || '';
                        sel.value = value;
                        // sync toggle text
                        const valueLabel = it.textContent;
                        wrapper.querySelector('.custom-select-value').textContent = valueLabel;
                        // mark selected visually
                        menu.querySelectorAll('.custom-select-item').forEach(i => i.classList.remove('selected'));
                        it.classList.add('selected');
                        // close
                        menu.style.display = 'none';
                        toggle.setAttribute('aria-expanded','false');
                        wrapper.classList.remove('open');
                        sel.dispatchEvent(new Event('change', { bubbles: true }));
                    });

                    // Close on outside click
                    document.addEventListener('click', function(ev) {
                        if (!wrapper.contains(ev.target)) {
                            menu.style.display = 'none';
                            toggle.setAttribute('aria-expanded','false');
                        }
                    });

                    // Store reference for syncing
                    sel._customWrapper = wrapper;
                });
            }

            // Sync visibility of custom menu items with native select options (used by filters)
            function syncCustomSelectVisibility(sel) {
                if (!sel || !sel._customWrapper) return;
                const menu = sel._customWrapper.querySelector('.custom-select-menu');
                const items = Array.from(menu.querySelectorAll('.custom-select-item'));
                Array.from(sel.options).forEach(function(opt, idx) {
                    const it = items[idx];
                    if (!it) return;
                    it.style.display = opt.hidden ? 'none' : '';
                });
            }

            // Initialize custom selects after dom wiring
            try { createCustomSelects(); syncCustomSelectVisibility(teamSelector); syncCustomSelectVisibility(matchSelector); } catch (e) { /* ignore */ }

            // Match +/- navigation handlers: move to previous/next VISIBLE option and trigger change
            try {
                const matchDecr = document.getElementById('match-decrement');
                const matchIncr = document.getElementById('match-increment');

                function changeMatchBy(offset) {
                    if (!matchSelector) return;
                    const visibleOptions = Array.from(matchSelector.querySelectorAll('option'))
                        .filter(opt => opt.value && !opt.hidden);
                    if (visibleOptions.length === 0) return;

                    const currentValue = matchSelector.value;
                    let currentIndex = visibleOptions.findIndex(o => o.value === currentValue);
                    if (currentIndex === -1) {
                        // If nothing selected, pick first/last depending on direction
                        currentIndex = offset > 0 ? -1 : 0;
                    }

                    let newIndex = Math.min(Math.max(currentIndex + offset, 0), visibleOptions.length - 1);
                    const newOpt = visibleOptions[newIndex];
                    if (!newOpt) return;

                    matchSelector.value = newOpt.value;

                    // If a custom wrapper exists, update its display text and selected classes
                    try {
                        if (matchSelector._customWrapper) {
                            const wrapper = matchSelector._customWrapper;
                            const valueLabel = wrapper.querySelector('.custom-select-value');
                            if (valueLabel) valueLabel.textContent = newOpt.textContent;
                            const items = wrapper.querySelectorAll('.custom-select-item');
                            items.forEach(it => {
                                try { it.classList.toggle('selected', it.dataset.value === newOpt.value); } catch (e) { /* ignore */ }
                            });
                        }
                    } catch (e) { /* ignore */ }

                    matchSelector.dispatchEvent(new Event('change', { bubbles: true }));
                }

                if (matchDecr) matchDecr.addEventListener('click', function() { changeMatchBy(-1); });
                if (matchIncr) matchIncr.addEventListener('click', function() { changeMatchBy(1); });

                // Keyboard support when focus is on the match selector: left/right or +/- keys
                matchSelector.addEventListener('keydown', function(e) {
                    if (e.key === 'ArrowLeft' || e.key === '-' || e.key === 'Subtract') {
                        e.preventDefault(); changeMatchBy(-1);
                    } else if (e.key === 'ArrowRight' || e.key === '+' || e.key === 'Add') {
                        e.preventDefault(); changeMatchBy(1);
                    }
                });
            } catch (e) {
                // Non-fatal; don't break other behaviors
                console.warn('Match navigation init failed', e);
            }
        }
        
        // Initialize existing form components if present on page load
        initializeFormComponents();

        // Ensure spinning counters toggle is wired on normal page load
        try {
            setupSpinningCountersTogglePersistence();
            const spinToggle = document.getElementById('spinningCountersToggle');
            if (spinToggle) {
                const saved = localStorage.getItem('spinning_counters_enabled');
                const enabled = (saved === null) ? true : (saved === 'true' || saved === '1');
                spinToggle.checked = enabled;
                if (enabled) {
                    try { initializeSpinningCounters(); } catch (e) { console.warn('Could not initialize spinning counters on load', e); }
                } else {
                    try { teardownSpinningCounters(); } catch (e) { console.warn('Could not teardown spinning counters on load', e); }
                }
            }
        } catch (e) { console.warn('Spinning counters setup failed', e); }
        
        // ======== REAL-TIME CONFIG UPDATE LISTENERS ========
        
        // Listen for game config updates
        window.addEventListener('gameConfigUpdated', function(event) {
            const newGameConfig = event.detail;
            console.log('Game config updated in scouting form:', newGameConfig);
            
            // Show notification to user
            showConfigUpdateNotification('Game configuration has been updated due to alliance mode change.');
            
            // Optionally reload form elements or show a reload prompt
            if (confirm('The game configuration has been updated. Would you like to reload the form to use the new configuration?')) {
                window.location.reload();
            }
        });
        
        // ======== GLOBAL CONFIG RELOAD HANDLER ========
        // Listen for global config changes that require form reload
        window.addEventListener('globalConfigReload', function(event) {
            const configData = event.detail;
            console.log('Global config reload in scouting form:', configData);
            
            // Show notification
            showConfigUpdateNotification(`Configuration updated: ${configData.message}`);
            
            // Automatically reload the form content without full page reload
            reloadFormWithNewConfig();
        });
        
        // Function to reload form content with new configuration
        window.reloadFormWithNewConfig = function() {
            console.log('Reloading scouting form with new configuration...');
            
            // Get current form state
            const currentTeamId = document.getElementById('team-selector')?.value;
            const currentMatchId = document.getElementById('match-selector')?.value;
            
            if (!currentTeamId || !currentMatchId) {
                console.log('No team/match selected, skipping form reload');
                return;
            }
            
            // Capture scroll/focus state before AJAX request so we can restore after DOM replacement
            const __savedScrollY = window.scrollY || 0;
            const __savedActiveId = (document.activeElement && document.activeElement.id) ? document.activeElement.id : null;

            // Reload the form content via AJAX
            fetch(window.location.pathname, {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/x-www-form-urlencoded',
                    'X-Requested-With': 'XMLHttpRequest'
                },
                body: new URLSearchParams({
                    'team_id': currentTeamId,
                    'match_id': currentMatchId
                })
            })
            .then(response => response.json())
            .then(data => {
                if (data.success) {
                    // Replace the current form content
                    const currentFormContent = document.getElementById('form-content');
                    if (currentFormContent && data.html) {
                        currentFormContent.innerHTML = data.html;
                        
                        // Show warning if there was data corruption
                        if (data.warning) {
                            const warningAlert = document.createElement('div');
                            warningAlert.className = 'alert alert-warning alert-dismissible fade show mb-3';
                            warningAlert.innerHTML = `
                                <i class="fas fa-exclamation-triangle me-2"></i>
                                ${data.warning}
                                <button type="button" class="btn-close" data-bs-dismiss="alert" aria-label="Close"></button>
                            `;
                            currentFormContent.insertBefore(warningAlert, currentFormContent.firstChild);
                        }
                        
                        // Reinitialize form components
                        initializeFormComponents();

                        // Restore scroll position
                        try {
                            if (typeof window.safeRestoreScroll === 'function') {
                                window.safeRestoreScroll(__savedScrollY, { behavior: 'auto', timeout: 300 });
                            } else {
                                // Fallback already handled; no-op here to avoid double-restores
                            }
                        } catch (e) { /* ignore */ }

                        // Restore focus to previously focused element if it still exists
                        if (__savedActiveId) {
                            try {
                                const prev = document.getElementById(__savedActiveId);
                                if (prev && typeof prev.focus === 'function') prev.focus({ preventScroll: true });
                            } catch (e) { /* ignore */ }
                        }

                        console.log('Form reloaded successfully with new configuration');
                        showConfigUpdateNotification('Form updated with new configuration');
                    }
                } else {
                    console.error('Error reloading form:', data.message);
                    showConfigUpdateNotification('Error reloading form: ' + data.message, 'error');
                }
            })
            .catch(error => {
                console.error('Error reloading form:', error);
                showConfigUpdateNotification('Error reloading form. Please refresh the page.', 'error');
            });
        };
        
        // Listen for alliance status changes
        window.addEventListener('allianceStatusUpdated', function(event) {
            const allianceStatus = event.detail;
            console.log('Alliance status updated in scouting form:', allianceStatus);
            
            if (allianceStatus.is_active) {
                showConfigUpdateNotification(`Alliance mode activated. Now using shared configuration from ${allianceStatus.alliance_info?.alliance_name || 'alliance'}.`);
            } else {
                showConfigUpdateNotification('Alliance mode deactivated. Now using individual team configuration.');
            }
        });
        
        // Function to show config update notifications
        function showConfigUpdateNotification(message, type = 'info') {
            // Normalize type
            let normalizedType = type;
            if (!type || type === 'info' || type === 'message' || type === 'default') normalizedType = 'success';
            if (type === 'error' || type === 'err') normalizedType = 'danger';
            if (type === 'warn') normalizedType = 'warning';

            // Create a notification banner
            const notification = document.createElement('div');
            notification.className = `alert alert-${normalizedType} alert-dismissible fade show position-fixed`;
            notification.style.cssText = 'top: 20px; right: 20px; z-index: 9999; max-width: 400px;';
            notification.innerHTML = `
                <i class="fas fa-sync-alt me-2"></i>
                ${message}
                <button type="button" class="btn-close" data-bs-dismiss="alert"></button>
            `;
            
            document.body.appendChild(notification);
            
            // Auto-remove after 10 seconds
            setTimeout(() => {
                if (notification.parentNode) {
                    notification.remove();
                }
            }, 10000);
        }
    });
</script>
<link rel="stylesheet" href="/static/css/scale-ui.css">
<script src="/static/js/scale-ui.js"></script>


    <script>
    // Ensure service worker is registered at root (/sw.js) so PWABuilder and other tools can detect it
    if ('serviceWorker' in navigator) {
    navigator.serviceWorker.register('/sw.js', { scope: '/' })
            .then(reg => {
                console.log('SW root registered:', reg.scope);
                // Force update check
                reg.update();
            })
            .catch(err => console.warn('SW root registration failed:', err));
    }

    // Reposition any portalled dropdowns on scroll/resize/mousewheel to prevent visual drift
    (function addPortalledRepositionHandler(){
        let pending = false;
        function repositionPortalled() {
            pending = false;
            // Find any portalled menus
            document.querySelectorAll('.dropdown-menu.navbar-glass').forEach(menu => {
                try {
                    if (!menu.__isPortalled || !menu.__portalToggle) return;
                    positionFixedDropdown(menu.__portalToggle, menu);
                } catch(e) { /* ignore */ }
            });
        }

        function scheduleReposition() {
            if (pending) return;
            pending = true;
            window.requestAnimationFrame(repositionPortalled);
        }

        // Listen to scroll, wheel and touchmove for robust repositioning
        window.addEventListener('scroll', scheduleReposition, { passive: true });
        window.addEventListener('wheel', scheduleReposition, { passive: true });
        window.addEventListener('touchmove', scheduleReposition, { passive: true });
        window.addEventListener('resize', scheduleReposition);
    })();
    </script>

    <!-- Temporary debug shim: intercept scrollTo to capture unexpected jumps to top on tall portrait screens -->
    <script>
    (function(){
        try {
            const isPortraitTall = (window.innerHeight > window.innerWidth) && (window.innerHeight >= 900);
            if (!isPortraitTall) return; // only active for the environment where you reported the bug

            window.__scrollJumpLogs = window.__scrollJumpLogs || [];

            const origScrollTo = window.scrollTo.bind(window);
            let lastUserClickY = null;

            // Track recent clicks
            document.addEventListener('click', function(e){
                try { lastUserClickY = window.pageYOffset || document.documentElement.scrollTop || 0; } catch(e) { lastUserClickY = null; }
                // expire after short time
                setTimeout(function(){ lastUserClickY = null; }, 700);
            }, true);

            window.scrollTo = function(){
                try {
                    // Normalize arguments
                    let targetY = null;
                    if (arguments.length === 1 && typeof arguments[0] === 'object' && arguments[0] !== null) {
                        targetY = arguments[0].top != null ? arguments[0].top : (arguments[0].left != null ? arguments[0].left : null);
                    } else if (arguments.length >= 2) {
                        // scrollTo(x, y)
                        targetY = arguments[1];
                    }

                    // If a call is trying to jump to the very top (0) shortly after a user click
                    if (targetY === 0 && lastUserClickY && lastUserClickY > 50) {
                        const entry = {
                            time: Date.now(),
                            beforeY: lastUserClickY,
                            stack: (new Error('scrollTo captured')).stack,
                            args: Array.prototype.slice.call(arguments)
                        };
                        window.__scrollJumpLogs.push(entry);
                        // Print brief warning so you can observe in console if present
                        console.warn('Captured scrollTo(0) after user click â€” recorded to window.__scrollJumpLogs (first 3 chars of stack):', (entry.stack||'').slice(0,120));
                        // Still perform the original call so behavior is unchanged while debugging
                        return origScrollTo.apply(window, arguments);
                    }
                } catch (err) {
                    // ignore errors in debug shim
                }
                return origScrollTo.apply(window, arguments);
            };
            console.log('Scroll debug shim active for tall-portrait screens â€” logs available at window.__scrollJumpLogs');
        } catch(e) { /* ignore */ }
    })();
    </script>

    <!-- Extra debug instrumentation: focus, history, and hashchange logging (temporary) -->
    <script>
    (function(){
        try {
            const isPortraitTall = (window.innerHeight > window.innerWidth) && (window.innerHeight >= 900);
            if (!isPortraitTall) return;

            window.__scrollActionLogs = window.__scrollActionLogs || [];

            // Wrap the current focus implementation (don't clobber earlier production wrapper)
            const currentFocus = HTMLElement.prototype.focus;
            HTMLElement.prototype.focus = function(options){
                let beforeY = window.pageYOffset || document.documentElement.scrollTop || 0;
                try {
                    // Call whatever focus implementation is present (production wrapper or native)
                    return currentFocus.call(this, options);
                } finally {
                    // Check shortly after focus whether the page was moved to top
                    setTimeout(() => {
                        try {
                            const afterY = window.pageYOffset || document.documentElement.scrollTop || 0;
                            if (afterY === 0 && beforeY > 50) {
                                const entry = { type: 'focus', tag: this && this.tagName, beforeY, time: Date.now(), stack: (new Error('focus captured')).stack };
                                window.__scrollActionLogs.push(entry);
                                console.warn('Debug: focus caused scroll-to-top; entry recorded in window.__scrollActionLogs (focus)');
                            }
                        } catch(e) {}
                    }, 40);
                }
            };

            // Wrap history methods to detect scroll changes after push/replace
            ['pushState','replaceState'].forEach(function(name){
                try {
                    const orig = history[name];
                    history[name] = function(){
                        const beforeY = window.pageYOffset || document.documentElement.scrollTop || 0;
                        const res = orig.apply(history, arguments);
                        setTimeout(() => {
                            try {
                                const afterY = window.pageYOffset || document.documentElement.scrollTop || 0;
                                if (afterY === 0 && beforeY > 50) {
                                    const entry = { type: name, args: Array.prototype.slice.call(arguments), beforeY, time: Date.now(), stack: (new Error(name+' captured')).stack };
                                    window.__scrollActionLogs.push(entry);
                                    console.warn('Debug: history.'+name+' caused scroll-to-top; entry recorded in window.__scrollActionLogs');
                                }
                            } catch(e) {}
                        }, 30);
                        return res;
                    };
                } catch(e) { /* ignore */ }
            });

            // Hashchange listener
            window.addEventListener('hashchange', function(e){
                try {
                    const beforeY = window.__lastUserScrollBeforeHash || 0;
                    const afterY = window.pageYOffset || document.documentElement.scrollTop || 0;
                    if (afterY === 0 && beforeY > 50) {
                        const entry = { type: 'hashchange', beforeY, time: Date.now(), stack: (new Error('hashchange captured')).stack };
                        window.__scrollActionLogs.push(entry);
                        console.warn('Debug: hashchange caused scroll-to-top; entry recorded in window.__scrollActionLogs');
                    }
                } catch(e) {}
            }, true);

            // Track last scroll position before clicks (helps hashchange detection)
            document.addEventListener('click', function(){
                try { window.__lastUserScrollBeforeHash = window.pageYOffset || document.documentElement.scrollTop || 0; } catch(e) { window.__lastUserScrollBeforeHash = 0; }
                setTimeout(function(){ window.__lastUserScrollBeforeHash = 0; }, 700);
            }, true);

            console.log('Extra scroll/focus/history debug instrumentation active â€” logs available at window.__scrollActionLogs');
        } catch(e) { /* ignore */ }
    })();
    </script>

    <!-- Aggressive click watcher: detect sudden jump-to-top after clicks and restore previous scroll Y -->
    <script>
    (function(){
        try {
            const isPortraitTall = (window.innerHeight > window.innerWidth) && (window.innerHeight >= 900);
            if (!isPortraitTall) return;

            // Keep a short history of recent restores so we don't loop
            window.__recentAutoRestores = window.__recentAutoRestores || [];

            document.addEventListener('click', function(ev){
                try {
                    const beforeY = window.pageYOffset || document.documentElement.scrollTop || 0;
                    // Only watch if user was scrolled down a bit
                    if (!beforeY || beforeY <= 30) return;

                    let rafCount = 0;
                    const maxRafs = 20; // watch for a short period (~20 frames)

                    function checkFrame(){
                        rafCount++;
                        const nowY = window.pageYOffset || document.documentElement.scrollTop || 0;
                        // If it jumped to top (or nearly top) restore immediately
                        if ((nowY === 0 || Math.abs(nowY) <= 2) && beforeY > 30) {
                            // Avoid rapidly re-restoring the same Y repeatedly
                            const last = window.__recentAutoRestores[window.__recentAutoRestores.length - 1] || {};
                            if (last.y === beforeY && (Date.now() - (last.t || 0) < 1000)) {
                                return; // recently restored same position
                            }

                            // Log with stacktrace
                            const trace = (new Error('auto-restore')).stack;
                            window.__scrollJumpLogs = window.__scrollJumpLogs || [];
                            window.__scrollJumpLogs.push({ time: Date.now(), beforeY, afterY: nowY, stack: trace, cause: 'auto-restore-after-click' });
                            window.__recentAutoRestores.push({ t: Date.now(), y: beforeY });
                            if (window.__recentAutoRestores.length > 10) window.__recentAutoRestores.shift();

                            // Use safeRestoreScroll if present to cooperate with stabilizer
                            if (window.safeRestoreScroll && typeof window.safeRestoreScroll === 'function') {
                                try { window.safeRestoreScroll(beforeY, { behavior: 'auto', timeout: 300 }); } catch(e) { try { window.scrollTo(0, beforeY); } catch(e2) {} }
                            } else {
                                try { window.scrollTo(0, beforeY); } catch(e) { /* ignore */ }
                            }

                            console.warn('Auto-restored scroll position after unexpected jump-to-top (debug): restored to', beforeY);
                            return;
                        }

                        if (rafCount < maxRafs) {
                            window.requestAnimationFrame(checkFrame);
                        }
                    }

                    window.requestAnimationFrame(checkFrame);
                } catch(e) { /* ignore */ }
            }, true);

            console.log('Aggressive click watcher active on tall-portrait screens');
        } catch(e) { /* ignore */ }
    })();
    </script>

    <!-- Very aggressive polling detector: sample scrollTop rapidly after clicks and restore if it jumps to top -->
    <script>
    (function(){
        try {
            const isPortraitTall = (window.innerHeight > window.innerWidth) && (window.innerHeight >= 900);
            if (!isPortraitTall) return;

            window.__scrollJumpLogs = window.__scrollJumpLogs || [];

            document.addEventListener('click', function(){
                try {
                    const beforeY = window.pageYOffset || document.documentElement.scrollTop || 0;
                    if (!beforeY || beforeY <= 30) return;

                    let elapsed = 0;
                    const intervalMs = 12; // rapid sampling
                    const maxDuration = 700; // watch for 700ms

                    const id = setInterval(() => {
                        try {
                            elapsed += intervalMs;
                            const nowY = window.pageYOffset || document.documentElement.scrollTop || 0;
                            if ((nowY === 0 || Math.abs(nowY) <= 2) && beforeY > 30) {
                                // Capture stack
                                let stack = null;
                                try { stack = (new Error('poll-capture')).stack; } catch(e) { stack = 'no-stack'; }

                                const entry = { t: Date.now(), beforeY, afterY: nowY, stack, note: 'poll-detected' };
                                window.__scrollJumpLogs.push(entry);

                                // Avoid loops: if last restore same y recently, skip
                                const recent = window.__recentAutoRestores || [];
                                const last = recent[recent.length-1] || {};
                                if (!(last.y === beforeY && (Date.now() - (last.t||0) < 1000))) {
                                    // restore using safeRestoreScroll when available
                                    try {
                                        if (window.safeRestoreScroll && typeof window.safeRestoreScroll === 'function') {
                                            window.safeRestoreScroll(beforeY, { behavior: 'auto', timeout: 300 });
                                        } else {
                                            window.scrollTo(0, beforeY);
                                        }
                                        window.__recentAutoRestores = window.__recentAutoRestores || [];
                                        window.__recentAutoRestores.push({ t: Date.now(), y: beforeY });
                                        if (window.__recentAutoRestores.length > 10) window.__recentAutoRestores.shift();
                                    } catch(e) { /* ignore */ }
                                }

                                clearInterval(id);
                                return;
                            }
                            if (elapsed >= maxDuration) {
                                clearInterval(id);
                                return;
                            }
                        } catch(e) { clearInterval(id); }
                    }, intervalMs);
                } catch(e) { /* ignore */ }
            }, true);

            console.log('Polling scroll detector active on tall-portrait screens');
        } catch(e) { /* ignore */ }
    })();
    </script>

    <!-- Strong capture-phase anchor guard: prevents href="#" and empty/invalid anchors from jumping to top -->
    <script>
    (function(){
        'use strict';
        // This runs on all viewports (conservative safety) to block anchors that would change the hash
        // and cause browsers to scroll to top. We whitelist elements that explicitly opt-in or are
        // known interactive controls (Bootstrap toggles, ARIA buttons, data attributes).

        function isWhitelistedAnchor(anchor) {
            if (!anchor) return false;
            if (anchor.hasAttribute('data-allow-navigation') || anchor.hasAttribute('data-allow-top')) return true;
            if (anchor.hasAttribute('data-bs-toggle') || anchor.hasAttribute('data-toggle') || anchor.hasAttribute('data-bs-target') || anchor.getAttribute('role') === 'button') return true;
            // If anchor has a real href to an external location or a valid same-page target, allow
            return false;
        }

        document.body.addEventListener('click', function(e){
            try {
                const anchor = e.target && e.target.closest ? e.target.closest('a') : null;
                if (!anchor) return;

                const href = (anchor.getAttribute('href') || '').trim();

                // Allow whitelisted anchors
                if (isWhitelistedAnchor(anchor)) return;

                // Block empty, hash-only, or javascript:void anchors which often cause jumps
                if (href === '' || href === '#' || href.toLowerCase().startsWith('javascript:') || href === '#!') {
                    if (e.cancelable) e.preventDefault();
                    // Stop other handlers from acting on this anchor which might trigger navigation
                    e.stopImmediatePropagation();

                    // If anchor wraps a real control, forward the click to it
                    const inner = anchor.querySelector('button, [role="button"], input[type="button"], input[type="submit"]');
                    if (inner) {
                        try { inner.click(); } catch(err) { /* ignore */ }
                    }
                    return;
                }

                // If it's a hash targeting an element that doesn't exist, prevent the jump
                if (href.startsWith('#') && href.length > 1) {
                    const id = href.slice(1);
                    if (!document.getElementById(id)) {
                        if (e.cancelable) e.preventDefault();
                        e.stopImmediatePropagation();
                        return;
                    }
                }
            } catch(err) { /* swallow errors to avoid breaking page */ }
        }, true); // capture phase ensures we intercept before other handlers
    })();
    </script>

    <!-- Unconditional conservative click+scroll guard (production-safe):
         - Records last user click scroll position/time
         - Microtask restores scroll if it immediately jumps to top after a click
         - Overrides window.scrollTo to block programmatic scroll-to-top right after interaction
         - Whitelist by setting `window.allowScrollToTop = true` when needed
    -->
    <script>
    (function(){
        'use strict';
        try {
            window.__lastUserInteraction = window.__lastUserInteraction || { time: 0, y: 0 };

            // Capture-phase listener records last Y and timestamp for user interactions
            document.addEventListener('click', function(e){
                try {
                    var y = window.pageYOffset || document.documentElement.scrollTop || 0;
                    window.__lastUserInteraction.time = Date.now();
                    window.__lastUserInteraction.y = y;

                    // schedule a microtask to detect immediate jump-to-top caused by this click
                    Promise.resolve().then(function(){
                        try {
                            var afterY = window.pageYOffset || document.documentElement.scrollTop || 0;
                            if ((afterY === 0 || Math.abs(afterY) <= 2) && window.__lastUserInteraction.y > 30 && !window.allowScrollToTop) {
                                // restore using safeRestoreScroll if available
                                try {
                                    if (window.safeRestoreScroll && typeof window.safeRestoreScroll === 'function') {
                                        window.safeRestoreScroll(window.__lastUserInteraction.y, { behavior: 'auto', timeout: 300 });
                                    } else {
                                        window.scrollTo(0, window.__lastUserInteraction.y);
                                    }
                                } catch (err) {
                                    try { window.scrollTo(0, window.__lastUserInteraction.y); } catch(e){}
                                }
                            }
                        } catch(e) {}
                    });
                } catch(e) { /* ignore */ }
            }, true);

            // Override window.scrollTo conservatively: if a script tries to programmatically set top=0
            // shortly after a user interaction, prevent it unless explicitly allowed.
            (function(){
                var origScrollTo = window.scrollTo.bind(window);
                window.scrollTo = function(x, y){
                    try {
                        var targetY = null;
                        if (arguments.length === 1 && typeof x === 'object' && x !== null) {
                            if (x.top !== undefined) targetY = x.top;
                        } else if (arguments.length >= 2) {
                            targetY = y;
                        }

                        var now = Date.now();
                        if (targetY === 0 || targetY === 0) {
                            var last = window.__lastUserInteraction || { time: 0, y: 0 };
                            if (!window.allowScrollToTop && last && (now - last.time) < 700 && last.y > 30) {
                                // Block the jump-to-top; instead restore to last y.
                                try {
                                    if (window.safeRestoreScroll && typeof window.safeRestoreScroll === 'function') {
                                        window.safeRestoreScroll(last.y, { behavior: 'auto', timeout: 300 });
                                    } else {
                                        origScrollTo(0, last.y);
                                    }
                                } catch (e) {
                                    try { origScrollTo(0, last.y); } catch(_) {}
                                }
                                return;
                            }
                        }
                    } catch (e) { /* ignore */ }
                    return origScrollTo.apply(window, arguments);
                };
            })();

            console.log('Conservative click+scroll guard initialized');
        } catch(e) { console.warn('click+scroll guard init failed', e); }
    })();
    </script>

    
    

    
    

    
    

    
    <div class="modal fade" id="chatModal" tabindex="-1" aria-labelledby="chatModalLabel" aria-hidden="true">
      <div class="modal-dialog modal-lg modal-dialog-centered">
        <div class="modal-content">
          <div class="modal-header">
            <h5 class="modal-title" id="chatModalLabel">Chat</h5>
            <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
          </div>
          <div class="modal-body">
            <ul class="nav nav-tabs mb-3" id="chatTab" role="tablist">
              <li class="nav-item" role="presentation">
                <button class="nav-link active" id="dm-tab" data-bs-toggle="tab" data-bs-target="#dmTabPane" type="button" role="tab">DMs</button>
              </li>
                            <li class="nav-item" role="presentation">
                                <button class="nav-link" id="assistant-tab" data-bs-toggle="tab" data-bs-target="#assistantTabPane" type="button" role="tab">Support</button>
                            </li>
              <li class="nav-item" role="presentation">
                <button class="nav-link" id="group-tab" data-bs-toggle="tab" data-bs-target="#groupTabPane" type="button" role="tab">Groups</button>
              </li>
            </ul>
            <div class="tab-content" id="chatTabContent">
              <div class="tab-pane fade show active" id="dmTabPane" role="tabpanel">
                <div id="dmChatContainer" class="chat-container"></div>
                <div class="input-group mt-3">
                  <input type="text" class="form-control" id="dmChatInput" placeholder="Type a message...">
                  <button class="btn btn-primary" id="dmSendBtn">Send</button>
                </div>
              </div>
              <div class="tab-pane fade" id="assistantTabPane" role="tabpanel">
                                <div id="assistantChatContainer" class="chat-container"></div>
                                <div class="input-group mt-3">
                                    <input type="text" class="form-control" id="assistantChatInput" placeholder="Ask for help...">
                                    <button class="btn btn-primary" id="assistantSendBtn">Send</button>
                                </div>
              </div>
              <div class="tab-pane fade" id="groupTabPane" role="tabpanel">
                <div class="mb-2">
                  <input type="text" id="groupNameInput" class="form-control form-control-sm d-inline-block w-200" placeholder="Group name">
                  <button class="btn btn-outline-primary btn-sm" id="joinGroupBtn">Join/Create Group</button>
                  <select id="currentGroupSelect" class="form-select form-select-sm d-inline-block w-200"></select>
                  <button class="btn btn-outline-danger btn-sm" id="leaveGroupBtn">Leave Group</button>
                </div>
                <div id="groupChatContainer" class="chat-container"></div>
                <div class="input-group mt-3">
                  <input type="text" class="form-control" id="groupChatInput" placeholder="Type a group message...">
                  <button class="btn btn-primary" id="groupSendBtn">Send</button>
                </div>
              </div>
            </div>
          </div>
        </div>
      </div>
    </div>

    <script>
    document.addEventListener('DOMContentLoaded', function() {
            // Global safeguard: prevent anchors with href="#" from changing the hash/scroll
            // Many templates use href="#" for buttons; on some mobile browsers tapping these
            // will jump the page to the top. Intercept and prevent default for those anchors.
            document.body.addEventListener('click', function(e) {
                try {
                    // Find nearest anchor element
                    const anchor = e.target.closest && e.target.closest('a');
                    if (!anchor) return;

                    const href = (anchor.getAttribute('href') || '').trim();

                    // Allow anchors used by Bootstrap or ARIA controls to function
                    const isToggle = anchor.hasAttribute('data-bs-toggle') || anchor.hasAttribute('data-toggle') || anchor.getAttribute('role') === 'button' || anchor.hasAttribute('data-bs-target') || anchor.hasAttribute('aria-controls');

                    // If href is empty, just '#', javascript:void, or '#' plus whitespace, prevent navigation
                    const isHarmlessHash = href === '#' || href === '' || href.toLowerCase().startsWith('javascript:') || href === '#!';

                    if (isHarmlessHash && !isToggle) {
                        // Prevent default navigation which can jump to top on mobile browsers
                        e.preventDefault();

                        // If the anchor is being used purely as a wrapper for a control element,
                        // forward the click to the first interactive child so existing handlers run.
                        const innerBtn = anchor.querySelector('button, [role="button"], input[type="button"], input[type="submit"]');
                        if (innerBtn) {
                            // Dispatch a click event on the inner control in a safe way
                            try { innerBtn.click(); } catch (err) { /* ignore */ }
                        }
                        return;
                    }

                    // If this is an href to an internal hash targeting an element on the page,
                    // allow default behavior only if the element exists; otherwise prevent jump
                    if (href.startsWith('#') && href.length > 1 && !isToggle) {
                        const targetEl = document.getElementById(href.slice(1));
                        if (!targetEl) {
                            e.preventDefault();
                            return;
                        }
                    }
                } catch (err) {
                    // swallow errors to avoid breaking pages
                    console.warn('anchor click safeguard error', err);
                }
            }, { passive: false });

            // Additional narrow-screen capture-phase guard: record scrollY before clicks
            // and prevent stray href="#" clicks from jumping the page on small viewports.
            document.addEventListener('click', function(e) {
                try {
                                // Only active for narrow screens or tall portrait devices where this is a frequent problem
                                const isPortraitTallNow = (window.innerHeight > window.innerWidth) && (window.innerHeight >= 900);
                                if (window.innerWidth > 900 && !isPortraitTallNow) return;

                    // Snapshot before click
                    const beforeY = window.pageYOffset || document.documentElement.scrollTop || 0;

                    const anchor = e.target.closest && e.target.closest('a');
                    if (!anchor) return;

                    const href = (anchor.getAttribute('href') || '').trim();
                    if (!href || href === '#' || href.toLowerCase().startsWith('javascript:')) {
                        // Prevent default navigation
                        if (e.cancelable) e.preventDefault();
                        // After a microtask, if scroll moved to top, restore it
                        Promise.resolve().then(() => {
                            const afterY = window.pageYOffset || document.documentElement.scrollTop || 0;
                            if (afterY === 0 && beforeY > 50) {
                                // Use safeRestoreScroll if available to cooperate with stabilizer
                                if (window.safeRestoreScroll && typeof window.safeRestoreScroll === 'function') {
                                    window.safeRestoreScroll(beforeY, { behavior: 'auto', timeout: 300 });
                                } else {
                                    try { window.scrollTo(0, beforeY); } catch(e){}
                                }
                            }
                        });
                        return;
                    }
                } catch (err) {
                    console.warn('narrow-screen click guard error', err);
                }
            }, { passive: false, capture: true });

            // Prevent focus() calls from scrolling the page in browsers that don't support
            // the preventScroll option reliably. We wrap focus to provide preventScroll when possible.
            (function(){
                try {
                    const origFocus = HTMLElement.prototype.focus;
                    HTMLElement.prototype.focus = function(options){
                        if (typeof options === 'object' && options && options.preventScroll) {
                            // browser supports options, call through
                            return origFocus.call(this, options);
                        }
                        // Try to call with preventScroll option first
                        try {
                            return origFocus.call(this, { preventScroll: true });
                        } catch(e) {
                            // Fallback to original focus without scrolling
                            try { return origFocus.call(this); } catch(e2) { /* ignore */ }
                        }
                    };
                } catch (e) { /* ignore if prototype can't be modified */ }
            })();

            // Page-scoped defensive guard: prevent immediate scroll-to-top calls
            // caused by third-party code right after a user click inside the scouting form.
            // We now implement this by listening for clicks inside the form and, when
            // necessary, using the global safeRestoreScroll helper to perform intended
            // restores. The stabilizer suppression flag is handled by safeRestoreScroll.
            try {
                if (window.location.pathname && window.location.pathname.includes('/scouting/form')) {
                    // When user clicks in the form content, mark the element so any
                    // legitimate restore code can route through safeRestoreScroll.
                    document.body.addEventListener('click', function(ev) {
                        try {
                            const inForm = ev.target && ev.target.closest && (ev.target.closest('#form-content') || ev.target.closest('#scouting-form'));
                            if (inForm) {
                                // Attach a short-lived marker to the document that other code
                                // can check before calling window.scrollTo directly. Prefer
                                // to call safeRestoreScroll instead of calling window.scrollTo.
                                window.__recentlyClickedInScoutingForm = Date.now();
                                window.setTimeout(function(){ try { delete window.__recentlyClickedInScoutingForm; } catch(e){} }, 350);
                            }
                        } catch (e) { /* ignore */ }
                    }, true);
                }
            } catch (e) { /* ignore overall errors */ }
        // Open modal on button click


        // Socket.IO setup
        // Attempt to use WebSocket transport first; if handshake fails (400) or
        // websockets are not supported by the hosting environment (for example
        // when behind a proxy that doesn't forward upgrades or when using a
        // WSGI server without websocket support), fall back to long-polling.
        if (!window.socket) {
            try {
                // Try websocket + polling (prefer websocket)
                window.socket = io({ transports: ['websocket', 'polling'] });
            } catch (e) {
                // Fallback to polling-only if the above throws synchronously
                window.socket = io({ transports: ['polling'] });
            }

            // If connect errors occur (for example a 400 during websocket
            // handshake), attempt a reconnect using polling-only transport.
            window.socket.on && window.socket.on('connect_error', function(err) {
                try {
                    // If the current transport attempted websocket and failed,
                    // force polling-only reconnect.
                    if (window.socket && window.socket.io && window.socket.io.opts && Array.isArray(window.socket.io.opts.transports)) {
                        const cur = window.socket.io.opts.transports;
                        if (cur.includes('websocket') && !cur.includes('polling')) {
                            // Switch to polling-only and reconnect
                            window.socket.io.opts.transports = ['polling'];
                            try { window.socket.disconnect(); } catch(e) {}
                            try { window.socket.connect(); } catch(e) {}
                        } else if (cur.includes('websocket') && cur.includes('polling')) {
                            // If both were permitted but connection error still occurred,
                            // prefer polling-only retry to avoid repeated 400s.
                            window.socket.io.opts.transports = ['polling'];
                            try { window.socket.disconnect(); } catch(e) {}
                            try { window.socket.connect(); } catch(e) {}
                        }
                    }
                } catch (e) { /* swallow */ }
            });
        }
        const socket = window.socket;
    const recipientSelect = document.getElementById('assistantChatRecipient');
    const chatContainer = document.getElementById('assistantChatContainer');
    const chatInput = document.getElementById('assistantChatInput');
    const sendBtn = document.getElementById('assistantSendBtn');
    const deleteBtn = document.getElementById('assistantDeleteHistoryBtn');
        let allMessages = [];
        let currentRecipient = 'assistant';
        let usernameLoaded = false;

        // Fetch user list for chat (including 'assistant')
        function fetchRecipients() {
            // If the recipient select isn't present on this page, no-op
            if (!recipientSelect) return Promise.resolve();
            return fetch('/assistant/chat-users')
                .then(r => r.json())
                .then(data => {
                    recipientSelect.innerHTML = '';
                    // Always add assistant as an option
                    const optAssistant = document.createElement('option');
                    optAssistant.value = 'assistant';
                    optAssistant.textContent = 'Assistant';
                    recipientSelect.appendChild(optAssistant);
                    // Add users
                    data.users.forEach(u => {
                        const opt = document.createElement('option');
                        opt.value = u;
                        opt.textContent = u + (u === data.current_user ? ' (You)' : '');
                        recipientSelect.appendChild(opt);
                    });
                });
        }

        if (recipientSelect) {
            recipientSelect.addEventListener('change', function() {
                currentRecipient = this.value;
                renderHistory(allMessages);
            });
        }

        function renderMessage(msg) {
            // Only show messages for the selected recipient
            if ((currentRecipient === 'assistant' && msg.recipient === 'assistant') ||
                (msg.sender === currentRecipient && msg.recipient === window.currentUsername) ||
                (msg.sender === window.currentUsername && msg.recipient === currentRecipient)) {
                const div = document.createElement('div');
                div.className = 'mb-2';
                div.innerHTML = `<strong>${msg.sender}:</strong> <span>${msg.text}</span> <span class="text-muted time-text">${new Date(msg.timestamp).toLocaleTimeString()}</span>`;
                chatContainer.appendChild(div);
                chatContainer.scrollTop = chatContainer.scrollHeight;
            }
        }

        function renderHistory(history) {
            chatContainer.innerHTML = '';
            allMessages = history;
            history.forEach(renderMessage);
        }

        socket.on('assistant_chat_message', function(msg) {
            allMessages.push(msg);
            renderMessage(msg);
        });
        socket.on('assistant_chat_history', renderHistory);

        if (sendBtn) {
            sendBtn.disabled = true;

            sendBtn.addEventListener('click', function() {
                const text = (chatInput && chatInput.value || '').trim();
                if (text && window.currentUsername) {
                    console.log('Sending:', { text, recipient: currentRecipient, sender: window.currentUsername });
                    socket.emit('assistant_chat_message', { text, recipient: currentRecipient, sender: window.currentUsername });
                    if (chatInput) chatInput.value = '';
                } else {
                    alert('Username not loaded yet. Please wait.');
                }
            });
            if (chatInput) {
                chatInput.addEventListener('keypress', function(e) {
                    if (e.key === 'Enter') sendBtn.click();
                });
            }
        }

        if (deleteBtn) {
            deleteBtn.addEventListener('click', function() {
                fetch('/assistant/delete-chat-history', { method: 'POST' })
                    .then(r => r.json())
                    .then(data => {
                        if (data.success) {
                            if (chatContainer) chatContainer.innerHTML = '';
                        } else {
                            alert(data.message || 'Failed to delete chat history');
                        }
                    });
            });
        }

        // On modal open, fetch recipients and chat history
        const openBtn = document.getElementById('openAssistantModalBtn');
        if (openBtn) {
            openBtn.addEventListener('click', function() {
                const modal = new bootstrap.Modal(document.getElementById('assistantModal'));
                modal.show();
                fetchRecipients();
                if (window.socket) {
                    window.socket.emit('assistant_chat_history_request');
                }
            });
        }

        // Get current username for filtering
        fetch('/assistant/chat-users').then(r => r.json()).then(data => {
            window.currentUsername = data.current_user;
            sendBtn.disabled = false;
            usernameLoaded = true;
            console.log('Current username loaded:', window.currentUsername);
        });

        // Open chat modal from navbar
        const openChatModalNav = document.getElementById('openChatModalNav');
        if (openChatModalNav) {
            openChatModalNav.addEventListener('click', function(e) {
                e.preventDefault();
                const modal = new bootstrap.Modal(document.getElementById('chatModal'));
                modal.show();
            });
        }
        // Assistant tab logic: send message to /assistant/ask and display response
        const assistantSendBtn = document.getElementById('assistantSendBtn');
        const assistantChatInput = document.getElementById('assistantChatInput');
        const assistantChatContainer = document.getElementById('assistantChatContainer');
        assistantSendBtn.addEventListener('click', async function() {
            const question = assistantChatInput.value.trim();
            if (!question) return;
            // Show user message
            const userDiv = document.createElement('div');
            userDiv.className = 'mb-2';
            userDiv.innerHTML = `<strong>You:</strong> <span>${question}</span>`;
            assistantChatContainer.appendChild(userDiv);
            assistantChatInput.value = '';
            assistantChatContainer.scrollTop = assistantChatContainer.scrollHeight;
            // Send to backend
            const response = await fetch('/assistant/ask', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ question })
            });
            const data = await response.json();
            const botDiv = document.createElement('div');
            botDiv.className = 'mb-2';
            botDiv.innerHTML = `<strong>Assistant:</strong> <span>${data.text || data.message || 'No response.'}</span>`;
            assistantChatContainer.appendChild(botDiv);
            assistantChatContainer.scrollTop = assistantChatContainer.scrollHeight;
        });
        assistantChatInput.addEventListener('keypress', function(e) {
            if (e.key === 'Enter') assistantSendBtn.click();
        });
        // ... (existing DM and group chat logic would go here) ...
    });
    </script>
    <script>
    // Robust sidebar layout adjustment helper. This actively measures the
    // sidebar and applies inline margins to `main`/`footer`/`.topbar` so the
    // page content is pushed over reliably on desktop breakpoints.
    (function(){
        'use strict';

        function applySidebarMargin() {
            try {
                var sb = document.getElementById('appSidebar');
                var mainEl = document.querySelector('main');
                var footerEl = document.querySelector('footer.footer');
                var topbar = document.querySelector('.topbar');
                if (!sb || !mainEl) return;

                var rect = sb.getBoundingClientRect();
                var sbWidth = Math.round(rect.width || 0);
                var isDesktop = window.innerWidth >= 992;

                if (isDesktop && sbWidth > 8) {
                    // Ensure the body has the desktop layout classes
                    if (!document.body.classList.contains('with-sidebar')) document.body.classList.add('with-sidebar');
                    if (!document.body.classList.contains('topbar-fixed')) document.body.classList.add('topbar-fixed');

                    // Remove mobile overlay state if present
                    if (document.body.classList.contains('sidebar-open')) document.body.classList.remove('sidebar-open');

                    // Update the CSS variable so stylesheet rules that use
                    // var(--sidebar-width) (including !important rules) update.
                    try { document.body.style.setProperty('--sidebar-width', sbWidth + 'px'); } catch (e) {}

                    // Apply inline margins (use !important priority as a fallback
                    // for any stubborn stylesheet rules). Prefer calling the CSS
                    // variable above so the majority of rules update automatically.
                    try { mainEl.style.setProperty('margin-left', sbWidth + 'px', 'important'); } catch(e){ mainEl.style.marginLeft = sbWidth + 'px'; }
                    if (footerEl) {
                        try { footerEl.style.setProperty('margin-left', sbWidth + 'px', 'important'); } catch(e){ footerEl.style.marginLeft = sbWidth + 'px'; }
                    }
                    if (topbar) {
                        try { topbar.style.setProperty('margin-left', sbWidth + 'px', 'important'); } catch(e){ topbar.style.marginLeft = sbWidth + 'px'; }
                        try { topbar.style.setProperty('width', 'calc(100% - ' + sbWidth + 'px)', 'important'); } catch(e){ topbar.style.width = 'calc(100% - ' + sbWidth + 'px)'; }
                    }
                } else {
                    // Clear inline margins on small screens
                    try { document.body.style.removeProperty('--sidebar-width'); } catch(e) {}
                    try { mainEl.style.removeProperty('margin-left'); } catch(e){ mainEl.style.marginLeft = ''; }
                    if (footerEl) { try { footerEl.style.removeProperty('margin-left'); } catch(e){ footerEl.style.marginLeft = ''; } }
                    if (topbar) {
                        try { topbar.style.removeProperty('margin-left'); } catch(e){ topbar.style.marginLeft = ''; }
                        try { topbar.style.removeProperty('width'); } catch(e){ topbar.style.width = ''; }
                    }
                }
            } catch (e) {
                // swallow
            }
        }

        // Debounce helper
        var resizeTimer = null;
        function onResizeDebounced() {
            if (resizeTimer) clearTimeout(resizeTimer);
            resizeTimer = setTimeout(function(){ applySidebarMargin(); }, 120);
        }

        // Expose the helper globally so other scripts (and toggle handlers)
        // can force a layout recalculation immediately when needed.
        try { window.applySidebarMargin = applySidebarMargin; } catch (e) { /* ignore */ }

        // Adjust on key events
        document.addEventListener('DOMContentLoaded', function(){
            // dispatch sidebar toggle so other listeners update
            try { document.dispatchEvent(new CustomEvent('obsidian:sidebar:toggled')); } catch(e){}
            applySidebarMargin();
        });
        window.addEventListener('load', applySidebarMargin);
        window.addEventListener('resize', onResizeDebounced);

        // When sidebar is toggled by our UI, adjust layout
        document.addEventListener('obsidian:sidebar:toggled', applySidebarMargin);

        // Ensure we react to sidebar transition end (open/close animations)
        try {
            var sbEl = document.getElementById('appSidebar');
            if (sbEl) sbEl.addEventListener('transitionend', function(ev){
                // Only respond to transform/width transitions
                if (!ev || !ev.propertyName) { applySidebarMargin(); return; }
                if (['transform','width','left','margin-left'].indexOf(ev.propertyName) !== -1) applySidebarMargin();
            });
        } catch (e) { /* ignore */ }

        // Also periodically attempt to fix layout for pages that modify classes
        // after load (guarded to avoid perf issues).
        var tries = 0;
        var maxTries = 8;
        var poll = setInterval(function(){
            try { applySidebarMargin(); } catch(e){}
            tries += 1;
            if (tries >= maxTries) clearInterval(poll);
        }, 250);
    })();
    </script>
    <script>
    document.addEventListener('DOMContentLoaded', function() {
        // Expose current user's username to client-side scripts for local checks
        try {
            window.CURRENT_USERNAME = null;
        } catch (e) { window.CURRENT_USERNAME = null; }

        async function updateChatUnreadBadge() {
            try {
                const resp = await fetch('/chat/state');
                const data = await resp.json();
                const badge = document.getElementById('chatUnreadBadge');
                const userDot = document.getElementById('userChatDot');
                const userUnreadItem = document.getElementById('userDropdownUnreadItem');
                const openUnreadChatLink = document.getElementById('openUnreadChatLink');
                const notifBellBadge = document.getElementById('notificationsBadge');
                const notifList = document.getElementById('notificationsList');

                // Update chat badge in nav/user menu
                if (badge) {
                    if (data.unreadCount && data.unreadCount > 0) {
                        badge.textContent = data.unreadCount;
                        badge.style.display = '';
                        if (userDot) userDot.style.display = '';
                        if (userUnreadItem) userUnreadItem.style.display = '';
                        if (openUnreadChatLink && data.lastSource) {
                            try {
                                const s = encodeURIComponent(JSON.stringify(data.lastSource));
                                openUnreadChatLink.href = `/chat?focus=${s}`;
                            } catch(e) {}
                        } else if (openUnreadChatLink) {
                            openUnreadChatLink.href = `/chat`;
                        }
                    } else {
                        badge.style.display = 'none';
                        if (userDot) userDot.style.display = 'none';
                        if (userUnreadItem) userUnreadItem.style.display = 'none';
                    }
                }

                // Update topbar notifications bell and list
                if (notifBellBadge) {
                    if (data.unreadCount && data.unreadCount > 0) {
                        notifBellBadge.textContent = data.unreadCount;
                        notifBellBadge.style.display = '';
                    } else {
                        notifBellBadge.style.display = 'none';
                        notifBellBadge.textContent = '';
                    }
                }

                if (notifList) {
                    // Remove any existing chat-unread marker item
                    const existing = document.getElementById('notif-chat-unread-item');
                    if (existing) existing.remove();

                    if (data.unreadCount && data.unreadCount > 0) {
                        // Build a top entry for unread chat messages
                        let title = '';
                        let detail = '';
                        let focusParam = '';
                        if (data.lastSource && data.lastSource.type === 'dm' && data.lastSource.id) {
                            title = `${data.unreadCount} unread chat message(s)`;
                            detail = `Most recent: ${data.lastSource.id}`;
                            try {
                                focusParam = `?focus=${encodeURIComponent(JSON.stringify(data.lastSource))}`;
                            } catch(e) { focusParam = ''; }
                        } else {
                            title = `${data.unreadCount} unread chat message(s)`;
                            detail = 'Open chat to view messages';
                        }

                        const chatItemHtml = `
                            <a id="notif-chat-unread-item" href="/chat${focusParam}" class="list-group-item list-group-item-action d-flex align-items-start">
                                <div class="me-2">
                                    <i class="fas fa-comment-alt fa-lg text-primary"></i>
                                </div>
                                <div class="flex-fill">
                                    <div class="fw-bold">${escapeHtml(title)}</div>
                                    <div class="small text-muted">${escapeHtml(detail)}</div>
                                </div>
                                <div class="ms-2 text-end">
                                    <small class="text-muted">Open</small>
                                </div>
                            </a>
                        `;

                        // Prepend so chat notifications appear at top
                        notifList.insertAdjacentHTML('afterbegin', chatItemHtml);
                    }
                }
            } catch (e) {
                // Ignore fetch errors silently
            }
        }

        // small helper to escape text for inserted HTML
        function escapeHtml(text) {
            const div = document.createElement('div');
            div.textContent = text;
            return div.innerHTML;
        }
        // Update on page load
        updateChatUnreadBadge();
        // Poll every 5 seconds so notifications stay timely across all pages
        setInterval(updateChatUnreadBadge, 5000);
        // Listen for real-time DM and group chat events if socket.io is available
        if (window.socket) {
            window.socket.on('dm_message', function(msg) {
                try {
                    // Ignore messages authored by the current client (prevents sender receiving their own mobile send as unread)
                    if (window.CURRENT_USERNAME && msg && msg.sender && String(msg.sender).toLowerCase() === String(window.CURRENT_USERNAME).toLowerCase()) {
                        return;
                    }
                } catch (e) {
                    // If any error, fall through and handle as before
                }
                if (!window.location.pathname.startsWith('/chat')) {
                    // include source info so dropdown can open focused DM
                    fetch('/chat/increment-unread', {method: 'POST', headers: {'Content-Type':'application/json'}, body: JSON.stringify({lastSource: {type: 'dm', id: msg.sender}})}).then(updateChatUnreadBadge);
                }
            });
            // Group chat messages are disabled in this build; no-op.
        }
        // When chat page/modal is opened, reset unread count
        const chatNavItem = document.getElementById('chatNavItem');
        if (chatNavItem) {
            chatNavItem.addEventListener('click', function() {
                // When user opens chat, clear unread and any source pointer
                fetch('/chat/reset-unread', {method: 'POST'}).then(updateChatUnreadBadge);
            });
        }
        
        // ======== REAL-TIME CONFIG SYNC ========
        
        // Store current config data globally
        window.currentConfig = {
            game_config: null,
            pit_config: null,
            alliance_status: null
        };
        
        // Track if this is the initial config load
        window.configInitialized = false;
        
        // Function to fetch current configuration
        function fetchCurrentConfig() {
            return fetch('/alliances/scouting/config/current')
                .then(response => response.json())
                .then(data => {
                    window.currentConfig = data;
                    return data;
                })
                .catch(error => {
                    console.warn('Could not fetch current config:', error);
                    return null;
                });
        }
        
        // Function to update alliance status in navigation
        function updateAllianceStatusNav(allianceStatus, allianceInfo) {
            const allianceStatusElement = document.querySelector('[data-alliance-status]');
            if (allianceStatusElement) {
                if (allianceStatus) {
                    allianceStatusElement.innerHTML = `
                        <div class="d-flex align-items-center">
                            <i class="fas fa-users me-1"></i>Alliance Mode Active
                            <small class="text-muted ms-1">
                                ${allianceInfo ? allianceInfo.alliance_name : ''}
                            </small>
                        </div>
                    `;
                    allianceStatusElement.style.display = 'block';
                } else {
                    allianceStatusElement.style.display = 'none';
                }
            }
        }
        
        // Function to show auto-sync notifications
        function showAutoSyncNotification(message, type = 'info') {
            // Normalize type values to Bootstrap alert classes
            let normalizedType = type;
            if (!type || type === 'info' || type === 'message' || type === 'default') {
                normalizedType = 'success';
            } else if (type === 'error' || type === 'err') {
                normalizedType = 'danger';
            } else if (type === 'warn') {
                normalizedType = 'warning';
            }

            // Create a notification banner
            const notification = document.createElement('div');
            notification.className = `alert alert-${normalizedType} alert-dismissible fade show position-fixed`;
            notification.style.cssText = 'top: 80px; right: 20px; z-index: 9999; max-width: 400px; box-shadow: 0 4px 8px rgba(0,0,0,0.2);';
            
            const iconMap = {
                'info': 'fas fa-sync-alt',
                'success': 'fas fa-check-circle',
                'warning': 'fas fa-exclamation-triangle',
                'danger': 'fas fa-times-circle'
            };

            const icon = iconMap[normalizedType] || iconMap['info'];
            
            notification.innerHTML = `
                <div class="d-flex align-items-center">
                    <i class="${icon} me-2"></i>
                    <div>
                        <strong>Alliance Auto-Sync</strong><br>
                        <small>${message}</small>
                    </div>
                </div>
                <button type="button" class="btn-close" data-bs-dismiss="alert"></button>
            `;
            
            document.body.appendChild(notification);
            
            // Auto-remove after 8 seconds
            setTimeout(() => {
                if (notification.parentNode) {
                    const bsAlert = new bootstrap.Alert(notification);
                    bsAlert.close();
                }
            }, 8000);
        }
        
        // Function to trigger config refresh events for other scripts
        function triggerConfigUpdate(configData, isInitialLoad = false) {
            // Only dispatch update events if this is not the initial load
            if (!isInitialLoad && window.configInitialized) {
                // Dispatch custom events that other pages can listen to
                window.dispatchEvent(new CustomEvent('configUpdated', {
                    detail: configData
                }));
                
                window.dispatchEvent(new CustomEvent('gameConfigUpdated', {
                    detail: configData.game_config
                }));
                
                window.dispatchEvent(new CustomEvent('pitConfigUpdated', {
                    detail: configData.pit_config
                }));
                
                window.dispatchEvent(new CustomEvent('allianceStatusUpdated', {
                    detail: configData.alliance_status
                }));
                
                console.log('Config update events dispatched for real change');
            } else {
                console.log('Skipping config update events for initial load');
            }
        }
        
        // Socket.IO listeners for real-time updates
        if (window.socket) {
            // Auto-join team room when connected
            window.socket.on('connect', function() {
                console.log('Socket.IO connected, joining team room...');
                // always join team room if a team number exists (allow 0)
                

                // also join alliance room if alliance mode is active
                fetchCurrentConfig().then(cfg => {
                    if (cfg && cfg.alliance_status && cfg.alliance_status.alliance_id) {
                        window.socket.emit('join_alliance_room', { alliance_id: cfg.alliance_status.alliance_id });
                        console.log('Joined alliance room', cfg.alliance_status.alliance_id);
                    }
                }).catch(() => {});
            });
            
            // Handle team room join confirmation
            window.socket.on('joined_team_room', function(data) {
                console.log('Successfully joined team room:', data.team_number);
            });
            
            // Listen for alliance mode toggles
            window.socket.on('alliance_mode_toggled', function(data) {
                console.log('Alliance mode toggled:', data);
                window.currentConfig.game_config = data.effective_game_config;
                window.currentConfig.pit_config = data.effective_pit_config;
                window.currentConfig.alliance_status = {
                    is_active: data.alliance_status,
                    alliance_info: data.alliance_info,
                    team_number: data.team_number
                };
                
                triggerConfigUpdate(window.currentConfig, false); // This is a real update
                updateAllianceStatusNav(data.alliance_status, data.alliance_info);
            });
            
            // Listen for general config updates
            window.socket.on('config_updated', function(data) {
                console.log('Config updated:', data);
                window.currentConfig.game_config = data.effective_game_config;
                window.currentConfig.pit_config = data.effective_pit_config;
                window.currentConfig.alliance_status = {
                    is_active: data.alliance_status,
                    alliance_info: data.alliance_info,
                    team_number: data.team_number
                };
                
                triggerConfigUpdate(window.currentConfig, false); // This is a real update
            });
            
            // Listen for alliance status changes (for nav bar updates)
            window.socket.on('alliance_status_changed', function(data) {
                console.log('Alliance status changed:', data);
                updateAllianceStatusNav(data.alliance_status, data.alliance_info);
            });
            
            // ======== EVENT CHANGE HANDLER ========
            // Listen for current event changes to update UI immediately sitewide
            window.socket.on('event_changed', function(data) {
                console.log('Current event changed:', data);
                
                // Update local config cache with new event code
                if (window.currentConfig && window.currentConfig.game_config) {
                    window.currentConfig.game_config.current_event_code = data.new_event_code;
                }
                
                // Dispatch custom event so pages can react
                window.dispatchEvent(new CustomEvent('eventChanged', {
                    detail: {
                        old_event_code: data.old_event_code,
                        new_event_code: data.new_event_code,
                        event_name: data.event_name,
                        scouting_team: data.scouting_team
                    }
                }));
                
                // Show notification and reload the page to reflect the change
                showGlobalConfigNotification('Current event changed to: ' + data.event_name, 'event_change');
                
                // Reload the page after a brief delay to let the notification show
                setTimeout(function() {
                    window.location.reload();
                }, 1500);
            });
            
            // ======== ALLIANCE AUTO-SYNC HANDLERS ========
            // helper used by both websocket and polling
            function handleAllianceDataSyncAuto(data) {
                console.log('Received auto-sync data from Team', data.from_team);
                // acknowledge by whichever channel is available
                if (window.socket) {
                    window.socket.emit('alliance_auto_sync_received', data);
                } else {
                    // fall back to HTTP ack
                    if (data.sync_id) {
                        fetch(`/alliances/scouting/sync/ack/${data.sync_id}`, {method: 'POST'}).catch(()=>{});
                    }
                }
                
                // Show notification about incoming data (less verbose for periodic syncs)
                if (data.type === 'periodic_sync') {
                    const totalEntries = data.scouting_data.length + data.pit_data.length + (data.qualitative_data ? data.qualitative_data.length : 0);
                    if (totalEntries > 0) {
                        console.log(`Periodic sync: Received ${totalEntries} entries from Team ${data.from_team}`);
                        if (totalEntries >= 5) {
                            showAutoSyncNotification(`Periodic sync: ${totalEntries} entries from Team ${data.from_team}`, 'info');
                        }
                    }
                } else {
                    if (data.scouting_data.length > 0) {
                        showAutoSyncNotification(`Received ${data.scouting_data.length} scouting entries from Team ${data.from_team} (${data.alliance_name})`);
                    }
                    if (data.pit_data.length > 0) {
                        showAutoSyncNotification(`Received ${data.pit_data.length} pit scouting entries from Team ${data.from_team} (${data.alliance_name})`);
                    }
                    if (data.qualitative_data && data.qualitative_data.length > 0) {
                        showAutoSyncNotification(`Received ${data.qualitative_data.length} qualitative entries from Team ${data.from_team} (${data.alliance_name})`);
                    }
                }
            }

            // Listen for automatic alliance data sync via socket
            window.socket.on('alliance_data_sync_auto', handleAllianceDataSyncAuto);

            // Polling fallback for unreliable websocket
            function pollAllianceSyncs() {
                fetch('/alliances/scouting/sync/pending')
                    .then(r => r.json())
                    .then(resp => {
                        if (resp && resp.syncs) {
                            resp.syncs.forEach(s => {
                                handleAllianceDataSyncAuto(s);
                                // acknowledge via HTTP (socket ack already done above)
                                fetch(`/alliances/scouting/sync/ack/${s.sync_id}`, {method: 'POST'}).catch(()=>{});
                            });
                        }
                    }).catch(()=>{});
            }
            // start polling every 15s
            setInterval(pollAllianceSyncs, 15000);
            pollAllianceSyncs();
            
            // Listen for auto-sync completion confirmations
            window.socket.on('alliance_auto_sync_complete', function(data) {
                console.log('Auto-sync completed:', data);
                if (data.imported_count > 0) {
                    if (data.type === 'periodic_sync') {
                        // Less verbose for periodic syncs
                        console.log(`Periodic sync completed: imported ${data.imported_count} entries from Team ${data.from_team}`);
                        // Only show notification for substantial periodic imports
                        if (data.imported_count >= 3) {
                            showAutoSyncNotification(`Periodic sync: imported ${data.imported_count} entries from Team ${data.from_team}`, 'success');
                        }
                    } else {
                        // Full notification for manual syncs
                        showAutoSyncNotification(`Successfully imported ${data.imported_count} entries from Team ${data.from_team} (${data.alliance_name})`, 'success');
                    }
                    
                    // Refresh current page if it's data-related
                    if (window.location.pathname.includes('/scouting') || 
                        window.location.pathname.includes('/analysis') || 
                        window.location.pathname.includes('/pit-scouting')) {
                        setTimeout(() => {
                            window.location.reload();
                        }, 2000);
                    }
                }
            });

            // ======== HTTP POLLING FALLBACK ========
            let allianceSyncPoller = null;
            function handleSyncPayload(data) {
                // reuse same logic as the socket handler
                console.log('Handling sync payload via polling', data.from_team);
                // send ack immediately
                if (data.sync_id) {
                    fetch('/alliances/scouting/sync/ack/' + data.sync_id, {method: 'POST'}).catch(() => {});
                }
                // show notifications similar to socket
                if (data.scouting_data.length) {
                    showAutoSyncNotification(`${data.scouting_data.length} scouting entries from Team ${data.from_team} (${data.alliance_name})`);
                }
                if (data.pit_data.length) {
                    showAutoSyncNotification(`${data.pit_data.length} pit entries from Team ${data.from_team} (${data.alliance_name})`);
                }
                if (data.qualitative_data && data.qualitative_data.length) {
                    showAutoSyncNotification(`${data.qualitative_data.length} qualitative entries from Team ${data.from_team} (${data.alliance_name})`);
                }
                // optionally reload
                if (window.location.pathname.includes('/scouting') ||
                    window.location.pathname.includes('/analysis') ||
                    window.location.pathname.includes('/pit-scouting')) {
                    setTimeout(() => window.location.reload(), 2000);
                }
            }

            function pollForSyncs() {
                fetch('/alliances/scouting/sync/pending')
                    .then(r => r.json())
                    .then(d => {
                        if (d.syncs && d.syncs.length) {
                            d.syncs.forEach(handleSyncPayload);
                        }
                    }).catch(() => {});
            }

            window.socket.on('connect', function() {
                // stop polling when socket returns
                if (allianceSyncPoller) { clearInterval(allianceSyncPoller); allianceSyncPoller = null; }
            });
            window.socket.on('disconnect', function() {
                // start polling every 30 seconds when disconnected
                if (!allianceSyncPoller) {
                    allianceSyncPoller = setInterval(pollForSyncs, 30000);
                }
            });
            
            // ======== GLOBAL CONFIG CHANGE HANDLER ========
            // Listen for global config changes that affect ALL pages
            window.socket.on('global_config_changed', function(data) {
                console.log('Global config changed:', data);
                
                // Update local config cache
                window.currentConfig.game_config = data.effective_game_config;
                window.currentConfig.pit_config = data.effective_pit_config;
                window.currentConfig.alliance_status = {
                    is_active: data.alliance_status,
                    alliance_info: data.alliance_info,
                    team_number: data.team_number
                };
                
                // Trigger all config update events
                triggerConfigUpdate(window.currentConfig, false);
                updateAllianceStatusNav(data.alliance_status, data.alliance_info);
                
                // Dispatch global reload events for pages to refresh their content
                window.dispatchEvent(new CustomEvent('globalConfigReload', {
                    detail: {
                        type: data.type,
                        message: data.message,
                        game_config: data.effective_game_config,
                        pit_config: data.effective_pit_config,
                        alliance_status: data.alliance_status,
                        alliance_info: data.alliance_info,
                        timestamp: data.timestamp
                    }
                }));
                
                // Show user notification
                if (data.message) {
                    showGlobalConfigNotification(data.message, data.type);
                }
                
                // Reload page content that depends on config
                reloadConfigDependentContent();
            });
        }
        
        // ======== GLOBAL CONFIG MANAGEMENT FUNCTIONS ========
        
        // Function to show global config notifications
        function showGlobalConfigNotification(message, type) {
            // Create or update notification element
            let notificationId = 'global-config-notification';
            let existingNotification = document.getElementById(notificationId);
            
            if (existingNotification) {
                existingNotification.remove();
            }
            
            const notificationHtml = `
                <div id="${notificationId}" class="alert alert-info alert-dismissible fade show global-config-notification">
                    <div class="d-flex align-items-center">
                        <i class="fas fa-sync-alt me-2"></i>
                        <div>
                            <strong>Configuration Updated</strong><br>
                            <small>${message}</small>
                        </div>
                    </div>
                    <button type="button" class="btn-close" data-bs-dismiss="alert"></button>
                </div>
            `;
            
            document.body.insertAdjacentHTML('beforeend', notificationHtml);
            
            // Auto-remove after 5 seconds
            setTimeout(() => {
                const notification = document.getElementById(notificationId);
                if (notification) {
                    notification.remove();
                }
            }, 5000);
        }
        
        // Function to reload config-dependent content on the current page
        function reloadConfigDependentContent() {
            const currentPath = window.location.pathname;
            
            // Page-specific content reloading
            if (currentPath.includes('/scouting/form')) {
                reloadScoutingFormContent();
            } else if (currentPath.includes('/graphs') || currentPath.includes('/analytics')) {
                reloadAnalyticsContent();
            } else if (currentPath.includes('/pit_scouting')) {
                reloadPitScoutingContent();
            } else if (currentPath.includes('/matches')) {
                reloadMatchesContent();
            } else if (currentPath.includes('/alliances')) {
                reloadAlliancesContent();
            }
            
            // Reload any generic config-dependent elements
            reloadGenericConfigElements();
        }
        
        // Page-specific reload functions
        function reloadScoutingFormContent() {
            // Trigger form reload if function exists
            if (typeof window.reloadFormWithNewConfig === 'function') {
                window.reloadFormWithNewConfig();
            }
        }
        
        function reloadAnalyticsContent() {
            // Trigger analytics reload if function exists
            if (typeof window.reloadAnalyticsWithNewConfig === 'function') {
                window.reloadAnalyticsWithNewConfig();
            }
        }
        
        function reloadPitScoutingContent() {
            // Trigger pit scouting reload if function exists
            if (typeof window.reloadPitScoutingWithNewConfig === 'function') {
                window.reloadPitScoutingWithNewConfig();
            }
        }
        
        function reloadMatchesContent() {
            // Trigger matches reload if function exists
            if (typeof window.reloadMatchesWithNewConfig === 'function') {
                window.reloadMatchesWithNewConfig();
            }
        }
        
        function reloadAlliancesContent() {
            // Trigger alliances reload if function exists
            if (typeof window.reloadAlliancesWithNewConfig === 'function') {
                window.reloadAlliancesWithNewConfig();
            }
        }
        
        function reloadGenericConfigElements() {
            // Reload any elements with data-config-dependent attribute
            const configElements = document.querySelectorAll('[data-config-dependent]');
            configElements.forEach(element => {
                const reloadType = element.getAttribute('data-config-dependent');
                if (reloadType === 'game' && window.currentConfig.game_config) {
                    // Trigger custom event for this element
                    element.dispatchEvent(new CustomEvent('configReload', {
                        detail: { config: window.currentConfig.game_config, type: 'game' }
                    }));
                } else if (reloadType === 'pit' && window.currentConfig.pit_config) {
                    element.dispatchEvent(new CustomEvent('configReload', {
                        detail: { config: window.currentConfig.pit_config, type: 'pit' }
                    }));
                }
            });
        }
        
        // Initial config fetch on page load
        fetchCurrentConfig().then(configData => {
            if (configData) {
                triggerConfigUpdate(configData, true); // Mark as initial load
                updateAllianceStatusNav(
                    configData.alliance_status.is_active, 
                    configData.alliance_status.alliance_info
                );
                window.configInitialized = true; // Mark config as initialized
            }
        });
        
        // Navbar improvements
        function initNavbarImprovements() {
            // Sync chat badges between desktop and mobile
            function syncChatBadges() {
                const desktopBadge = document.getElementById('chatUnreadBadge');
                const mobileBadge = document.getElementById('chatUnreadBadgeMobile');
                
                if (desktopBadge && mobileBadge) {
                    // Sync visibility
                    if (desktopBadge.style.display !== 'none') {
                        mobileBadge.style.display = 'inline';
                        mobileBadge.textContent = desktopBadge.textContent;
                    } else {
                        mobileBadge.style.display = 'none';
                    }
                }
            }
            
            // Observe changes to desktop badge
            const desktopBadge = document.getElementById('chatUnreadBadge');
            if (desktopBadge) {
                const observer = new MutationObserver(syncChatBadges);
                observer.observe(desktopBadge, {
                    attributes: true,
                    childList: true,
                    subtree: true
                });
                syncChatBadges(); // Initial sync
            }
            
            // Enhanced dropdown animations
            const dropdowns = document.querySelectorAll('.dropdown-menu-animated');
            dropdowns.forEach(dropdown => {
                const parent = dropdown.closest('.dropdown');
                if (parent) {
                    parent.addEventListener('show.bs.dropdown', function() {
                        dropdown.classList.add('show');
                    });
                    
                    parent.addEventListener('hide.bs.dropdown', function() {
                        dropdown.classList.remove('show');
                    });
                }
            });
            
            // Close mobile menu when clicking outside
            document.addEventListener('click', function(e) {
                const navbarCollapse = document.getElementById('navbarMain');
                const navbarToggler = document.querySelector('.navbar-toggler');
                
                if (navbarCollapse && navbarCollapse.classList.contains('show')) {
                    if (!navbarCollapse.contains(e.target) && !navbarToggler.contains(e.target)) {
                        const collapse = new bootstrap.Collapse(navbarCollapse, {
                            toggle: false
                        });
                        collapse.hide();
                    }
                }
            });
            
            // Smooth scroll for navbar brand
            const navbarBrand = document.querySelector('.navbar-brand');
            if (navbarBrand) {
                navbarBrand.addEventListener('click', function(e) {
                    // Only smooth scroll if we're on the same page
                    const href = this.getAttribute('href');
                    if (href && window.location.pathname === href) {
                        e.preventDefault();
                        try {
                            if (window.safeRestoreScroll && typeof window.safeRestoreScroll === 'function') {
                                // Route through global helper so it coordinates with mobile stabilizer
                                window.safeRestoreScroll(0, { behavior: 'smooth', timeout: 200 });
                            } else {
                                // Fallback for older pages/environments
                                window.scrollTo({ top: 0, behavior: 'smooth' });
                            }
                        } catch (err) {
                            try { window.scrollTo({ top: 0, behavior: 'smooth' }); } catch(e) {}
                        }
                    }
                });
            }
            
            // Active state management for single-page navigation
            function updateActiveNavItem() {
                const currentPath = window.location.pathname;
                const navLinks = document.querySelectorAll('.nav-link, .dropdown-item');
                
                navLinks.forEach(link => {
                    const href = link.getAttribute('href');
                    if (href === currentPath) {
                        link.classList.add('active');
                        
                        // Also activate parent dropdown if this is a dropdown item
                        const parentDropdown = link.closest('.dropdown');
                        if (parentDropdown) {
                            const parentToggle = parentDropdown.querySelector('.dropdown-toggle');
                            if (parentToggle) {
                                parentToggle.classList.add('active');
                            }
                        }
                    }
                });
            }
            
            // Call on initial load
            updateActiveNavItem();
        }
        
        // Initialize navbar improvements
        initNavbarImprovements();

            // Clear unread button (x) handler
            const clearUnreadBtn = document.getElementById('clearUnreadBtn');
            if (clearUnreadBtn) {
                clearUnreadBtn.addEventListener('click', function() {
                    fetch('/chat/reset-unread', { method: 'POST' })
                        .then(r => {
                            if (r.ok) {
                                // hide dot and this button
                                const dot = document.getElementById('userChatDot');
                                if (dot) dot.style.display = 'none';
                                clearUnreadBtn.style.display = 'none';
                                const unreadItem = document.getElementById('userDropdownUnreadItem');
                                if (unreadItem) unreadItem.style.display = 'none';
                                const chatBadge = document.getElementById('chatUnreadBadge');
                                if (chatBadge) { chatBadge.style.display = 'none'; chatBadge.textContent = '' }
                            }
                        }).catch(e => console.warn('Failed to clear unread', e));
                });
            }
        
        // Initialize search functionality
        initSearchFunctionality();
        
        // Reinitialize on window resize (when responsive classes change)
        window.addEventListener('resize', function() {
            clearTimeout(window.searchResizeTimeout);
            window.searchResizeTimeout = setTimeout(initSearchFunctionality, 250);
        });
        
        // Initialize dropdown positioning fix
        initDropdownPositioning();

        // Ensure card dropdowns use static display to avoid Popper placement flicker.
        // This forces Bootstrap not to attach Popper for dropdowns inside `.card` and
        // lets our positioning/portal logic run deterministically.
        (function enforceStaticDisplayForCardDropdowns(){
            try {
                document.querySelectorAll('.card .dropdown-toggle[data-bs-toggle="dropdown"]').forEach(btn => {
                    if (!btn.hasAttribute('data-bs-display')) btn.setAttribute('data-bs-display', 'static');
                    // Recreate Bootstrap Dropdown instance so it respects the new option
                    try {
                        if (window.bootstrap && window.bootstrap.Dropdown) {
                            const inst = window.bootstrap.Dropdown.getInstance(btn);
                            if (inst && typeof inst.dispose === 'function') inst.dispose();
                            window.bootstrap.Dropdown.getOrCreateInstance(btn);
                        }
                    } catch (e) { /* non-fatal */ }
                });
            } catch (e) { console.warn('Failed to enforce static display for card dropdowns', e); }
        })();

        // Mobile: ensure touch devices reliably open dropdown toggles
        (function ensureTouchDropdowns(){
            if (!('ontouchstart' in window)) return; // only for touch devices
            document.querySelectorAll('.dropdown-toggle').forEach(btn => {
                // Avoid attaching multiple times
                if (btn.__touchHandlerAttached) return;
                btn.__touchHandlerAttached = true;

                btn.addEventListener('touchend', function(e){
                    // If bootstrap dropdown exists, toggle explicitly â€” this avoids issues when clicks are swallowed by overlays
                    try {
                        if (window.bootstrap && window.bootstrap.Dropdown) {
                            const inst = window.bootstrap.Dropdown.getOrCreateInstance(btn);
                            // If menu not shown, show it; otherwise let Bootstrap handle hide on outside tap
                            const menu = btn.closest('.dropdown')?.querySelector('.dropdown-menu');
                            if (menu && !menu.classList.contains('show')) {
                                inst.show();
                                e.preventDefault();
                            }
                        }
                    } catch (err) {
                        // Fallback to click to let browser/Bootstrap handle it
                        try { btn.click(); } catch(e){}
                    }
                }, { passive: false });
            });
        })();
        
        // Global fallback for dropdowns inside navbar/topbar **and** cards
        // Portals card dropdowns on `show.bs.dropdown` to avoid Popper flicker/incorrect initial placement.
        document.addEventListener('show.bs.dropdown', function(event) {
            const dropdown = event.target.closest('.navbar .dropdown, .topbar .dropdown, .card .dropdown');
            if (!dropdown) return;

            // Only portal navbar/topbar on desktop (keep mobile behavior unchanged)
            const isNavbarTopbar = dropdown.matches('.navbar .dropdown') || dropdown.matches('.topbar .dropdown');
            if (isNavbarTopbar && window.innerWidth < 992) return;

            const toggle = dropdown.querySelector('.dropdown-toggle');
            const menu = dropdown.querySelector('.dropdown-menu');
            if (!toggle || !menu) return;

            // If already portalled, ensure position will be updated shortly
            if (menu.__portalPlaceholder) {
                setTimeout(() => positionFixedDropdown(toggle, menu), 1);
                return;
            }

            // Create placeholder in original location and move menu to <body>
            const placeholder = document.createComment('dropdown-portal-placeholder');
            menu.parentNode.insertBefore(placeholder, menu);
            menu.__portalPlaceholder = placeholder;
            menu.__portalToggle = toggle;
            menu.__isPortalled = true;

            menu.classList.add('navbar-glass');
            document.body.appendChild(menu);

            // Hide while we re-position to avoid visible Popper flicker
            const prevVis = menu.style.visibility;
            menu.style.visibility = 'hidden';
            menu.style.position = 'fixed';
            menu.style.zIndex = '2147483647';
            menu.style.willChange = 'transform, top, left';

            // Destroy any Popper instance so it won't overwrite our fixed placement
            try {
                if (window.bootstrap && window.bootstrap.Dropdown) {
                    const bsInstance = window.bootstrap.Dropdown.getInstance(toggle) || window.bootstrap.Dropdown.getOrCreateInstance(toggle);
                    if (bsInstance && bsInstance._popper) {
                        try { bsInstance._popper.destroy(); } catch(e){}
                        try { bsInstance._popper = null; } catch(e){}
                    }
                }
            } catch (e) { /* ignore */ }

            // Position and then restore visibility
            setTimeout(() => {
                try {
                    positionFixedDropdown(toggle, menu);
                    menu.style.removeProperty('transform');
                    menu.style.removeProperty('inset');
                    menu.style.removeProperty('right');
                } catch (e) { /* ignore */ }
                try { menu.style.visibility = prevVis || ''; } catch(e){}
            }, 1);
        });

        // Also catch the shown event as a final fallback
        document.addEventListener('shown.bs.dropdown', function(event) {
            const dropdown = event.target.closest('.navbar .dropdown, .topbar .dropdown');
            if (dropdown && window.innerWidth >= 992) {
                const toggle = dropdown.querySelector('.dropdown-toggle');
                const menu = dropdown.querySelector('.dropdown-menu');
                if (toggle && menu) {
                    positionFixedDropdown(toggle, menu);
                }
            }
        });

        // Mobile fallback: ensure dropdowns stay within the viewport and don't drop off screen
        document.addEventListener('shown.bs.dropdown', function(event) {
            try {
                const dropdown = event.target.closest('.navbar .dropdown, .topbar .dropdown');
                if (!dropdown) return;
                if (window.innerWidth >= 992) return; // desktop handled elsewhere
                const menu = dropdown.querySelector('.dropdown-menu');
                if (!menu) return;

                // Allow time for Popper or bootstrap to set dimensions/transform, then clamp
                setTimeout(() => {
                    try {
                        const rect = menu.getBoundingClientRect();
                        const gap = 8; // px from screen edge
                        // If menu extends beyond right edge, anchor it to the right with a small gap
                        if (rect.right > (window.innerWidth - gap)) {
                            menu.style.left = 'auto';
                            menu.style.right = gap + 'px';
                            menu.style.transform = 'none';
                        }
                        // If menu extends beyond left edge, anchor to left with small gap
                        if (rect.left < gap) {
                            menu.style.left = gap + 'px';
                            menu.style.right = 'auto';
                            menu.style.transform = 'none';
                        }
                        // Force a reasonable max width so it doesn't exceed viewport
                        menu.style.maxWidth = 'calc(100vw - ' + (gap * 2) + 'px)';
                        // Ensure it's visible and accessible
                        menu.style.overflow = 'auto';
                        menu.style.overflowY = 'auto';
                        menu.style.position = 'absolute';
                    } catch (e) { /* ignore */ }
                }, 8);
            } catch(e) { /* ignore */ }
        });

        // Portal navbar/topbar **and card** dropdowns to body so they stay fixed during page scroll
        // - Navbar/topbar portalling is still desktop-only; card dropdowns are portalled on all viewports
        document.addEventListener('shown.bs.dropdown', function(event) {
            try {
                const dropdown = event.target.closest('.navbar .dropdown, .topbar .dropdown, .card .dropdown');
                if (!dropdown) return;

                // For navbar/topbar, only portal on desktop; allow card dropdowns on any viewport
                if ((dropdown.closest('.navbar') || dropdown.closest('.topbar')) && window.innerWidth < 992) return;

                const menu = dropdown.querySelector('.dropdown-menu');
                const toggle = dropdown.querySelector('.dropdown-toggle');
                if (!menu || !toggle) return;

                // If already portalled, just reposition
                if (menu.__portalPlaceholder) {
                    positionFixedDropdown(toggle, menu);
                    return;
                }

                // Create placeholder in original location
                const placeholder = document.createComment('dropdown-portal-placeholder');
                menu.parentNode.insertBefore(placeholder, menu);
                // Move menu to body and mark as navbar-glass so it matches app surfaces and is found by restoration logic
                menu.classList.add('navbar-glass');
                document.body.appendChild(menu);
                // Mark placeholder and toggle for restoration/repositioning
                menu.__portalPlaceholder = placeholder;
                // Keep a reference to the toggle so we can reposition on scroll/resize
                menu.__portalToggle = toggle;
                menu.__isPortalled = true;

                // Make it fixed and position it (use a very-high z-index to escape stacking contexts)
                menu.style.position = 'fixed';
                menu.style.zIndex = '2147483647';
                menu.style.willChange = 'transform, top, left';
                positionFixedDropdown(toggle, menu);

                // Destroy Popper instance if Bootstrap created one so it won't overwrite our fixed positioning on scroll
                try {
                    if (window.bootstrap && window.bootstrap.Dropdown) {
                        const bsInstance = window.bootstrap.Dropdown.getInstance(toggle);
                        if (bsInstance && bsInstance._popper) {
                            try { bsInstance._popper.destroy(); } catch(e){}
                            try { bsInstance._popper = null; } catch(e){}
                        }
                    }
                } catch (e) { /* ignore */ }

                // Remove any Popper-applied transform/inset so the menu remains where we placed it
                try {
                    menu.style.removeProperty('transform');
                    menu.style.removeProperty('inset');
                    menu.style.removeProperty('right');
                } catch (e) {}
            } catch (e) {
                // ignore portal errors
                console.warn('Dropdown portal error', e);
            }
        });

        // Restore portalled dropdowns when they hide
        document.addEventListener('hide.bs.dropdown', function(event) {
            try {
                const dropdown = event.target.closest('.navbar .dropdown, .topbar .dropdown');
                if (!dropdown) return;
                // The menu might already be in the dropdown or on body. Prefer any portalled menu (navbar-glass) first.
                const menu = document.querySelector('.dropdown-menu.navbar-glass') || dropdown.querySelector('.dropdown-menu') || document.querySelector('.dropdown-menu[aria-expanded="true"]');
                if (!menu) return;
                const placeholder = menu.__portalPlaceholder;
                if (!placeholder) return;

                // Grab the toggle so we can re-create Popper/Dropdown instances later
                const toggle = dropdown.querySelector('.dropdown-toggle');

                // Restore into original parent before the placeholder
                if (placeholder.parentNode) {
                    placeholder.parentNode.insertBefore(menu, placeholder);
                    placeholder.parentNode.removeChild(placeholder);
                } else {
                    // Fallback: append back to dropdown
                    dropdown.appendChild(menu);
                }

                // Remove glass class when restoring
                menu.classList.remove('navbar-glass');

                // Clean up styles
                menu.style.position = '';
                menu.style.left = '';
                menu.style.top = '';
                menu.style.right = '';
                menu.style.bottom = '';
                menu.style.zIndex = '';
                menu.style.willChange = '';
                // Reinitialize Popper/Dropdown for normal future behavior (if toggle exists)
                try {
                    if (toggle && window.bootstrap && window.bootstrap.Dropdown) {
                        // If there's an existing instance, dispose then re-create
                        const existing = window.bootstrap.Dropdown.getInstance(toggle);
                        if (existing && typeof existing.dispose === 'function') existing.dispose();
                        window.bootstrap.Dropdown.getOrCreateInstance(toggle);
                    }
                } catch (e) { /* ignore */ }

                // Normalize ARIA and classes so toggle and menu remain in a consistent hidden state
                try {
                    if (toggle) {
                        toggle.setAttribute('aria-expanded', 'false');
                        toggle.classList.remove('show');
                    }
                    if (menu) {
                        // Remove visibility classes and any Popper styles that might keep it visible
                        menu.classList.remove('show');
                        menu.style.removeProperty('transform');
                        menu.style.removeProperty('inset');
                        menu.removeAttribute('data-popper-placement');

                        // Clear any sizing/overflow we may have set while positioning
                        menu.style.removeProperty('max-height');
                        menu.style.removeProperty('maxWidth');
                        menu.style.removeProperty('overflow');
                        menu.style.removeProperty('overflow-y');

                        // Ensure it's not forcing display or opacity
                        menu.style.display = '';
                        try { menu.style.opacity = ''; } catch(e){}

                        // mark as just hidden to avoid immediate re-open from stray click events
                        try { menu.__justHidden = Date.now(); } catch(e){}
                    }
                } catch (e) { /* ignore */ }

                // Clean up portalling metadata
                try { delete menu.__portalPlaceholder; } catch(e) {}
                try { delete menu.__portalToggle; } catch(e) {}
                try { delete menu.__isPortalled; } catch(e) {}
            } catch (e) {
                console.warn('Dropdown portal restore error', e);
            }
        });
    });

    // Watch for dropdown `show` mutations inside `.card` and force-portalling/positioning
    (function observeCardDropdownShows(){
        try {
            const observer = new MutationObserver(mutations => {
                mutations.forEach(m => {
                    if (m.attributeName !== 'class') return;
                    const menu = m.target;
                    if (!menu || !menu.classList.contains('dropdown-menu')) return;
                    const cardAncestor = menu.closest('.card');
                    if (!cardAncestor) return; // only care about card dropdowns

                    if (menu.classList.contains('show')) {
                        const dropdown = menu.closest('.dropdown');
                        const toggle = dropdown?.querySelector('.dropdown-toggle');
                        if (!toggle) return;

                        // Ensure Bootstrap won't attempt Popper placement for card dropdowns
                        try { toggle.setAttribute('data-bs-display', 'static'); } catch(e){}

                        // Portal if not already
                        if (!menu.__portalPlaceholder) {
                            try {
                                const placeholder = document.createComment('dropdown-portal-placeholder');
                                menu.parentNode.insertBefore(placeholder, menu);
                                menu.__portalPlaceholder = placeholder;
                                menu.__portalToggle = toggle;
                                menu.__isPortalled = true;
                                menu.classList.add('navbar-glass');
                                document.body.appendChild(menu);
                            } catch (e) { /* ignore */ }
                        }

                        // Hide while we compute position to avoid visible fallback positioning
                        const prevVis = menu.style.visibility;
                        menu.style.visibility = 'hidden';
                        menu.style.position = 'fixed';
                        menu.style.zIndex = '2147483647';

                        // Position on next tick
                        setTimeout(() => {
                            try {
                                positionFixedDropdown(toggle, menu);
                                menu.style.removeProperty('transform');
                                menu.style.removeProperty('inset');
                                menu.style.visibility = prevVis || '';
                                menu.style.opacity = '1';
                            } catch (e) { /* ignore */ }
                        }, 1);
                    }
                });
            });

            document.querySelectorAll('.card .dropdown .dropdown-menu').forEach(menu => {
                observer.observe(menu, { attributes: true, attributeFilter: ['class'] });
            });
        } catch (e) { console.warn('card dropdown observer failed', e); }
    })();

    // Fix dropdown positioning for navbar dropdowns
    function initDropdownPositioning() {
        // Only apply to desktop navbar dropdowns
        function handleDropdownPositioning() {
        if (window.innerWidth >= 992) {
            // Include both .navbar and topbar dropdowns so topbar menus are positioned fixed
            const navbarDropdowns = document.querySelectorAll('.navbar .dropdown, .topbar .dropdown');

            navbarDropdowns.forEach(dropdown => {
                const toggle = dropdown.querySelector('.dropdown-toggle');
                const menu = dropdown.querySelector('.dropdown-menu');
                    
                    if (toggle && menu) {
                        // Remove any existing event listeners to prevent duplicates
                        toggle.removeEventListener('click', handleDropdownClick);
                        dropdown.removeEventListener('show.bs.dropdown', handleDropdownShow);
                        dropdown.removeEventListener('shown.bs.dropdown', handleDropdownShown);
                        
                        // Add event listeners
                        toggle.addEventListener('click', handleDropdownClick);
                        dropdown.addEventListener('show.bs.dropdown', handleDropdownShow);
                        dropdown.addEventListener('shown.bs.dropdown', handleDropdownShown);
                        
                        function handleDropdownClick(e) {
                            // If the menu was just hidden (restored) very recently, ignore this click to
                            // avoid a double-toggle situation caused by reparenting and Popper timing.
                            try {
                                const now = Date.now();
                                if (menu && menu.__justHidden && (now - menu.__justHidden) < 400) {
                                    // Clear the flag and bail
                                    delete menu.__justHidden;
                                    return;
                                }
                            } catch (e) {}

                            setTimeout(() => {
                                if (menu.classList.contains('show')) {
                                    positionFixedDropdown(toggle, menu);
                                }
                            }, 5);
                        }
                        
                        function handleDropdownShow() {
                            setTimeout(() => {
                                if (menu.classList.contains('show')) {
                                    positionFixedDropdown(toggle, menu);
                                }
                            }, 5);
                        }
                        
                        function handleDropdownShown() {
                            positionFixedDropdown(toggle, menu);
                        }
                    }
                });
            } else {
                // Reset any fixed positioning for mobile
                const navbarDropdowns = document.querySelectorAll('.navbar .dropdown-menu, .topbar .dropdown-menu');
                navbarDropdowns.forEach(menu => {
                    menu.style.position = '';
                    menu.style.left = '';
                    menu.style.top = '';
                    menu.style.right = '';
                    menu.style.bottom = '';
                });
            }
        }
        
        handleDropdownPositioning();
        
        // Reposition on window resize
        window.addEventListener('resize', function() {
            handleDropdownPositioning();
            
            if (window.innerWidth >= 992) {
                const visibleDropdowns = document.querySelectorAll('.navbar .dropdown-menu.show');
                visibleDropdowns.forEach(menu => {
                    const toggle = menu.closest('.dropdown').querySelector('.dropdown-toggle');
                    if (toggle) {
                        positionFixedDropdown(toggle, menu);
                    }
                });
            }
        });
    }
    
    function positionFixedDropdown(toggle, menu) {
        if (window.innerWidth < 992) return; // Don't apply to mobile
        
        // Skip positioning for user dropdown on iOS - let CSS handle it
        const isIOS = /iPad|iPhone|iPod/.test(navigator.userAgent) || 
                      (navigator.platform === 'MacIntel' && navigator.maxTouchPoints > 1);
        const isUserDropdown = menu.id === 'userMenu';
        if (isIOS && isUserDropdown) {
            // On iOS, use absolute positioning for user dropdown (handled by CSS)
            menu.style.position = 'absolute';
            menu.style.zIndex = '1060';
            return;
        }
        
        // Force the menu to be visible but transparent to measure it
        menu.style.opacity = '0';
        menu.style.display = 'block';
        menu.style.position = 'fixed';
        menu.style.zIndex = '1060';
        
        const toggleRect = toggle.getBoundingClientRect();
        const menuRect = menu.getBoundingClientRect();
        const viewportWidth = window.innerWidth;
        const viewportHeight = window.innerHeight;
        
        // More generous edge buffers
        const edgeBuffer = 15;
        const bottomBuffer = 20;
        
        // Calculate initial position
        let left = toggleRect.left;
        let top = toggleRect.bottom + 8; // 8px margin-top
        
        // Check if this is a right-aligned dropdown (like user menu)
        const isRightAligned = menu.classList.contains('dropdown-menu-end');
        
        if (isRightAligned) {
            // For right-aligned dropdowns, align to the right edge of the button
            left = toggleRect.right - menuRect.width;
            
            // Enhanced right edge detection - check if dropdown would go off screen
            if (left + menuRect.width > viewportWidth - edgeBuffer) {
                // Move dropdown further left to stay on screen
                left = viewportWidth - menuRect.width - edgeBuffer;
            }
            
            // Enhanced left edge detection - ensure dropdown doesn't go off left edge
            if (left < edgeBuffer) {
                left = edgeBuffer;
                // If dropdown is still too wide for screen, reduce its width
                if (menuRect.width > viewportWidth - (2 * edgeBuffer)) {
                    menu.style.maxWidth = (viewportWidth - (2 * edgeBuffer)) + 'px';
                    menu.style.overflowY = 'auto';
                }
            }
        } else {
            // For left-aligned dropdowns, check if they extend beyond right edge
            if (left + menuRect.width > viewportWidth - edgeBuffer) {
                // Try aligning to right edge of toggle button first
                let rightAlignedLeft = toggleRect.right - menuRect.width;
                if (rightAlignedLeft >= edgeBuffer) {
                    left = rightAlignedLeft;
                    menu.classList.add('dropdown-menu-end');
                } else {
                    // If that still doesn't work, force it to fit within viewport
                    left = viewportWidth - menuRect.width - edgeBuffer;
                    if (left < edgeBuffer) {
                        left = edgeBuffer;
                        menu.style.maxWidth = (viewportWidth - (2 * edgeBuffer)) + 'px';
                        menu.style.overflowY = 'auto';
                    }
                }
            } else {
                menu.classList.remove('dropdown-menu-end');
            }
            // Ensure left-aligned dropdowns don't go off the left edge
            left = Math.max(edgeBuffer, left);
        }
        
        // Enhanced bottom edge detection
        if (top + menuRect.height > viewportHeight - bottomBuffer) {
            // Try showing above the toggle button
            let newTop = toggleRect.top - menuRect.height - 8;
            if (newTop >= 0) {
                top = newTop;
            } else {
                // If it doesn't fit above either, constrain height and add scroll
                top = edgeBuffer;
                menu.style.maxHeight = (viewportHeight - (2 * edgeBuffer)) + 'px';
                menu.style.overflowY = 'auto';
            }
        }
        
        // Apply positioning with !important to override any conflicting CSS
        menu.style.setProperty('left', left + 'px', 'important');
        menu.style.setProperty('top', top + 'px', 'important');
        menu.style.setProperty('right', 'auto', 'important');
        menu.style.setProperty('bottom', 'auto', 'important');
        menu.style.setProperty('position', 'fixed', 'important');
        menu.style.opacity = '1'; // Make visible again
        
        // Debug logging (can be removed in production)
        if (window.location.hostname === 'localhost' || window.location.hostname === '127.0.0.1') {
            console.log('Dropdown positioned:', {
                toggleRect: toggleRect,
                menuRect: menuRect,
                finalLeft: left,
                finalTop: top,
                viewportWidth: viewportWidth,
                isRightAligned: isRightAligned
            });
        }
    }
    
    // Enhanced Search functionality
    // Global function for hiding suggestions
    window.hideSuggestions = function() {
    // Support multiple suggestion containers: topbar (searchSuggestionsTop), navbar (searchSuggestions),
    // and main search page (suggestions)
    const searchSuggestions = document.getElementById('searchSuggestionsTop') || document.getElementById('searchSuggestions') || document.getElementById('suggestions');
    const searchInput = document.getElementById('quickSearchInputTop') || document.getElementById('quickSearchInput');
        
        if (searchSuggestions) {
            searchSuggestions.classList.remove('show');
            // Force-hide and clear positioning so nothing remains visible
            try {
                searchSuggestions.style.setProperty('display', 'none', 'important');
                searchSuggestions.style.setProperty('visibility', 'hidden', 'important');
                searchSuggestions.style.setProperty('opacity', '0', 'important');
                searchSuggestions.style.setProperty('pointer-events', 'none', 'important');
                // Remove leftover positioning to avoid thin lines from borders/shadows
                searchSuggestions.style.removeProperty('left');
                searchSuggestions.style.removeProperty('top');
                searchSuggestions.style.removeProperty('right');
                searchSuggestions.style.removeProperty('bottom');
                searchSuggestions.style.removeProperty('position');
                searchSuggestions.style.removeProperty('width');
                searchSuggestions.style.removeProperty('border');
                searchSuggestions.style.removeProperty('box-shadow');
                searchSuggestions.style.removeProperty('background');
            } catch (e) { /* non-fatal */ }

            selectedIndex = -1;
            if (searchInput) {
                searchInput.setAttribute('aria-expanded', 'false');
            }
            console.log('Suggestions hidden');
        }
    };

    // Global variables for search functionality
    let searchTimeout;
    let selectedIndex = -1;
    let currentSuggestions = [];
    
    // Global function for selecting suggestions
    window.selectSuggestion = function(text, type, searchQuery) {
        const searchInput = document.getElementById('quickSearchInput');
        const searchSuggestions = document.getElementById('searchSuggestions');
        
        if (searchInput) {
            // Use the provided searchQuery if available, otherwise fall back to extraction logic
            let finalSearchQuery = searchQuery;
            
            if (!finalSearchQuery) {
                // Extract meaningful search terms based on type (fallback)
                if (type === 'team') {
                    // For team suggestions like "Team 5454 - Obsidian", extract the team number
                    const teamNumberMatch = text.match(/Team (\d+)/);
                    if (teamNumberMatch) {
                        finalSearchQuery = teamNumberMatch[1]; // Just the team number (e.g., "5454")
                    } else {
                        // If no team number found, use the full text
                        finalSearchQuery = text;
                    }
                } else if (type === 'user') {
                    // For users, use the username as-is
                    finalSearchQuery = text;
                } else {
                    // For other types, use the full text
                    finalSearchQuery = text;
                }
            }
            
            console.log('Selected suggestion:', text, 'Searching for:', finalSearchQuery);
            
            searchInput.value = finalSearchQuery;
            window.hideSuggestions();
            
            // Navigate to search page with the optimized query
            window.location.href = `/search?q=${encodeURIComponent(finalSearchQuery)}`;
        }
    };

    function initSearchFunctionality() {
        // Check if screen is large enough for desktop search
        if (window.innerWidth < 992) {
            console.log('Screen too small for desktop search, skipping initialization');
            return;
        }
        
    const searchInput = document.getElementById('quickSearchInputTop') || document.getElementById('quickSearchInput');
    const searchSuggestions = document.getElementById('searchSuggestionsTop') || document.getElementById('searchSuggestions');
    const searchClearBtn = document.getElementById('searchClearBtnTop') || document.getElementById('searchClearBtn');
        
        console.log('Search elements found:', {
            searchInput: !!searchInput,
            searchSuggestions: !!searchSuggestions,
            searchClearBtn: !!searchClearBtn
        });
        
        if (!searchInput) {
            console.warn('No search input element found');
            return;
        }
        
        if (!searchSuggestions) {
            console.warn('searchSuggestions element not found');
            return;
        }
        
        // Position search suggestions using absolute positioning
        function positionSearchSuggestions() {
            if (!searchSuggestions || !searchInput) return;

            // If the dropdown is not currently being shown, ensure it remains hidden
            if (!searchSuggestions.classList.contains('show') && !searchSuggestions.querySelector('.search-loading') && !searchSuggestions.querySelector('.suggestion-item')) {
                // Remove any aggressive positioning and force-hide to avoid a visible border or thin line
                try {
                    searchSuggestions.style.setProperty('display', 'none', 'important');
                    searchSuggestions.style.setProperty('visibility', 'hidden', 'important');
                    searchSuggestions.style.setProperty('opacity', '0', 'important');
                    // Also remove position to avoid any residual artifacts
                    searchSuggestions.style.removeProperty('left');
                    searchSuggestions.style.removeProperty('top');
                    searchSuggestions.style.removeProperty('right');
                    searchSuggestions.style.removeProperty('bottom');
                    searchSuggestions.style.removeProperty('position');
                    searchSuggestions.style.removeProperty('width');
                } catch (e) { /* non-fatal */ }
                return;
            }

            console.log('Positioning search suggestions');

            // Get the search input wrapper position
            const inputWrapper = searchInput.closest('.search-input-wrapper');
            if (!inputWrapper) return;
            const inputRect = inputWrapper.getBoundingClientRect();

            // Position dropdown directly below the search bar (only apply when visible)
            searchSuggestions.style.setProperty('position', 'fixed', 'important');
            searchSuggestions.style.setProperty('top', (inputRect.bottom + 8) + 'px', 'important');
            searchSuggestions.style.setProperty('left', inputRect.left + 'px', 'important');
            searchSuggestions.style.setProperty('width', Math.max(inputRect.width, 300) + 'px', 'important');
            searchSuggestions.style.setProperty('z-index', '2147483647', 'important');
            searchSuggestions.style.setProperty('background', 'var(--bs-body-bg)', 'important');
            searchSuggestions.style.setProperty('border', '1px solid var(--bs-border-color)', 'important');
            searchSuggestions.style.setProperty('border-radius', '12px', 'important');
            searchSuggestions.style.setProperty('box-shadow', '0 8px 32px rgba(0, 0, 0, 0.15)', 'important');
            searchSuggestions.style.setProperty('pointer-events', 'auto', 'important');
            searchSuggestions.style.setProperty('overflow-y', 'auto', 'important');
            searchSuggestions.style.setProperty('max-height', '400px', 'important');
            searchSuggestions.style.setProperty('backdrop-filter', 'blur(10px)', 'important');
            searchSuggestions.style.setProperty('-webkit-backdrop-filter', 'blur(10px)', 'important');

            // Ensure display/visibility/opactiy are set only when actually showing
            searchSuggestions.style.setProperty('display', 'block', 'important');
            searchSuggestions.style.setProperty('visibility', 'visible', 'important');
            searchSuggestions.style.setProperty('opacity', '1', 'important');

            console.log('Modern dropdown positioning applied');
        }
        
        // Show loading state
        function showLoading() {
            if (!searchSuggestions) return;
            console.log('Showing loading state');
            searchSuggestions.innerHTML = `
                <div class="search-loading" style="padding: 16px; text-align: center; color: var(--bs-secondary);">
                    <div class="spinner-border spinner-border-sm me-2" role="status" aria-hidden="true"></div>
                    Searching...
                </div>
            `;
            searchSuggestions.classList.add('show');
            positionSearchSuggestions();
        }
        
        // Handle search input with debouncing
        searchInput.addEventListener('input', function(e) {
            clearTimeout(searchTimeout);
            const query = this.value.trim();
            
            console.log('Input event (top/global):', query, 'length:', query.length);
            
            // Show/hide clear button
            if (searchClearBtn) {
                searchClearBtn.style.display = query ? 'flex' : 'none';
            }
            
            // Update ARIA attributes
            searchInput.setAttribute('aria-expanded', query.length >= 2 ? 'true' : 'false');
            
            // Hide suggestions immediately if search is empty
            if (query.length === 0) {
                window.hideSuggestions();
                return;
            }
            
            if (query.length < 2) {
                window.hideSuggestions();
                return;
            }
            
            // Show loading immediately for better UX
            showLoading();
            
            searchTimeout = setTimeout(() => {
                console.log('Fetching suggestions for:', query);
                fetchSuggestions(query);
            }, 300); // Increased delay to reduce API calls
        });
        
        // Clear button functionality
        if (searchClearBtn) {
            searchClearBtn.addEventListener('click', function() {
                searchInput.value = '';
                searchInput.focus();
                window.hideSuggestions();
                this.style.display = 'none';
                searchInput.setAttribute('aria-expanded', 'false');
            });
        }
        
        // Hide suggestions when search input loses focus (with delay for clicks)
        searchInput.addEventListener('blur', function() {
            // Small delay to allow for clicking on suggestions
            setTimeout(() => {
                window.hideSuggestions();
            }, 150);
        });
        
        // Show suggestions when search input gains focus (if there's content)
        searchInput.addEventListener('focus', function() {
            if (this.value.trim().length >= 2 && currentSuggestions.length > 0) {
                searchSuggestions.classList.add('show');
                positionSearchSuggestions();
            }
        });
        
        // Add click event delegation for suggestion items
        if (searchSuggestions) {
            searchSuggestions.addEventListener('click', function(e) {
                const suggestionItem = e.target.closest('.suggestion-item');
                if (suggestionItem) {
                    const url = suggestionItem.getAttribute('data-url');
                    if (url) {
                        window.location.href = url;
                        return;
                    }

                    const text = suggestionItem.getAttribute('data-value');
                    const type = suggestionItem.getAttribute('data-type');
                    const searchQuery = suggestionItem.getAttribute('data-search-query');
                    if (text && type) {
                        window.selectSuggestion(text, type, searchQuery);
                    }
                }
            });
        } else {
            console.warn('searchSuggestions element not found for event delegation');
        }
        
        // Reposition dropdown on window resize
        window.addEventListener('resize', function() {
            if (searchSuggestions && searchSuggestions.classList.contains('show')) {
                positionSearchSuggestions();
            }
        });
        
        // Reposition dropdown on scroll
        window.addEventListener('scroll', function() {
            if (searchSuggestions && searchSuggestions.classList.contains('show')) {
                positionSearchSuggestions();
            }
        });
        
        window.addEventListener('resize', positionSearchSuggestions);
        
        // Enhanced keyboard navigation
        searchInput.addEventListener('keydown', function(e) {
            const suggestions = searchSuggestions?.querySelectorAll('.suggestion-item');
            
            if (!suggestions || suggestions.length === 0) {
                if (e.key === 'Enter') {
                    e.preventDefault();
                    performQuickSearch();
                }
                return;
            }
            
            switch (e.key) {
                case 'ArrowDown':
                    e.preventDefault();
                    selectedIndex = Math.min(selectedIndex + 1, suggestions.length - 1);
                    updateSelectedSuggestion(suggestions);
                    scrollToActiveSuggestion();
                    break;
                case 'ArrowUp':
                    e.preventDefault();
                    selectedIndex = Math.max(selectedIndex - 1, -1);
                    updateSelectedSuggestion(suggestions);
                    scrollToActiveSuggestion();
                    break;
                case 'Enter':
                    e.preventDefault();
                    if (selectedIndex >= 0 && suggestions[selectedIndex]) {
                        const text = suggestions[selectedIndex].getAttribute('data-value');
                        const type = suggestions[selectedIndex].getAttribute('data-type');
                        const searchQuery = suggestions[selectedIndex].getAttribute('data-search-query');
                        if (text && type) {
                            window.selectSuggestion(text, type, searchQuery);
                        }
                    } else {
                        performQuickSearch();
                    }
                    break;
                case 'Escape':
                    window.hideSuggestions();
                    searchInput.blur();
                    break;
                case 'Tab':
                    // Allow tabbing through suggestions
                    if (selectedIndex >= 0 && suggestions[selectedIndex]) {
                        e.preventDefault();
                        const text = suggestions[selectedIndex].getAttribute('data-value');
                        const type = suggestions[selectedIndex].getAttribute('data-type');
                        const searchQuery = suggestions[selectedIndex].getAttribute('data-search-query');
                        if (text && type) {
                            window.selectSuggestion(text, type, searchQuery);
                        }
                    }
                    break;
            }
        });
        
        // Scroll active suggestion into view
        function scrollToActiveSuggestion() {
            const activeSuggestion = searchSuggestions?.querySelector('.suggestion-item.active');
            if (activeSuggestion && searchSuggestions) {
                const containerRect = searchSuggestions.getBoundingClientRect();
                const itemRect = activeSuggestion.getBoundingClientRect();
                
                if (itemRect.bottom > containerRect.bottom) {
                    activeSuggestion.scrollIntoView({ block: 'end', behavior: 'smooth' });
                } else if (itemRect.top < containerRect.top) {
                    activeSuggestion.scrollIntoView({ block: 'start', behavior: 'smooth' });
                }
            }
        }
        
        // Hide suggestions when clicking outside
        document.addEventListener('click', function(e) {
            // Don't hide if clicking on the search input, suggestions dropdown, or clear button
            if (!e.target.closest('.enhanced-search-container') && 
                !e.target.closest('#searchSuggestions') &&
                !e.target.closest('#searchClearBtn')) {
                window.hideSuggestions();
            }
        });
        
        // Prevent suggestions from hiding when clicking inside the dropdown
        if (searchSuggestions) {
            searchSuggestions.addEventListener('mousedown', function(e) {
                // Prevent the blur event from firing when clicking on suggestions
                e.preventDefault();
            });
        }
        
        // Enhanced fetch suggestions with categorization
        function fetchSuggestions(query) {
            console.log('Fetching suggestions for:', query); // Debug log

            // Request all suggestion types including pages and help for broad coverage
            const typesParam = 'team,user,match,scouting,page,help';

            fetch(`/search/api/suggestions?q=${encodeURIComponent(query)}&types=${encodeURIComponent(typesParam)}`)
                .then(response => {
                    console.log('Response received:', response.status); // Debug log
                    return response.json();
                })
                .then(data => {
                    console.log('Data received:', data); // Debug log
                    displaySuggestions(data.suggestions || []);
                })
                .catch(error => {
                    console.error('Error fetching suggestions:', error);
                    showNoResults();
                });
        }
        
        // Enhanced display suggestions with categories and icons
        function displaySuggestions(suggestions) {
            console.log('Displaying suggestions:', suggestions); // Debug log
            
            if (!searchSuggestions) {
                console.log('No searchSuggestions element found'); // Debug log
                return;
            }
            
            if (suggestions.length === 0) {
                console.log('No suggestions to display'); // Debug log
                showNoResults();
                return;
            }
            
            currentSuggestions = suggestions;
            console.log('Building HTML for', suggestions.length, 'suggestions'); // Debug log
            
            // Group suggestions by type
            const grouped = suggestions.reduce((acc, suggestion) => {
                const type = suggestion.type || 'other';
                if (!acc[type]) acc[type] = [];
                acc[type].push(suggestion);
                return acc;
            }, {});
            
            let html = '';
            
            // Define category order and labels
            const categoryOrder = ['team', 'user', 'match', 'scouting', 'page', 'help'];
            const categoryLabels = {
                'team': 'Teams',
                'user': 'Users',
                'match': 'Matches',
                'scouting': 'Scouting'
                , 'page': 'Pages',
                'help': 'Help & Docs'
            };
            
            // Build HTML with categories
            categoryOrder.forEach(type => {
                if (grouped[type] && grouped[type].length > 0) {
                    if (html) html += ''; // Separator between categories
                    html += `<div class="suggestion-category">${categoryLabels[type]}</div>`;
                    
                    grouped[type].forEach((suggestion, index) => {
                        const iconClass = getIconForType(suggestion.type);
                        const globalIndex = suggestions.indexOf(suggestion);
                        
                        html += `
                            <div class="suggestion-item" 
                                 data-index="${globalIndex}" 
                                 data-type="${suggestion.type}" 
                                 data-value="${escapeHtml(suggestion.text)}"
                                 data-search-query="${escapeHtml(suggestion.search_query || suggestion.text)}"
                                 data-url="${escapeHtml(suggestion.url || '')}"
                                 role="option">
                                <div class="suggestion-icon">
                                    <i class="${iconClass}"></i>
                                </div>
                                <div class="suggestion-content">
                                    <div class="suggestion-title">
                                        ${escapeHtml(suggestion.text)}
                                        ${suggestion.event_name || suggestion.event_code ? `<small class="text-muted ms-2">${escapeHtml((suggestion.event_name && suggestion.event_code) ? `${suggestion.event_name} (${suggestion.event_code})` : (suggestion.event_name || suggestion.event_code))}</small>` : ''}
                                    </div>
                                    <div class="suggestion-type">${suggestion.type}</div>
                                </div>
                            </div>
                        `;
                    });
                }
            });
            
            console.log('Generated HTML:', html.substring(0, 100) + '...'); // Debug log
            
            searchSuggestions.innerHTML = html;
            console.log('HTML set, adding show class');
            searchSuggestions.classList.add('show');
            console.log('Show class added, checking visibility:', getComputedStyle(searchSuggestions).display);
            positionSearchSuggestions();
            selectedIndex = -1;
            // If dark mode is active, enforce dark colors on the suggestion container
            try {
                if (document.documentElement.classList.contains('dark-mode')) {
                    searchSuggestions.style.setProperty('background', '#0b0b0d', 'important');
                    searchSuggestions.style.setProperty('color', '#ffffff', 'important');
                    searchSuggestions.style.setProperty('border-color', 'rgba(255,255,255,0.04)', 'important');
                    // Ensure individual suggestion items inherit readable colors
                    const items = searchSuggestions.querySelectorAll('.suggestion-item');
                    items.forEach(it => {
                        it.style.setProperty('background', 'transparent', 'important');
                        it.style.setProperty('color', '#ffffff', 'important');
                        const title = it.querySelector('.suggestion-title'); if (title) title.style.setProperty('color', '#ffffff', 'important');
                        const st = it.querySelector('.suggestion-type'); if (st) st.style.setProperty('color', '#bfbfbf', 'important');
                    });
                }
            } catch (e) { console && console.debug && console.debug('apply dark suggestion styles error', e); }
            
            // Debug: Check element dimensions and position
            const rect = searchSuggestions.getBoundingClientRect();
            console.log('Dropdown dimensions:', {
                width: rect.width,
                height: rect.height,
                top: rect.top,
                left: rect.left,
                visible: rect.width > 0 && rect.height > 0,
                hasContent: searchSuggestions.innerHTML.length > 0
            });
            
            console.log('Suggestions should now be visible'); // Debug log
            
            // Update ARIA attributes
            searchInput.setAttribute('aria-expanded', 'true');
            searchSuggestions.setAttribute('aria-activedescendant', '');
        }
        
        // Show no results message
        function showNoResults() {
            if (!searchSuggestions) return;
            console.log('Showing no results message'); // Debug log
            searchSuggestions.innerHTML = `
                <div class="no-suggestions">
                    <i class="fas fa-search-minus mb-2"></i><br>
                    No suggestions found
                </div>
            `;
            searchSuggestions.classList.add('show');
            positionSearchSuggestions();
        }
        
        // Update selected suggestion styling
        function updateSelectedSuggestion(suggestions) {
            suggestions.forEach((item, index) => {
                item.classList.toggle('active', index === selectedIndex);
            });
            
            // Update ARIA attributes
            if (selectedIndex >= 0 && suggestions[selectedIndex]) {
                const activeId = `suggestion-${selectedIndex}`;
                suggestions[selectedIndex].id = activeId;
                searchInput.setAttribute('aria-activedescendant', activeId);
            } else {
                searchInput.setAttribute('aria-activedescendant', '');
            }
        }
        
        // Enhanced icon mapping
        function getIconForType(type) {
            const icons = {
                'team': 'fas fa-users',
                'user': 'fas fa-user',
                'event': 'fas fa-calendar',
                'match': 'fas fa-gamepad',
                'scouting': 'fas fa-clipboard-list',
                'scouting_data': 'fas fa-clipboard-list'
                , 'page': 'fas fa-file-alt',
                'help': 'fas fa-book'
            };
            return icons[type] || 'fas fa-search';
        }
        
        // Escape HTML to prevent XSS
        function escapeHtml(text) {
            const div = document.createElement('div');
            div.textContent = text;
            return div.innerHTML;
        }
        
        // Perform quick search
        function performQuickSearch() {
            const query = searchInput.value.trim();
            if (query) {
                // Add a subtle animation before navigation
                searchInput.style.transform = 'scale(0.98)';
                setTimeout(() => {
                    window.location.href = `/search?q=${encodeURIComponent(query)}`;
                }, 100);
            }
        }
    }
    
    // Helper function for performQuickSearch (moved outside initSearchFunctionality)
    function performQuickSearch() {
        const searchInput = document.getElementById('quickSearchInput');
        if (searchInput) {
            const query = searchInput.value.trim();
            if (query) {
                window.location.href = `/search?q=${encodeURIComponent(query)}`;
            }
        }
    }
    </script>
    <script src="/static/js/countup-site.js"></script>
        <script>
        // Mobile viewport-height helper: write a --vh CSS variable that equals 1% of
        // the current window.innerHeight. This avoids layout clipping caused by
        // mobile browsers' dynamic UI (address bars/navigation bars). We call this
        // on load and resize/orientation changes so 100 * var(--vh) matches the
        // visible viewport.
        (function(){
            function setVh(){
                try{
                    var vh = (window.innerHeight || document.documentElement.clientHeight) * 0.01;
                    document.documentElement.style.setProperty('--vh', vh + 'px');
                }catch(e){}
            }
            setVh();
            window.addEventListener('resize', setVh, { passive: true });
            window.addEventListener('orientationchange', setVh, { passive: true });
            document.addEventListener('visibilitychange', function(){ if(!document.hidden) setVh(); });
        })();
        </script>
</body>
</html>