"""Create an Event, Teams, and scheduled Matches for a scouting team.

Configure variables in the CONFIG block below then run this file from the
project root. The script will use the application's Flask app context and
SQLAlchemy `db` object so it writes into the project's database.

Notes:
- Provide START_TIME as an ISO-8601 string; if it has no timezone the script
  treats it as UTC. The script will store scheduled times in UTC.
- Matches are generated by cycling through the provided team list in groups
  of 6 (3v3). This is a simple scheduling approach intended for test data and
  quick setup; it's not a competition-grade round-robin generator.

Usage (from project root):
    python -m scripts.add_event_teams_matches

"""
from datetime import datetime, timedelta, timezone
import sys
import os
import argparse

# Ensure project root is on sys.path when invoked as a module
PROJECT_ROOT = os.path.dirname(os.path.dirname(os.path.abspath(__file__)))
if PROJECT_ROOT not in sys.path:
    sys.path.insert(0, PROJECT_ROOT)

from app import create_app, db
from app.models import Event, Team, Match
from sqlalchemy.exc import IntegrityError


# ========== CONFIG: edit these variables ===========
EVENT_NAME = "Example Regional"
EVENT_CODE = "EXREG"
EVENT_YEAR = 2025
SCOUTING_TEAM_NUMBER = 5454  # Set to your scouting team number (or None)

# Provide a list of team numbers that will participate. Must be at least 6.
TEAMS = [254, 1114, 2056, 118, 1678, 1676, 148, 1241]

# Start time for the first match - ISO format recommended, include timezone
# Here we set it to 03:30 Central Standard Time on 2030-11-05.
# Use '-06:00' offset for CST (UTC-6). The script will convert this to UTC
# when storing scheduled_time in the database.
START_TIME = '2025-11-05T04:35:00-06:00'

MATCH_INTERVAL_MINUTES = 1  # Minutes between scheduled matches
MATCH_COUNT = 50  # Number of matches to create
MATCH_TYPE = 'qm'  # e.g., 'qm' for qualification

# Optional: base for match numbering. Will start at MATCH_NUMBER_START.
MATCH_NUMBER_START = 1
# ====================================================


def parse_iso_to_utc(s):
    """Parse an ISO datetime string and return a timezone-aware UTC datetime.
    If input has no tzinfo, treat it as UTC.
    """
    try:
        dt = datetime.fromisoformat(s)
    except Exception:
        # Fallback common format
        dt = datetime.strptime(s, '%Y-%m-%d %H:%M:%S')

    if dt.tzinfo is None:
        dt = dt.replace(tzinfo=timezone.utc)
    else:
        dt = dt.astimezone(timezone.utc)

    return dt


def ensure_event(session, name, code, year, scouting_team_number=None):
    # Normalize code to avoid duplicates due to casing/whitespace
    try:
        code_norm = code.strip().upper() if code else None
    except Exception:
        code_norm = code

    event = Event.query.filter_by(code=code_norm, scouting_team_number=scouting_team_number).first()
    if event:
        print(f"Using existing event id={event.id} name={event.name} code={event.code}")
        return event

    # Fallback: try by name+year
    if name and year is not None:
        event = Event.query.filter_by(name=name, year=year, scouting_team_number=scouting_team_number).first()
        if event:
            print(f"Using existing event by name id={event.id} name={event.name} code={event.code}")
            return event

    event = Event(name=name, code=code_norm if code_norm else code, year=year, scouting_team_number=scouting_team_number)
    session.add(event)
    try:
        session.commit()
        print(f"Created Event id={event.id} name={event.name} code={event.code}")
        return event
    except IntegrityError:
        # Race: another process created the event concurrently. Rollback and re-query.
        session.rollback()
        event = Event.query.filter_by(code=code_norm, scouting_team_number=scouting_team_number).first()
        if event:
            print(f"Race-resolved: using existing event id={event.id} name={event.name} code={event.code}")
            return event
        # As last resort, try lookup by name/year
        event = Event.query.filter_by(name=name, year=year, scouting_team_number=scouting_team_number).first()
        if event:
            return event
        # Re-raise if we cannot resolve
        raise


def ensure_team(session, team_number, team_name=None, scouting_team_number=None):
    team = Team.query.filter_by(team_number=team_number, scouting_team_number=scouting_team_number).first()
    if team:
        # Update name if provided
        if team_name and not team.team_name:
            team.team_name = team_name
            session.commit()
        return team

    team = Team(team_number=team_number, team_name=team_name or '', scouting_team_number=scouting_team_number)
    session.add(team)
    session.commit()
    print(f"Created Team id={team.id} number={team.team_number}")
    return team


def create_matches(session, event, teams, start_dt, interval_minutes, match_count, match_type, match_number_start=1, scouting_team_number=None):
    """Create match_count matches for event using teams list. Teams are used in
    rotating groups of 6 (3 red, 3 blue). scheduled_time is stored in UTC.
    Returns list of Match objects.
    """
    if len(teams) < 6:
        raise ValueError("At least 6 teams are required to create 3v3 matches.")

    created = []
    teams_list = list(teams)
    n = len(teams_list)

    for i in range(match_count):
        start_time = start_dt + timedelta(minutes=i * interval_minutes)
        start_idx = (i * 6) % n
        selected = [teams_list[(start_idx + j) % n] for j in range(6)]
        red = selected[:3]
        blue = selected[3:]

        red_str = ','.join(str(x) for x in red)
        blue_str = ','.join(str(x) for x in blue)

        match_number = match_number_start + i

        # Check if match already exists to avoid duplicates
        existing = Match.query.filter_by(event_id=event.id, match_number=match_number, match_type=match_type, scouting_team_number=scouting_team_number).first()
        if existing:
            print(f"Skipping existing Match {match_type} {match_number} (id={existing.id})")
            created.append(existing)
            continue

        m = Match(
            match_number=match_number,
            match_type=match_type,
            event_id=event.id,
            red_alliance=red_str,
            blue_alliance=blue_str,
            scheduled_time=start_time,
            scouting_team_number=scouting_team_number
        )
        session.add(m)
        created.append(m)

    session.commit()
    print(f"Created/verified {len(created)} matches for event id={event.id}")
    return created


def main():
    app = create_app()
    with app.app_context():
        start_dt = parse_iso_to_utc(START_TIME)
        # Use the event code defined in the script's CONFIG block
        event = ensure_event(db.session, EVENT_NAME, EVENT_CODE, EVENT_YEAR, scouting_team_number=SCOUTING_TEAM_NUMBER)

        # Ensure teams and associate them with event
        team_objs = []
        for tnum in TEAMS:
            team = ensure_team(db.session, tnum, scouting_team_number=SCOUTING_TEAM_NUMBER)
            # Associate with event if not already
            if event not in team.events:
                try:
                    team.events.append(event)
                    db.session.add(team)
                except Exception:
                    pass
            team_objs.append(team)

        # Commit team-event associations
        db.session.commit()

        # Create matches
        try:
            matches = create_matches(db.session, event, TEAMS, start_dt, MATCH_INTERVAL_MINUTES, MATCH_COUNT, MATCH_TYPE, match_number_start=MATCH_NUMBER_START, scouting_team_number=SCOUTING_TEAM_NUMBER)
        except Exception as e:
            print(f"Error creating matches: {e}")
            return

        print("Done. Summary:")
        print(f"  Event: {event.name} (id={event.id})")
        print(f"  Teams added/verified: {len(team_objs)}")
        print(f"  Matches created/verified: {len(matches)}")


if __name__ == '__main__':
    parser = argparse.ArgumentParser(description='Add event, teams, and scheduled matches to the database.')
    parser.add_argument('--start-time', '-s', help='ISO start time for first match (overrides START_TIME in file)')
    parser.add_argument('--match-count', '-n', type=int, help='Number of matches to create (overrides MATCH_COUNT)')
    parser.add_argument('--interval', '-i', type=int, help='Minutes between matches (overrides MATCH_INTERVAL_MINUTES)')
    args = parser.parse_args()

    # Apply overrides to module-level constants in a simple way (event code is set in file)
    if args.start_time:
        globals()['START_TIME'] = args.start_time
    if args.match_count:
        globals()['MATCH_COUNT'] = args.match_count
    if args.interval:
        globals()['MATCH_INTERVAL_MINUTES'] = args.interval

    main()
